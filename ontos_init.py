"""Unified initialization script for Project Ontos.

v2.4: Added interactive mode selection, --reconfig, and --non-interactive flags.

Prerequisites:
- Copy the `.ontos/` folder to your project root BEFORE running this script
- Copy this file (ontos_init.py) to your project root

This script will:
1. Verify .ontos/ exists (required)
2. Configure Ontos mode interactively
3. Create optional directories (.ontos-internal, docs)
4. Install git hooks
5. Generate the initial context map
"""

import os
import sys
import shutil
import subprocess
import argparse
import re

# Define paths relative to script location
PROJECT_ROOT = os.path.dirname(os.path.abspath(__file__))
HOOKS_DIR = os.path.join(PROJECT_ROOT, '.git', 'hooks')


def prompt_for_mode() -> str:
    """Interactive mode selection.
    
    Returns:
        Selected mode string: 'automated', 'prompted', or 'advisory'
    """
    print("""
1. How should Ontos handle session archiving?

   [1] Fully Automatic (recommended for solo devs)
       - Auto-archives session on git push
       - One log per branch per day (appends on subsequent pushes)
       - Zero friction, best practices enforced silently

   [2] Prompted (recommended for teams) [DEFAULT]
       - Push blocked until you archive
       - You choose event type, slug, and details
       - More control, ensures quality

   [3] Advisory (minimal)
       - Push shows reminder only
       - You decide if/when to archive
       - Maximum flexibility, risk of forgetting
""")
    
    while True:
        choice = input("Enter choice [1-3, default=2]: ").strip()
        if choice == '' or choice == '2':
            return 'prompted'
        elif choice == '1':
            return 'automated'
        elif choice == '3':
            return 'advisory'
        else:
            print("Please enter 1, 2, or 3")


def prompt_for_source() -> str:
    """Prompt for default source name.
    
    Returns:
        Source name or empty string to prompt each time.
    """
    print("""
2. What name should appear in logs?
   (This identifies who/what created the session log)
   
   Tip: Set ONTOS_SOURCE env var to override per-session
""")
    source = input("   Enter name (or blank to prompt each time): ").strip()
    return source


def generate_config(mode: str, source: str) -> None:
    """Generate ontos_config.py from template.
    
    Args:
        mode: Selected mode ('automated', 'prompted', 'advisory')
        source: Default source name or empty string
    """
    template_path = os.path.join(PROJECT_ROOT, '.ontos', 'templates', 'ontos_config.py.template')
    
    if os.path.exists(template_path):
        with open(template_path, 'r') as f:
            content = f.read()
        
        # Replace placeholders
        content = content.replace('{{MODE}}', mode)
        if source:
            content = content.replace('{{SOURCE_QUOTED}}', f'"{source}"')
        else:
            content = content.replace('{{SOURCE_QUOTED}}', 'None')
    else:
        # Fallback if template doesn't exist
        source_line = f'DEFAULT_SOURCE = "{source}"' if source else 'DEFAULT_SOURCE = None'
        content = f'''"""Ontos Configuration.

Generated by ontos_init.py. Edit this file to customize behavior.
"""

# Mode: "automated", "prompted", or "advisory"
ONTOS_MODE = "{mode}"

# Your name for log attribution
{source_line}

# Import defaults (required)
from .ontos.scripts.ontos_config_defaults import *
'''
    
    with open('ontos_config.py', 'w') as f:
        f.write(content)


def parse_existing_config() -> dict:
    """Parse existing ontos_config.py if present.
    
    Returns:
        Dictionary of current config values.
    """
    config = {}
    if not os.path.exists('ontos_config.py'):
        return config
    
    try:
        with open('ontos_config.py', 'r') as f:
            content = f.read()
        
        # Simple regex parsing for common patterns
        mode_match = re.search(r'ONTOS_MODE\s*=\s*["\'](\w+)["\']', content)
        if mode_match:
            config['ONTOS_MODE'] = mode_match.group(1)
        
        source_match = re.search(r'DEFAULT_SOURCE\s*=\s*["\']([^"\']+)["\']', content)
        if source_match:
            config['DEFAULT_SOURCE'] = source_match.group(1)
        
        # Capture any non-standard settings for preservation
        for line in content.split('\n'):
            if '=' in line and not line.strip().startswith('#'):
                match = re.match(r'(\w+)\s*=\s*(.+)', line.strip())
                if match:
                    key = match.group(1)
                    if key not in ['ONTOS_MODE', 'DEFAULT_SOURCE'] and key not in config:
                        config[key] = match.group(2)
    except Exception:
        pass
    
    return config


def reconfig() -> None:
    """Reconfigure Ontos while preserving custom settings."""
    print("══════════════════════════════════════════════════════════════")
    print("                   Ontos Reconfiguration")
    print("══════════════════════════════════════════════════════════════")
    
    current = parse_existing_config()
    current_mode = current.get('ONTOS_MODE', 'none')
    print(f"\nCurrent mode: {current_mode}")
    
    # Identify custom settings
    standard_keys = {'ONTOS_MODE', 'DEFAULT_SOURCE', 'DOCS_DIR', 'LOGS_DIR'}
    custom_settings = {k: v for k, v in current.items() if k not in standard_keys}
    
    if custom_settings:
        print("\nCustom settings detected (will be preserved):")
        for k, v in custom_settings.items():
            print(f"  - {k} = {v}")
    
    # Run interactive prompts
    mode = prompt_for_mode()
    source = prompt_for_source()
    
    # Generate new config
    generate_config(mode, source)
    
    # Append preserved custom settings
    if custom_settings:
        with open('ontos_config.py', 'a') as f:
            f.write("\n# Preserved custom settings\n")
            for k, v in custom_settings.items():
                f.write(f"{k} = {v}\n")
    
    print("\n══════════════════════════════════════════════════════════════")
    print(f"  ✓ Mode changed: {current_mode} → {mode}")
    if custom_settings:
        print(f"  ✓ Preserved {len(custom_settings)} custom setting(s)")
    print("══════════════════════════════════════════════════════════════\n")


def scaffold_starter_docs() -> None:
    """Create starter documentation templates if they don't exist."""
    # Create Common_Concepts.md if it doesn't exist
    concepts_path = 'docs/reference/Common_Concepts.md'
    if not os.path.exists(concepts_path):
        os.makedirs(os.path.dirname(concepts_path), exist_ok=True)
        with open(concepts_path, 'w') as f:
            f.write("""---
id: common_concepts
type: atom
status: active
depends_on: []
---

# Common Concepts

Standard vocabulary for tagging logs and documents.

| Concept | Description |
|---------|-------------|
| `api` | API design or implementation |
| `auth` | Authentication and authorization |
| `ci` | Continuous integration |
| `config` | Configuration management |
| `docs` | Documentation |
| `test` | Testing |
| `ux` | User experience |
""")
        print("  Created docs/reference/Common_Concepts.md")


def main():
    parser = argparse.ArgumentParser(
        description='Initialize or reconfigure Project Ontos'
    )
    parser.add_argument(
        '--reconfig',
        action='store_true',
        help='Reconfigure Ontos mode (preserves custom settings)'
    )
    parser.add_argument(
        '--non-interactive',
        action='store_true',
        help='Run without prompts (uses defaults or specified values)'
    )
    parser.add_argument(
        '--mode',
        choices=['automated', 'prompted', 'advisory'],
        default='prompted',
        help='Mode for non-interactive setup (default: prompted)'
    )
    parser.add_argument(
        '--source',
        default='',
        help='Default source name for non-interactive setup'
    )
    
    args = parser.parse_args()
    
    # Handle --reconfig
    if args.reconfig:
        reconfig()
        return
    
    print("══════════════════════════════════════════════════════════════")
    print("             Welcome to Project Ontos v2.4 Setup")
    print("══════════════════════════════════════════════════════════════")
    
    # 1. Ensure .ontos directory exists
    if not os.path.exists('.ontos/scripts'):
        print("\n❌ Error: .ontos/scripts not found.")
        print("   Please ensure you have cloned Project Ontos correctly.")
        print("   If installing into a new project, copy the .ontos directory first.")
        sys.exit(1)
        
    # 2. Configure mode
    print("\n1. Configuring Ontos mode...")
    
    if args.non_interactive:
        mode = args.mode
        source = args.source
        print(f"   Using non-interactive mode: {mode}")
        if source:
            print(f"   Using source: {source}")
    elif os.path.exists('ontos_config.py'):
        print("   ontos_config.py already exists (run --reconfig to change)")
        mode = None
        source = None
    else:
        mode = prompt_for_mode()
        source = prompt_for_source()
    
    # Generate config if mode was selected
    if mode:
        generate_config(mode, source)
        print(f"\n   ✓ Created ontos_config.py (mode: {mode})")
    
    # 3. Set up directories
    print("\n2. Setting up directories...")
    dirs = [
        'docs',
        'docs/reference',
        'docs/logs'
    ]
    
    for d in dirs:
        if not os.path.exists(d):
            os.makedirs(d)
            print(f"   Created {d}/")
        else:
            print(f"   {d}/ already exists")

    # 4. Install git hooks
    print("\n3. Installing git hooks...")
    
    if not os.path.exists(HOOKS_DIR):
        try:
            os.makedirs(HOOKS_DIR)
        except OSError:
            pass
            
    bash_hook_src = os.path.join(PROJECT_ROOT, '.ontos', 'hooks', 'pre-push')
    bash_hook_dst = os.path.join(HOOKS_DIR, 'pre-push')
    
    if os.path.exists(bash_hook_src):
        try:
            shutil.copy2(bash_hook_src, bash_hook_dst)
            st = os.stat(bash_hook_dst)
            os.chmod(bash_hook_dst, st.st_mode | 0o111)
            print("   ✓ Installed pre-push hook")
        except Exception as e:
            print(f"   ⚠ Warning: Failed to install pre-push hook: {e}")
    else:
        print("   ⚠ Warning: Pre-push hook source not found")

    # 5. Create starter documentation
    print("\n4. Creating starter documentation...")
    scaffold_starter_docs()
    
    # 6. Generate initial Context Map
    print("\n5. Generating initial Context Map...")
    try:
        subprocess.run([sys.executable, '.ontos/scripts/ontos_generate_context_map.py'], 
                       check=True, capture_output=True)
        print("   ✓ Context map generated")
    except subprocess.CalledProcessError:
        print("   ⚠ Warning: Context map generation failed")
        
    print("\n══════════════════════════════════════════════════════════════")
    print("                  ✅ Ontos initialized!")
    print("══════════════════════════════════════════════════════════════")
    print("\nNext steps:")
    print("  1. Review ontos_config.py")
    print("  2. Start working on your project")
    print("  3. Before pushing, run 'Archive Ontos' to log your session")
    print("")

if __name__ == "__main__":
    main()
