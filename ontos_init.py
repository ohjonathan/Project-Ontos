"""Unified initialization script for Project Ontos.

v2.4: Added interactive mode selection, --reconfig, and --non-interactive flags.

Prerequisites:
- Copy the `.ontos/` folder to your project root BEFORE running this script
- Copy this file (ontos_init.py) to your project root

This script will:
1. Verify .ontos/ exists (required)
2. Configure Ontos mode interactively
3. Create optional directories (.ontos-internal, docs)
4. Install git hooks
5. Generate the initial context map
"""

import os
import sys
import shutil
import subprocess
import argparse
import re

# Define paths relative to script location
PROJECT_ROOT = os.path.dirname(os.path.abspath(__file__))
HOOKS_DIR = os.path.join(PROJECT_ROOT, '.git', 'hooks')


def prompt_for_mode() -> str:
    """Interactive mode selection with promises.
    
    Returns:
        Selected mode string: 'automated', 'prompted', or 'advisory'
    """
    print("""
+================================================================+
|                    Choose Your Workflow                        |
+================================================================+

   [1] Automated (recommended for solo devs)

       "Zero friction - just works."

       - Sessions auto-archived on push
       - Old logs auto-consolidated on commit
       - Nothing left behind, you focus on building

   ----------------------------------------------------------------

   [2] Prompted (recommended for teams) [DEFAULT]

       "Keep me in the loop."

       - Push blocked until you archive
       - Consolidation warning shown at activation
       - Full control with gentle guidance

   ----------------------------------------------------------------

   [3] Advisory (for power users)

       "Maximum flexibility."

       - Warnings only, never blocks
       - You decide if/when to archive
       - Run consolidation on your schedule

+================================================================+
""")

    while True:
        choice = input("Enter choice [1-3, default=2]: ").strip()
        if choice == '' or choice == '2':
            return 'prompted'
        elif choice == '1':
            return 'automated'
        elif choice == '3':
            return 'advisory'
        else:
            print("Please enter 1, 2, or 3")


def prompt_for_source() -> str:
    """Prompt for default source name.
    
    Returns:
        Source name or empty string to prompt each time.
    """
    print("""
2. What name should appear in logs?
   (This identifies who/what created the session log)
   
   Tip: Set ONTOS_SOURCE env var to override per-session
""")
    source = input("   Enter name (or blank to prompt each time): ").strip()
    return source


def generate_config(mode: str, source: str) -> None:
    """Generate ontos_config.py from template.
    
    Args:
        mode: Selected mode ('automated', 'prompted', 'advisory')
        source: Default source name or empty string
    """
    template_path = os.path.join(PROJECT_ROOT, '.ontos', 'templates', 'ontos_config.py.template')
    
    if os.path.exists(template_path):
        with open(template_path, 'r') as f:
            content = f.read()
        
        # Replace placeholders
        content = content.replace('{{MODE}}', mode)
        if source:
            content = content.replace('{{SOURCE_QUOTED}}', f'"{source}"')
        else:
            content = content.replace('{{SOURCE_QUOTED}}', 'None')
    else:
        # Fallback if template doesn't exist
        source_line = f'DEFAULT_SOURCE = "{source}"' if source else 'DEFAULT_SOURCE = None'
        content = f'''"""Ontos Configuration.

Generated by ontos_init.py. Edit this file to customize behavior.
"""

# Mode: "automated", "prompted", or "advisory"
ONTOS_MODE = "{mode}"

# Your name for log attribution
{source_line}

# Import defaults (required)
from .ontos.scripts.ontos_config_defaults import *
'''
    
    with open('ontos_config.py', 'w') as f:
        f.write(content)


def parse_existing_config() -> dict:
    """Parse existing ontos_config.py if present.
    
    Returns:
        Dictionary of current config values.
    """
    config = {}
    if not os.path.exists('ontos_config.py'):
        return config
    
    try:
        with open('ontos_config.py', 'r') as f:
            content = f.read()
        
        # Simple regex parsing for common patterns
        mode_match = re.search(r'ONTOS_MODE\s*=\s*["\'](\w+)["\']', content)
        if mode_match:
            config['ONTOS_MODE'] = mode_match.group(1)
        
        source_match = re.search(r'DEFAULT_SOURCE\s*=\s*["\']([^"\']+)["\']', content)
        if source_match:
            config['DEFAULT_SOURCE'] = source_match.group(1)
        
        # Capture any non-standard settings for preservation
        for line in content.split('\n'):
            if '=' in line and not line.strip().startswith('#'):
                match = re.match(r'(\w+)\s*=\s*(.+)', line.strip())
                if match:
                    key = match.group(1)
                    if key not in ['ONTOS_MODE', 'DEFAULT_SOURCE'] and key not in config:
                        config[key] = match.group(2)
    except Exception:
        pass
    
    return config


def reconfig(args=None) -> None:
    """Reconfigure Ontos while preserving custom settings.

    Args:
        args: Optional argparse namespace with mode/source for non-interactive use.
    """
    print("══════════════════════════════════════════════════════════════")
    print("                   Ontos Reconfiguration")
    print("══════════════════════════════════════════════════════════════")

    current = parse_existing_config()
    current_mode = current.get('ONTOS_MODE', 'none')
    print(f"\nCurrent mode: {current_mode}")

    # Identify custom settings
    standard_keys = {'ONTOS_MODE', 'DEFAULT_SOURCE', 'DOCS_DIR', 'LOGS_DIR'}
    custom_settings = {k: v for k, v in current.items() if k not in standard_keys}

    if custom_settings:
        print("\nCustom settings detected (will be preserved):")
        for k, v in custom_settings.items():
            print(f"  - {k} = {v}")

    # Handle non-interactive environments
    is_interactive = sys.stdin.isatty()
    if not is_interactive:
        mode = args.mode if args else 'prompted'
        source = args.source if args else ''
        print(f"\n   ⚠ Non-interactive environment detected")
        print(f"   Using: mode={mode}, source={'(prompt each time)' if not source else source}")
    else:
        # Run interactive prompts
        mode = prompt_for_mode()
        source = prompt_for_source()
    
    # Generate new config
    generate_config(mode, source)
    
    # Append preserved custom settings
    if custom_settings:
        with open('ontos_config.py', 'a') as f:
            f.write("\n# Preserved custom settings\n")
            for k, v in custom_settings.items():
                f.write(f"{k} = {v}\n")
    
    print("\n══════════════════════════════════════════════════════════════")
    print(f"  ✓ Mode changed: {current_mode} → {mode}")
    if custom_settings:
        print(f"  ✓ Preserved {len(custom_settings)} custom setting(s)")
    print("══════════════════════════════════════════════════════════════\n")


def create_directory_structure() -> None:
    """Create complete Ontos directory structure for user mode.
    
    Creates all required directories for a fully functional Ontos installation.
    Respects DOCS_DIR config setting. Idempotent - safe to run multiple times.
    """
    # Get docs dir from config (respects custom DOCS_DIR)
    try:
        sys.path.insert(0, os.path.join(PROJECT_ROOT, '.ontos', 'scripts'))
        from ontos_lib import resolve_config
        docs_dir = resolve_config('DOCS_DIR', 'docs')
    except ImportError:
        docs_dir = 'docs'
    
    # Required directories for user mode
    directories = [
        docs_dir,
        f'{docs_dir}/logs',
        f'{docs_dir}/strategy',
        f'{docs_dir}/strategy/proposals',
        f'{docs_dir}/archive',
        f'{docs_dir}/archive/logs',
        f'{docs_dir}/archive/proposals',
        f'{docs_dir}/reference',
    ]
    
    created_any = False
    for directory in directories:
        path = os.path.join(PROJECT_ROOT, directory)
        if not os.path.exists(path):
            os.makedirs(path)
            print(f"   Created {directory}/")
            created_any = True
    
    if not created_any:
        print("   All directories already exist")


def check_and_warn_old_paths() -> None:
    """Check for files in old locations and warn user."""
    # Get docs dir from config
    try:
        sys.path.insert(0, os.path.join(PROJECT_ROOT, '.ontos', 'scripts'))
        from ontos_lib import resolve_config
        docs_dir = resolve_config('DOCS_DIR', 'docs')
    except ImportError:
        docs_dir = 'docs'
    
    old_paths = [
        (f'{docs_dir}/decision_history.md', f'{docs_dir}/strategy/decision_history.md'),
        (f'{docs_dir}/Common_Concepts.md', f'{docs_dir}/reference/Common_Concepts.md'),
    ]
    
    for old, new in old_paths:
        old_full = os.path.join(PROJECT_ROOT, old)
        new_full = os.path.join(PROJECT_ROOT, new)
        if os.path.exists(old_full) and not os.path.exists(new_full):
            print(f"   [DEPRECATION WARNING] Found '{old}' in old location.")
            print(f"   Recommended: mv {old} {new}")
            print("   This file will be auto-migrated in v2.6.0")


def scaffold_starter_docs() -> None:
    """Create starter documentation using canonical templates.
    
    Uses template files from .ontos/templates/ to ensure consistency
    between user-mode starters and contributor-mode references.
    Respects DOCS_DIR config setting. Idempotent - safe to run multiple times.
    """
    # Get docs dir from config
    try:
        sys.path.insert(0, os.path.join(PROJECT_ROOT, '.ontos', 'scripts'))
        from ontos_lib import resolve_config
        docs_dir = resolve_config('DOCS_DIR', 'docs')
    except ImportError:
        docs_dir = 'docs'
    
    # Import template loader
    templates_dir = os.path.join(PROJECT_ROOT, '.ontos', 'templates')
    sys.path.insert(0, templates_dir)
    
    try:
        from templates import get_decision_history_template, get_common_concepts_template
    except ImportError:
        print("   Warning: Template loader not found, using inline templates")
        get_decision_history_template = None
        get_common_concepts_template = None
    
    # Create decision_history.md (in strategy/, not flat)
    decision_history_path = os.path.join(PROJECT_ROOT, docs_dir, 'strategy', 'decision_history.md')
    if not os.path.exists(decision_history_path):
        os.makedirs(os.path.dirname(decision_history_path), exist_ok=True)
        if get_decision_history_template:
            content = get_decision_history_template()
        else:
            content = """---
id: decision_history
type: strategy
status: active
depends_on: []
---

# Decision History

This document records key decisions made during development.

| Date | Slug | Decision | Outcome | Archive Path |
|------|------|----------|---------|--------------|
| | | | | |
"""
        with open(decision_history_path, 'w') as f:
            f.write(content)
        print(f"   Created {docs_dir}/strategy/decision_history.md")
    
    # Create Common_Concepts.md (in reference/)
    concepts_path = os.path.join(PROJECT_ROOT, docs_dir, 'reference', 'Common_Concepts.md')
    if not os.path.exists(concepts_path):
        os.makedirs(os.path.dirname(concepts_path), exist_ok=True)
        if get_common_concepts_template:
            content = get_common_concepts_template()
        else:
            content = """---
id: common_concepts
type: atom
status: active
depends_on: []
---

# Common Concepts

Standard vocabulary for tagging logs and documents.

| Concept | Description |
|---------|-------------|
| `architecture` | System design and structure |
| `bugfix` | Bug fixes and corrections |
| `config` | Configuration management |
| `docs` | Documentation |
| `feature` | New features |
| `refactor` | Code refactoring |
| `test` | Testing |
| `ux` | User experience |
"""
        with open(concepts_path, 'w') as f:
            f.write(content)
        print(f"   Created {docs_dir}/reference/Common_Concepts.md")
    
    # Check for files in old locations
    check_and_warn_old_paths()


def install_pre_commit_hook() -> bool:
    """Install pre-commit hook with conflict detection.

    Detects:
    - Husky (.husky/ directory)
    - pre-commit framework (.pre-commit-config.yaml)
    - Existing non-Ontos hooks

    Provides integration instructions instead of breaking user workflows.
    
    Returns:
        True if hook was installed, False otherwise.
    """
    pre_commit_src = os.path.join(PROJECT_ROOT, '.ontos', 'hooks', 'pre-commit')
    pre_commit_dst = os.path.join(HOOKS_DIR, 'pre-commit')

    if not os.path.exists(pre_commit_src):
        print("   ⚠ Warning: Pre-commit hook source not found")
        return False

    # Detect Husky
    husky_dir = os.path.join(PROJECT_ROOT, '.husky')
    if os.path.exists(husky_dir):
        print("\n   ⚠ Husky detected. Manual integration required:")
        print("   Add to .husky/pre-commit:")
        print("   python3 .ontos/scripts/ontos_pre_commit_check.py")
        return False

    # Detect pre-commit framework
    pre_commit_config = os.path.join(PROJECT_ROOT, '.pre-commit-config.yaml')
    if os.path.exists(pre_commit_config):
        print("\n   ⚠ pre-commit framework detected. Manual integration required:")
        print("   Add to .pre-commit-config.yaml:")
        print("""
   - repo: local
     hooks:
       - id: ontos-consolidate
         name: Ontos Auto-Consolidation
         entry: python3 .ontos/scripts/ontos_pre_commit_check.py
         language: system
         always_run: true
         pass_filenames: false
        """)
        return False

    # Check for existing non-Ontos hook
    if os.path.exists(pre_commit_dst):
        with open(pre_commit_dst, 'r') as f:
            content = f.read()
            if 'ontos' not in content.lower():
                print("\n   ⚠ Existing pre-commit hook detected")
                print("   Add this line to your existing hook:")
                print("   python3 .ontos/scripts/ontos_pre_commit_check.py")

                # In non-interactive environments, don't overwrite existing hooks
                if not sys.stdin.isatty():
                    print("   ℹ Skipping hook overwrite (non-interactive environment)")
                    return False

                response = input("   Overwrite existing hook? [y/N]: ").strip().lower()
                if response != 'y':
                    # Create backup and skip
                    backup = pre_commit_dst + '.backup'
                    shutil.copy2(pre_commit_dst, backup)
                    print(f"   ℹ Existing hook backed up to {backup}")
                    return False

    # Safe to install
    try:
        shutil.copy2(pre_commit_src, pre_commit_dst)
        st = os.stat(pre_commit_dst)
        os.chmod(pre_commit_dst, st.st_mode | 0o111)  # Make executable
        print("   ✓ Installed pre-commit hook")
        return True
    except Exception as e:
        print(f"   ⚠ Warning: Failed to install pre-commit hook: {e}")
        return False


def main():
    parser = argparse.ArgumentParser(
        description='Initialize or reconfigure Project Ontos'
    )
    parser.add_argument(
        '--reconfig',
        action='store_true',
        help='Reconfigure Ontos mode (preserves custom settings)'
    )
    parser.add_argument(
        '--non-interactive',
        action='store_true',
        help='Run without prompts (uses defaults or specified values)'
    )
    parser.add_argument(
        '--mode',
        choices=['automated', 'prompted', 'advisory'],
        default='prompted',
        help='Mode for non-interactive setup (default: prompted)'
    )
    parser.add_argument(
        '--source',
        default='',
        help='Default source name for non-interactive setup'
    )
    
    args = parser.parse_args()
    
    # Handle --reconfig
    if args.reconfig:
        reconfig(args)
        return
    
    print("══════════════════════════════════════════════════════════════")
    print("             Welcome to Project Ontos v2.5.2 Setup")
    print("══════════════════════════════════════════════════════════════")
    
    # 1. Ensure .ontos directory exists
    if not os.path.exists('.ontos/scripts'):
        print("\n❌ Error: .ontos/scripts not found.")
        print("   Please ensure you have cloned Project Ontos correctly.")
        print("   If installing into a new project, copy the .ontos directory first.")
        sys.exit(1)
        
    # 2. Configure mode
    print("\n1. Configuring Ontos mode...")
    
    # Detect non-interactive environment (CI/CD, IDE terminals, piped input)
    is_interactive = sys.stdin.isatty()

    if args.non_interactive or not is_interactive:
        mode = args.mode
        source = args.source
        if not is_interactive and not args.non_interactive:
            print(f"   ⚠ Non-interactive environment detected")
            print(f"   Using defaults: mode={mode}, source={'(prompt each time)' if not source else source}")
            print(f"   Tip: Use --mode <mode> --source <name> for explicit control")
        else:
            print(f"   Using non-interactive mode: {mode}")
            if source:
                print(f"   Using source: {source}")
    elif os.path.exists('ontos_config.py'):
        print("   ontos_config.py already exists (run --reconfig to change)")
        mode = None
        source = None
    else:
        mode = prompt_for_mode()
        source = prompt_for_source()
    
    # Generate config if mode was selected
    if mode:
        generate_config(mode, source)
        print(f"\n   ✓ Created ontos_config.py (mode: {mode})")
    
    # 3. Set up directories (complete structure for user mode)
    print("\n2. Setting up directories...")
    create_directory_structure()

    # 4. Install git hooks
    print("\n3. Installing git hooks...")
    
    if not os.path.exists(HOOKS_DIR):
        try:
            os.makedirs(HOOKS_DIR)
        except OSError:
            pass
            
    # Install pre-push hook
    bash_hook_src = os.path.join(PROJECT_ROOT, '.ontos', 'hooks', 'pre-push')
    bash_hook_dst = os.path.join(HOOKS_DIR, 'pre-push')
    
    if os.path.exists(bash_hook_src):
        try:
            shutil.copy2(bash_hook_src, bash_hook_dst)
            st = os.stat(bash_hook_dst)
            os.chmod(bash_hook_dst, st.st_mode | 0o111)
            print("   ✓ Installed pre-push hook")
        except Exception as e:
            print(f"   ⚠ Warning: Failed to install pre-push hook: {e}")
    else:
        print("   ⚠ Warning: Pre-push hook source not found")
    
    # Install pre-commit hook (v2.5+)
    install_pre_commit_hook()

    # 5. Create starter documentation
    print("\n4. Creating starter documentation...")
    scaffold_starter_docs()
    
    # 6. Generate initial Context Map
    print("\n5. Generating initial Context Map...")
    try:
        subprocess.run([sys.executable, '.ontos/scripts/ontos_generate_context_map.py'], 
                       check=True, capture_output=True)
        print("   ✓ Context map generated")
    except subprocess.CalledProcessError:
        print("   ⚠ Warning: Context map generation failed")
        
    print("\n══════════════════════════════════════════════════════════════")
    print("                  ✅ Ontos initialized!")
    print("══════════════════════════════════════════════════════════════")
    print("\nNext steps:")
    print("  1. Review ontos_config.py")
    print("  2. Start working on your project")
    print("  3. Before pushing, run 'Archive Ontos' to log your session")
    print("")

if __name__ == "__main__":
    main()
