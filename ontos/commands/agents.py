# ontos/commands/agents.py
"""
AI instruction file generation command.

Generates AGENTS.md and .cursorrules per Spec v3.0.2.
Replaces the legacy export command.
"""

from dataclasses import dataclass
from datetime import datetime
from pathlib import Path
from typing import Optional, Tuple, List


@dataclass
class AgentsOptions:
    """Configuration for agents command."""
    format: str = "agents"  # "agents", "cursor", "all"
    output_path: Optional[Path] = None
    force: bool = False


def find_repo_root() -> Path:
    """Find the repository root."""
    current = Path.cwd()

    for parent in [current] + list(current.parents):
        if (parent / ".ontos.toml").exists():
            return parent
        if (parent / ".git").exists():
            return parent

    return current


def _get_project_name(repo_root: Path) -> str:
    """Get project name from config or directory name."""
    try:
        from ontos.io.config import load_project_config
        config = load_project_config()
        if hasattr(config, 'project') and hasattr(config.project, 'name'):
            return config.project.name
    except Exception:
        pass
    return repo_root.name


def _get_doc_count(repo_root: Path) -> int:
    """Count markdown documents in docs directory."""
    try:
        from ontos.io.config import load_project_config
        config = load_project_config()
        docs_dir = repo_root / config.paths.docs_dir
    except Exception:
        docs_dir = repo_root / "docs"

    if not docs_dir.exists():
        return 0

    return len(list(docs_dir.rglob("*.md")))


def _get_context_map_mtime(repo_root: Path) -> Optional[datetime]:
    """Get last modified time of context map."""
    try:
        from ontos.io.config import load_project_config
        config = load_project_config()
        context_map = repo_root / config.paths.context_map
    except Exception:
        context_map = repo_root / "Ontos_Context_Map.md"

    if context_map.exists():
        mtime = context_map.stat().st_mtime
        return datetime.fromtimestamp(mtime)
    return None


def _generate_agents_md(repo_root: Path) -> str:
    """Generate AGENTS.md content with project stats."""
    project_name = _get_project_name(repo_root)
    doc_count = _get_doc_count(repo_root)
    context_map_mtime = _get_context_map_mtime(repo_root)
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M")

    last_updated = "N/A"
    if context_map_mtime:
        last_updated = context_map_mtime.strftime("%Y-%m-%d %H:%M")

    return f'''# AGENTS.md

> Generated by `ontos agents` on {timestamp}
> Regenerate with: `ontos agents`

## Project: {project_name}

This project uses **Ontos** for documentation management.

## Quick Start

1. Say **"Ontos"** or **"Activate Ontos"**
2. I will read `Ontos_Context_Map.md` and load relevant context
3. When done, say **"Archive Ontos"** to log your work

## Quick Reference

| Command | Purpose |
|---------|---------|
| `ontos map` | Regenerate context map |
| `ontos agents` | Generate instruction files |
| `ontos doctor` | Health check and validation |
| `ontos log -e "slug"` | Archive session work |
| `ontos query <id>` | Find document by ID |

## Project Stats

- **Documents:** {doc_count}
- **Last context map update:** {last_updated}

---
*If this file is stale (older than context map), run `ontos agents` to refresh.*
'''


def _generate_cursorrules(repo_root: Path) -> str:
    """Generate .cursorrules content."""
    project_name = _get_project_name(repo_root)
    doc_count = _get_doc_count(repo_root)
    context_map_mtime = _get_context_map_mtime(repo_root)
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M")

    last_updated = "N/A"
    if context_map_mtime:
        last_updated = context_map_mtime.strftime("%Y-%m-%d %H:%M")

    return f'''# .cursorrules
# Generated by ontos agents on {timestamp}
# Regenerate with: ontos agents --format=cursor

# Project: {project_name}

## Ontos Documentation System

This project uses Ontos for documentation management.

### Activation
When asked about documentation or project context:
1. Read `Ontos_Context_Map.md` to understand documentation structure
2. Follow document links to find relevant information
3. When session ends, remind user to run `ontos log` to archive work

### Key Commands
- `ontos map` - Regenerate context map
- `ontos agents` - Generate instruction files
- `ontos doctor` - Health check and validation
- `ontos log -e "slug"` - Archive session work
- `ontos query <id>` - Find document by ID

### Project Stats
- Documents: {doc_count}
- Last context map update: {last_updated}
'''


def agents_command(options: AgentsOptions) -> Tuple[int, str]:
    """
    Generate AI instruction files.

    Returns:
        Tuple of (exit_code, message)

    Exit Codes:
        0: Success
        1: File exists (use --force)
        2: Configuration error
    """
    try:
        repo_root = find_repo_root()
    except Exception as e:
        return 2, f"Configuration error: {e}"

    formats_to_generate: List[Tuple[str, Path, str]] = []

    if options.format in ("agents", "all"):
        output_path = options.output_path if options.format == "agents" else None
        agents_path = output_path or repo_root / "AGENTS.md"
        content = _generate_agents_md(repo_root)
        formats_to_generate.append(("AGENTS.md", agents_path, content))

    if options.format in ("cursor", "all"):
        output_path = options.output_path if options.format == "cursor" else None
        cursor_path = output_path or repo_root / ".cursorrules"
        content = _generate_cursorrules(repo_root)
        formats_to_generate.append((".cursorrules", cursor_path, content))

    # Path safety validation
    for name, path, _ in formats_to_generate:
        try:
            resolved_output = path.resolve()
            resolved_root = repo_root.resolve()
            resolved_output.relative_to(resolved_root)
        except ValueError:
            return 2, f"Error: Output path must be within repository root ({repo_root})"

    # Check for existing files
    if not options.force:
        for name, path, _ in formats_to_generate:
            if path.exists():
                return 1, f"{name} already exists at {path}. Use --force to overwrite."

    # Write files
    created_files = []
    try:
        for name, path, content in formats_to_generate:
            path.parent.mkdir(parents=True, exist_ok=True)
            path.write_text(content, encoding="utf-8")
            created_files.append(str(path))
    except Exception as e:
        return 2, f"Error writing file: {e}"

    if len(created_files) == 1:
        return 0, f"Created {created_files[0]}"
    else:
        return 0, f"Created {', '.join(created_files)}"
