---
id: v3_2_re_architecture_support_proposal
type: strategy
status: active
depends_on: [mission, constitution, ontos_agent_instructions]
concepts: [migration, export, decisions, architecture]
---

# Ontos v3.2: Re-Architecture Support Proposal

**Version:** 1.0
**Author:** Claude Opus 4.5
**Date:** 2026-01-26
**Status:** Draft (Pending Review)

---

## 1. Executive Summary

This proposal introduces **Re-Architecture Support** to Ontos—a suite of commands that help developers extract institutional knowledge when migrating projects to new technology stacks.

### The Problem

When a developer rebuilds a project (e.g., Python → TypeScript), they face "decision amnesia":
- **Technical decisions** are often embedded in code that will be rewritten
- **Architectural decisions** are scattered across logs, specs, and discussions
- **Strategic decisions** (why we chose X over Y) are hardest to recover

Ontos already captures this knowledge via its type hierarchy (kernel/strategy/product/atom) and session logs. But there's no tooling to **extract and organize** this knowledge for migration.

### The Solution

Three new commands:

| Command | Purpose | Output |
|---------|---------|--------|
| `ontos export` | Bulk extract documents with full content | JSON/YAML |
| `ontos decisions` | Generate migration-focused decision report | Markdown/JSON |
| `ontos migration-report` | Analyze dependency graph for migration safety | Markdown |

### Impact Assessment

| Category | Scope |
|----------|-------|
| New Files | 3 command modules |
| Modified Files | 4 (cli.py, frontmatter.py, 2 docs) |
| New Dependencies | None (stdlib only) |
| Breaking Changes | None |
| Backward Compatibility | Full |

---

## 2. Motivation & Use Case

### 2.1 The Finance-Engine Case Study

A real project tracked with Ontos during Python development. Key observations:

**What Ontos Captured Well:**
- Backward compatibility decisions (e.g., "use 4999 not None for UNCATEGORIZED")
- Architecture choices (e.g., "YAML rules over JSON for human editability")
- Risk assessments (e.g., "LLM malformed JSON → skip batch, don't crash")
- Phase boundaries (e.g., "Phase A must complete before Phase B due to schema dependency")

**What Was Hard to Extract:**
1. Decisions scattered across 12+ log files
2. No single "decisions.json" for downstream tools
3. No clear "what's safe to carry forward" guidance
4. Manual grep/search required to find "why did we choose X?"

### 2.2 The Re-Architecture Workflow (Current State)

```
1. Developer says: "We're rewriting in TypeScript"
2. Agent runs: ontos map → gets document list
3. Agent manually: reads each strategy/product doc
4. Agent manually: searches logs for "alternatives considered"
5. Agent manually: builds mental model of what survives migration
6. Result: Incomplete, time-consuming, error-prone
```

### 2.3 The Re-Architecture Workflow (Proposed)

```
1. Developer says: "We're rewriting in TypeScript"
2. Agent runs: ontos export --type strategy,product -o decisions.json
3. Agent runs: ontos decisions --migration-safe -o carry-forward.md
4. Agent runs: ontos migration-report
5. Result: Structured data + clear guidance on what survives
```

---

## 3. Detailed Design

### 3.1 Command: `ontos export`

#### 3.1.1 Purpose

Bulk export documents as structured data (JSON/YAML) with:
- Full frontmatter metadata
- Complete markdown content
- Dependency graph
- Provenance information

#### 3.1.2 CLI Interface

```bash
# Basic usage
ontos export -o output.json

# Filter by type (comma-separated)
ontos export --type strategy,product -o decisions.json

# Filter by concept
ontos export --concept pricing,architecture -o arch.json

# Filter by status
ontos export --status active,complete -o active.json

# Complex filter expression
ontos export --filter "type:strategy status:active" -o filtered.json

# Exclude content (metadata only)
ontos export --no-content -o index.json

# YAML output
ontos export --format yaml -o decisions.yaml
```

#### 3.1.3 Output Schema

```json
{
  "$schema": "ontos-export-v1",
  "exported_at": "2026-01-26T21:30:00Z",
  "ontos_version": "3.2.0",
  "source": {
    "project_name": "finance-engine",
    "git_remote": "github.com/user/finance-engine",
    "git_commit": "abc1234",
    "context_map_path": "Ontos_Context_Map.md"
  },
  "filters": {
    "types": ["strategy", "product"],
    "concepts": null,
    "status": ["active"],
    "expression": null
  },
  "summary": {
    "total_documents": 15,
    "by_type": {"strategy": 8, "product": 7},
    "by_status": {"active": 12, "draft": 3}
  },
  "documents": [
    {
      "id": "pricing_strategy",
      "type": "strategy",
      "status": "active",
      "path": "docs/strategy/pricing.md",
      "depends_on": ["mission", "audience"],
      "concepts": ["pricing", "business-model"],
      "created": "2025-12-01",
      "modified": "2026-01-15",
      "content": "# Pricing Strategy\n\nWe chose usage-based pricing because...",
      "content_hash": "sha256:abc123..."
    }
  ],
  "dependency_graph": {
    "nodes": ["mission", "pricing_strategy", "data_model"],
    "edges": [
      {"from": "pricing_strategy", "to": "mission"},
      {"from": "data_model", "to": "pricing_strategy"}
    ]
  }
}
```

#### 3.1.4 Implementation Notes

**New file:** `ontos/commands/export_data.py`

```python
@dataclass
class ExportDataOptions:
    types: Optional[List[str]] = None
    concepts: Optional[List[str]] = None
    status: Optional[List[str]] = None
    filter_expr: Optional[str] = None
    include_content: bool = True
    output_path: Optional[Path] = None
    format: str = "json"  # json, yaml


def export_data_command(options: ExportDataOptions) -> Tuple[int, str]:
    """Export documents as structured data."""
    # 1. Scan documents (reuse scan_docs_for_query)
    # 2. Apply filters
    # 3. Load content for each document
    # 4. Build dependency graph
    # 5. Serialize to JSON/YAML
    pass
```

**Modify:** `ontos/core/frontmatter.py`

Add function:
```python
def parse_full_document(filepath: str) -> Tuple[dict, str]:
    """Parse document returning (frontmatter_dict, content_str)."""
    pass
```

**Modify:** `ontos/cli.py`

Register command at line ~96:
```python
_register_export_data(subparsers, global_parser)
```

---

### 3.2 Command: `ontos decisions`

#### 3.2.1 Purpose

Generate a human-readable report of all decisions, organized for migration review. Extracts decision-relevant content from documents and logs.

#### 3.2.2 CLI Interface

```bash
# Generate markdown report
ontos decisions -o decisions.md

# JSON output for downstream tools
ontos decisions --format json -o decisions.json

# Filter to migration-safe (kernel + strategy + product, active status)
ontos decisions --migration-safe

# Include implementation decisions (atoms)
ontos decisions --include-atoms

# Verbose: include full document content
ontos decisions --verbose
```

#### 3.2.3 Output Format (Markdown)

```markdown
# Decision Extraction Report

**Generated:** 2026-01-26 21:30:00
**Project:** finance-engine
**Ontos Version:** 3.2.0

---

## Summary

| Type | Count | Migration Status |
|------|-------|------------------|
| Kernel | 2 | Always carry forward |
| Strategy | 8 | Carry forward |
| Product | 7 | Review for migration |
| Atom | 23 | Likely rewrite |
| Log | 45 | Reference only |

---

## Section 1: Foundational Decisions (Kernel)

These decisions define the project's identity and should ALWAYS survive migration.

### MISSION
**Path:** `.ontos-internal/kernel/mission.md`
**Status:** active

> Build a personal finance engine that automates categorization and journal entry generation.

**Core Principles:**
1. Local-first: All data stays on user's machine
2. LLM-augmented, not LLM-dependent: Works without AI, better with it
3. Audit trail: Every change is traceable

---

### CONSTITUTION
**Path:** `.ontos-internal/kernel/constitution.md`
**Status:** active
**Depends on:** mission

> Invariants that the system must always respect.

**Invariants:**
1. Never auto-approve transactions above $500
2. Always preserve original bank data
3. Categorization rules are human-editable YAML

---

## Section 2: Strategic Decisions (Strategy)

These decisions define the "how" at a high level. Carry forward unless strategy changes.

### PRICING_STRATEGY
**Path:** `docs/strategy/pricing.md`
**Status:** active
**Depends on:** mission, audience
**Concepts:** pricing, business-model

**Decision:** Usage-based pricing with free tier

**Rationale:**
- Aligns incentives with customer success
- Lower barrier for personal users
- Scales with business users

**Alternatives Rejected:**
- Flat-rate subscription: Punishes light users
- Per-seat licensing: Doesn't fit solo use case
- One-time purchase: No sustainable revenue for updates

---

### DATA_MODEL
**Path:** `docs/strategy/data_model.md`
**Status:** active
**Depends on:** mission
**Concepts:** architecture, data

**Decision:** Immutable transaction records + mutable categorization layer

**Rationale:**
- Bank data is source of truth, never modified
- Categorizations can be corrected without losing history
- Enables "what if" analysis on historical data

**Alternatives Rejected:**
- Single mutable record: Loses audit trail
- Event sourcing: Overkill for personal finance scale

---

## Section 3: Product Decisions (Product)

These decisions define features and user experience. Review for migration—some may change.

### CATEGORIZATION_UX
**Path:** `docs/product/categorization_ux.md`
**Status:** active
**Depends on:** data_model, pricing_strategy
**Concepts:** ux, categorization

**Decision:** Suggest → Review → Approve workflow

**Rationale:**
- LLM suggestions reduce manual work
- Human approval ensures accuracy
- Learning loop improves future suggestions

**Open Questions for Migration:**
- Should approval be batched or per-transaction?
- Should we support keyboard shortcuts?

---

## Section 4: Implementation Decisions (Atoms)

These decisions are tied to the current implementation. **Expect to rewrite** but preserve the intent.

### PARSER_IMPLEMENTATION
**Path:** `docs/atom/parser_implementation.md`
**Status:** active
**Depends on:** data_model
**Concepts:** implementation, csv

**Decision:** Custom CSV parser with configurable column mapping

**Intent to Preserve:**
- Support multiple bank formats
- Column mapping stored in YAML config
- Graceful handling of malformed rows

**Implementation Detail (May Change):**
- Python's csv module with custom dialect
- pandas fallback for complex Excel files

---

## Section 5: Key Decisions from Session Logs

Decisions extracted from development history.

### 2025-12-15: UNCATEGORIZED Representation
**Log:** `log_20251215_categorization_schema`
**Impacts:** data_model, api_spec

**Decision:** Use `category_id: 4999` (not `None`) for uncategorized transactions

**Rationale:**
- Downstream logic does `cat_id // 1000` which fails on None
- 4999 maps to "Expenses > Uncategorized" in category hierarchy
- Backward compatible with existing exports

---

### 2025-12-20: LLM Error Handling
**Log:** `log_20251220_llm_error_handling`
**Impacts:** categorization_engine

**Decision:** On malformed LLM response, skip batch and continue (don't crash)

**Rationale:**
- Personal finance is fault-tolerant
- Partial results still deliver value
- User can retry failed batches later

**Alternatives Rejected:**
- Crash on error: Too disruptive for background processing
- Retry forever: Wastes API quota on persistent errors

---

## Appendix A: Decision Index

| ID | Type | Status | Depends On |
|----|------|--------|------------|
| mission | kernel | active | - |
| constitution | kernel | active | mission |
| pricing_strategy | strategy | active | mission, audience |
| data_model | strategy | active | mission |
| categorization_ux | product | active | data_model, pricing_strategy |
| parser_implementation | atom | active | data_model |

---

## Appendix B: Concept Index

| Concept | Documents |
|---------|-----------|
| pricing | pricing_strategy |
| architecture | data_model, parser_implementation |
| ux | categorization_ux |
| categorization | categorization_ux, categorization_engine |
```

#### 3.2.4 Output Format (JSON)

```json
{
  "$schema": "ontos-decisions-v1",
  "generated_at": "2026-01-26T21:30:00Z",
  "project": "finance-engine",
  "summary": {
    "kernel": 2,
    "strategy": 8,
    "product": 7,
    "atom": 23,
    "log": 45
  },
  "decisions": [
    {
      "id": "pricing_strategy",
      "type": "strategy",
      "status": "active",
      "path": "docs/strategy/pricing.md",
      "migration_status": "carry_forward",
      "depends_on": ["mission", "audience"],
      "concepts": ["pricing", "business-model"],
      "decision_summary": "Usage-based pricing with free tier",
      "rationale": "Aligns incentives with customer success...",
      "alternatives_rejected": [
        {"option": "Flat-rate subscription", "reason": "Punishes light users"},
        {"option": "Per-seat licensing", "reason": "Doesn't fit solo use case"}
      ],
      "open_questions": []
    }
  ],
  "log_decisions": [
    {
      "date": "2025-12-15",
      "log_id": "log_20251215_categorization_schema",
      "decision_summary": "Use category_id: 4999 for uncategorized",
      "impacts": ["data_model", "api_spec"],
      "rationale": "Downstream logic does cat_id // 1000 which fails on None"
    }
  ]
}
```

#### 3.2.5 Implementation Notes

**New file:** `ontos/commands/decisions.py`

Key logic:
1. Load all documents via `parse_full_document()`
2. Extract decision-relevant sections:
   - Look for "## Decision", "## Rationale", "## Alternatives" headers
   - Parse "Key Decisions" section from logs
3. Classify migration status based on type hierarchy
4. Generate report in requested format

**Content extraction heuristics:**
```python
DECISION_HEADERS = [
    "decision", "key decision", "what we decided",
    "choice", "approach", "selected option"
]

RATIONALE_HEADERS = [
    "rationale", "why", "reasoning", "justification",
    "motivation", "because"
]

ALTERNATIVES_HEADERS = [
    "alternatives", "alternatives considered", "rejected",
    "what we didn't choose", "other options", "tradeoffs"
]
```

---

### 3.3 Command: `ontos migration-report`

#### 3.3.1 Purpose

Analyze the dependency graph to classify documents by migration safety:
- **Safe:** No dependencies on atoms (carry forward as-is)
- **Review:** Depends on atoms indirectly (may need updates)
- **Rewrite:** Is an atom (implementation-specific)

#### 3.3.2 CLI Interface

```bash
# Generate migration analysis
ontos migration-report

# Output to file
ontos migration-report -o migration.md

# JSON output
ontos migration-report --format json -o migration.json

# Verbose: show full dependency chains
ontos migration-report --verbose
```

#### 3.3.3 Output Format

```markdown
# Migration Analysis Report

**Generated:** 2026-01-26 21:30:00
**Project:** finance-engine

---

## Summary

| Category | Count | Action |
|----------|-------|--------|
| Safe to Carry Forward | 10 | Copy to new project |
| Needs Review | 5 | Update references |
| Likely Rewrite | 23 | Preserve intent, reimplement |

---

## Safe to Carry Forward

These documents have no dependencies on implementation-specific atoms.

| ID | Type | Depends On |
|----|------|------------|
| mission | kernel | - |
| constitution | kernel | mission |
| pricing_strategy | strategy | mission, audience |
| audience | strategy | mission |
| data_model | strategy | mission |

**Recommendation:** Copy these documents to the new project. Update file paths if directory structure changes.

---

## Needs Review

These documents depend on atoms (directly or indirectly). Review and update references.

| ID | Type | Atom Dependencies | Recommendation |
|----|------|-------------------|----------------|
| api_spec | product | parser_implementation | Update implementation references |
| categorization_ux | product | categorization_engine | Abstract implementation details |
| data_export | product | parser_implementation, export_format | Rewrite implementation section |

### Detail: api_spec

**Direct dependencies:** data_model (strategy)
**Transitive atom dependencies:** parser_implementation (via data_model references)

**Sections to review:**
- "## Input Format" references Python csv module
- "## Error Handling" mentions specific exception types

**Recommendation:** Keep the specification, update implementation examples.

---

## Likely Rewrite

These are atoms—implementation-specific documents that will likely be rewritten.

| ID | Concepts | Intent to Preserve |
|----|----------|-------------------|
| parser_implementation | csv, parsing | Multi-format support, graceful error handling |
| categorization_engine | llm, categorization | Suggest → Review → Approve flow |
| export_format | export, excel | Excel compatibility, column mapping |
| journal_generator | accounting, journal | Double-entry integrity |

**Recommendation:** Extract the intent and requirements from each atom. The implementation will change but the goals should survive.

---

## Dependency Graph Visualization

```
mission (kernel)
├── constitution (kernel)
├── audience (strategy)
│   └── pricing_strategy (strategy)
├── data_model (strategy)
│   ├── api_spec (product) ⚠️
│   │   └── parser_implementation (atom) ✗
│   └── categorization_ux (product) ⚠️
│       └── categorization_engine (atom) ✗
└── security_model (strategy)
```

Legend:
- ✓ Safe to carry forward
- ⚠️ Needs review
- ✗ Likely rewrite

---

## Migration Checklist

### Phase 1: Foundation
- [ ] Copy kernel documents (mission, constitution)
- [ ] Copy strategy documents (audience, data_model, pricing_strategy)
- [ ] Update any Python-specific references

### Phase 2: Product Specs
- [ ] Review api_spec — update implementation examples
- [ ] Review categorization_ux — abstract from Python specifics
- [ ] Review data_export — rewrite implementation section

### Phase 3: Atoms (New Project)
- [ ] Create TypeScript equivalent of parser_implementation
- [ ] Create TypeScript equivalent of categorization_engine
- [ ] Create TypeScript equivalent of journal_generator
- [ ] Update product docs to reference new atoms
```

#### 3.3.4 Implementation Notes

**New file:** `ontos/commands/migration_report.py`

Key algorithm:
```python
def classify_for_migration(files_data: Dict[str, dict]) -> Dict[str, str]:
    """
    Classify each document for migration.

    Returns dict of {doc_id: 'safe' | 'review' | 'rewrite'}
    """
    atoms = {d for d, data in files_data.items() if data['type'] == 'atom'}

    # Build transitive dependency closure
    depends_on_atoms = {}
    for doc_id, data in files_data.items():
        atom_deps = find_transitive_atom_deps(doc_id, files_data, atoms)
        depends_on_atoms[doc_id] = atom_deps

    classification = {}
    for doc_id, data in files_data.items():
        if data['type'] == 'atom':
            classification[doc_id] = 'rewrite'
        elif depends_on_atoms[doc_id]:
            classification[doc_id] = 'review'
        else:
            classification[doc_id] = 'safe'

    return classification
```

---

## 4. Alternatives Considered

### 4.1 Single "migration" Command vs. Three Commands

**Rejected:** Single `ontos migrate` command that does everything.

**Rationale:**
- Different use cases need different outputs (JSON for tools, Markdown for humans)
- Composability: `export` is useful beyond migration
- Separation of concerns: data extraction vs. analysis vs. reporting

### 4.2 Interactive Migration Wizard

**Rejected:** Step-by-step wizard that guides through migration decisions.

**Rationale:**
- Adds UI complexity (interactive prompts)
- Harder for AI agents to use
- Non-interactive commands are more scriptable

### 4.3 Migration as a New Document Type

**Rejected:** Add `migration` as a new document type with special fields.

**Rationale:**
- Migrations are events, not persistent documents
- Would require schema changes to all frontmatter validation
- Better to generate reports on-demand

### 4.4 Extend Existing `export` Command

**Considered:** Extend the current CLAUDE.md export to handle data export.

**Decision:** Create new `export` command, rename current to `export-claude` or deprecate.

**Rationale:**
- Current `export` is misleading (only exports CLAUDE.md)
- Clean break is better than overloading semantics
- Can add deprecation warning for transition period

---

## 5. Risks and Mitigations

| Risk | Impact | Mitigation |
|------|--------|------------|
| Content extraction heuristics fail | Missing decisions | Allow manual override via `decision_summary` field |
| Large projects slow to export | UX degradation | Add progress indicator, caching |
| JSON schema changes break tools | Integration failure | Version schema ($schema field), support multiple versions |
| Users expect import capability | Scope creep | Defer to v3.3, document as future work |

---

## 6. Implementation Plan

### Phase 1: `ontos export` (Foundation)

**Files:**
- `ontos/commands/export_data.py` — NEW
- `ontos/core/frontmatter.py` — MODIFY (add parse_full_document)
- `ontos/cli.py` — MODIFY (register command)

**Tests:**
- `tests/commands/test_export_data.py`
- Golden file tests with known output

**Verification:**
```bash
ontos export --type strategy -o test.json
# Verify JSON is valid and contains expected documents
```

### Phase 2: `ontos decisions` (Report Generation)

**Files:**
- `ontos/commands/decisions.py` — NEW
- `ontos/cli.py` — MODIFY

**Tests:**
- `tests/commands/test_decisions.py`
- Test content extraction heuristics

**Verification:**
```bash
ontos decisions -o decisions.md
# Verify markdown is readable and complete
```

### Phase 3: `ontos migration-report` (Analysis)

**Files:**
- `ontos/commands/migration_report.py` — NEW
- `ontos/cli.py` — MODIFY

**Tests:**
- `tests/commands/test_migration_report.py`
- Test classification logic

**Verification:**
```bash
ontos migration-report
# Verify classification matches expectations
```

### Phase 4: Documentation

**Files:**
- `docs/reference/Ontos_Manual.md` — UPDATE
- `docs/reference/Ontos_Agent_Instructions.md` — UPDATE
- `README.md` — UPDATE (add migration section)

---

## 7. Open Questions for Reviewers

1. **Schema versioning:** Should export JSON include `$schema` for validation?
2. **Content extraction:** What's the right balance between heuristics and explicit fields?
3. **Import capability:** Should v3.2 include `ontos import` or defer to v3.3?
4. **Atom classification:** Should we use a more nuanced scale than safe/review/rewrite?
5. **Log decision extraction:** How do we handle logs without "Key Decisions" section?

---

## 8. Success Criteria

1. `ontos export --type strategy,product` produces valid JSON with full content
2. `ontos decisions --migration-safe` generates actionable report
3. `ontos migration-report` correctly classifies documents by atom dependency
4. All commands work on the finance-engine project as case study
5. Documentation enables agents to use migration workflow autonomously

---

## 9. Version History

| Version | Date | Author | Changes |
|---------|------|--------|---------|
| 1.0 | 2026-01-26 | Claude Opus 4.5 | Initial proposal |
