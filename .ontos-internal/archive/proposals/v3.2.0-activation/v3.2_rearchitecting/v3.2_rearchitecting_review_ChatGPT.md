You’re aiming at the right problem, but the current design won’t reliably produce “migration-ready knowledge” unless you tighten a few core assumptions and make the outputs more deterministic and composable. Most of the risk sits in (a) decision extraction heuristics, (b) “safe/review/rewrite” logic built on a single `depends_on` edge type, and (c) the `export` rename story not matching “no breaking changes.” 

## The big assumption that breaks the proposal

### 1) “No new dependencies” vs YAML output

Python stdlib can’t emit real YAML safely. If you ship `--format yaml` without a dependency, you’ll end up with a homegrown serializer that will break on edge cases (multiline, escaping, nested structures). Either:

* drop YAML in v3.2 (JSON only), or
* make YAML an **optional extra** (`pip install ontos[yaml]`) and use a real library, or
* output “YAML-ish” only for a *very constrained schema* and explicitly document the constraints (still risky).

Right now the proposal promises YAML with no deps. That’s not credible. 

### 2) “No breaking changes” vs renaming the existing `export`

Section 4.4 says the current CLAUDE.md exporter should be renamed/deprecated and the new bulk export becomes `ontos export`. That *is* a breaking change for anyone (including your own scripts/agent prompts) that calls `ontos export` today. 

**Cleaner fix:** make `export` a *group*:

* `ontos export claude` (existing behavior)
* `ontos export data` (new behavior)
* keep `ontos export` as an alias to the existing behavior for one release, and print an upgrade message pointing to `export data`.

That preserves muscle memory and avoids “silent behavior swap.”

## What will fail in practice

### 3) Decision extraction via heuristics will be noisy and incomplete

Your `ontos decisions` plan is basically “grep headings and interpret.” It will:

* miss decisions that don’t use your expected headers,
* pull in non-decisions (e.g., “Why this matters” sections),
* produce inconsistent granularity across docs/logs.

The proposed mitigation (“manual override via `decision_summary` field”) quietly contradicts the earlier “no schema changes / no new doc types” rationale. If you’re going to add explicit fields, lean into it properly.

**Better approach:** make “decision capture” a first-class, minimal contract:

* Optional frontmatter fields:

  * `decision_summary: "..."`
  * `rationale: "..."` (short)
  * `alternatives: [...]` (short list)
  * `migration: { carry_forward: true|false, notes: "...", target_stack_notes: {...} }`
* Optional inline decision blocks (easy for humans):

  * a fenced block like:

    ````md
    ```ontos-decision
    summary: ...
    rationale: ...
    alternatives:
      - ...
    ````

    ```
    ```

This makes extraction deterministic and makes your reports real, not guessed.

### 4) Migration classification is too simplistic with a single edge type

“Safe if no atom dependencies (even transitive)” sounds good, but one leaky atom reference can turn *half the graph* into “Needs Review,” which kills usefulness.

You need at least one of:

* **typed edges** (`depends_on` vs `references` vs `implements`), or
* a way to mark edges as “migration-relevant” vs “contextual,” or
* doc-level “migration intent” overrides (explicit beats graph inference).

Right now you treat all `depends_on` edges as equally strong. That’s not how knowledge graphs behave in real docs.

### 5) Filter expression is scope creep with little payoff

`--filter "type:strategy status:active"` introduces:

* a grammar you must specify, parse, test, and support forever,
* user confusion when it doesn’t match expectations.

You already have `--type/--status/--concept`. Ship those first. Add `--filter` only if you have a real downstream need.

### 6) Determinism + “golden file tests” conflict with timestamps/provenance

Your export includes `exported_at`, git commit, etc. Golden tests will churn unless you:

* support a `--deterministic` mode (fixed timestamps, omit git fields), or
* normalize those fields in tests.

You should explicitly design for stable ordering too (sort documents, sort edges, stable JSON).

## A better architecture (still compatible with your 3-command plan)

Keep the three commands if you want, but architect them around a single shared primitive:

### 1) Introduce an internal “snapshot”

A function that returns a canonical, versioned object:

* documents (frontmatter + content optional)
* normalized dependency graph
* warnings (missing deps, invalid types, cycles)

Then:

* `ontos export` = serialize snapshot
* `ontos decisions` = snapshot → decision view (Markdown/JSON)
* `ontos migration-report` = snapshot → migration view (Markdown/JSON)

Add `--input snapshot.json` to `decisions` and `migration-report` so agents can:

* export once,
* run multiple analyses without rescanning the repo,
* share the snapshot with another tool/LLM.

This eliminates duplicated scanning/parsing logic and prevents the commands from drifting.

### 2) Add a thin “protocol runner” command (non-interactive)

You rejected a monolithic `ontos migrate`, fine. Still, most users want a one-liner.

Add:

* `ontos rearch pack --target typescript` that runs:

  * `export data` (JSON snapshot)
  * `decisions --migration-safe`
  * `migration-report`
    and writes a folder:
* `rearch_pack/EXPORT.json`
* `rearch_pack/DECISIONS.md`
* `rearch_pack/MIGRATION.md`
* `rearch_pack/WARNINGS.md`

Internally it just calls the same functions. Externally it becomes the “support protocol” entrypoint.

## Concrete changes I’d make before approving v3.2

### Must-change (ship blockers)

1. Decide YAML stance (drop, optional extra, or constrained format).
2. Fix the `export` transition plan so it’s actually backward compatible (use `export data` / `export claude`).
3. Make outputs deterministic (sorting + test strategy).

### Strongly recommended (otherwise this feature disappoints)

4. Replace heuristic-only decision extraction with explicit optional fields and/or decision blocks.
5. Add either typed dependency edges or explicit migration overrides, so `migration-report` doesn’t devolve into “everything is review.”
6. Define the “agent protocol” explicitly in docs: exact commands, expected artifacts, how the agent should consume them, and what to do on warnings.

## Quick answers to your open questions

1. `$schema`: yes, but make it a **versioned identifier** you can evolve (and include a separate `schema_version: 1` field too).
2. Heuristics vs explicit fields: explicit fields win. Heuristics should be fallback only.
3. Import: don’t ship full import in v3.2, but **do** ship a “pack” folder structure that’s easy to manually copy into the new repo (practical > perfect).
4. Nuanced scale: yes, but only if you can justify it. Start with 3 buckets plus an explicit override.
5. Logs without “Key Decisions”: enforce a log template going forward, and for legacy logs fall back to simple markers (e.g., `Decision:` lines). Don’t pretend you can infer structure from arbitrary prose reliably.

If you implement only one upgrade: make decisions explicit at write-time (frontmatter fields or decision blocks). That single move turns this from “clever reporting” into an actual re-architecture support protocol. 