I pulled the latest PyPI release of Ontos and reviewed the shipped source plus the repo landing pages. Current PyPI release is **3.1.0**, marked **Alpha**, Apache 2.0, released **Jan 22, 2026**. ([PyPI][1])

## What you’ve built, in plain terms

Ontos is a local first documentation system built around a lightweight frontmatter schema, a generated context map, and a CLI that helps keep docs navigable and current for both humans and AI assisted workflows. ([GitHub][2])

## Strengths

**The core idea is strong and pragmatic**

* A context map as the primary artifact is a great anchor for both humans and agents. It creates a single “source of truth” that can be regenerated rather than manually curated.
* The “don’t build a SaaS, keep state in files” posture is the right move for adoption.

**Low dependency footprint**

* Shipping with basically PyYAML as the only runtime dependency is a big win for trust, portability, and long term maintenance. ([PyPI][1])

**Modularity is trending in the right direction**

* You are clearly moving toward “core for logic, io for side effects, commands for orchestration”. A lot of the modules follow that intent well.
* The presence of `core/schema.py` and explicit schema versioning is a really good foundation for long term evolution without breaking repos.

**Init and project bootstrap ergonomics**

* `ontos init` is thoughtfully built, including worktree detection and “do no harm” behaviors. It’s close to the experience level of mature CLIs.

**Good taste in safety defaults**

* Hooks are fail open by default, with a path toward strict mode. That avoids the classic “tool blocks my push so I uninstall it” failure mode.

## Where it’s shaky, and why it matters

### 1. Multiple competing implementations of the same concepts

You have several parallel ways to do the same job, and they do not agree:

* Frontmatter parsing exists in more than one place with different behavior and different YAML capability.
* “describes” validation exists twice with the same function name but different semantics.
* Graph building and orphan logic show up in multiple commands with slightly different rules.

This is the number one maintenance risk. It will keep producing edge case bugs, and it makes it hard for contributors to know which path is canonical.

**What I’d do**

* Pick one canonical pipeline: read file → parse frontmatter → normalize → validate → build graph/index.
* Make every command reuse it.
* Delete or quarantine anything deprecated so it cannot be imported accidentally.

A concrete example: `core/validation.validate_describes_field` assumes a single string, while `core/staleness.normalize_describes` clearly anticipates lists. That will mis fire warnings or miss real issues depending on which path gets used.

### 2. Path resolution is inconsistent across commands

Some commands correctly find the project root by walking upward. Others anchor on `Path.cwd()` and assume you are running from repo root.

* `doctor` uses CWD for `.ontos.toml`, `.git`, docs dir, context map.
* `hook` resolves the context map as `Path.cwd() / config.paths.context_map`.

That will break in real usage because people run commands from subdirectories and git hooks are not guaranteed to execute from repo root.

**What I’d do**

* Introduce a single helper that returns `(project_root, config)` and use it everywhere.
* In hooks, always resolve paths relative to detected project root.

This is a high impact, low effort fix.

### 3. Config system is in an awkward transition state

Some newer code reads `.ontos.toml`. Some still tries to import `ontos_config`.
The biggest offender is `log`: it tries `from ontos_config import LOGS_DIR` and falls back to `docs/logs`. That means a user can set `logs_dir` in `.ontos.toml` and `ontos log` will ignore it.

**What I’d do**

* Treat `.ontos.toml` as the single source of truth.
* Keep `ontos_config` only as an optional backwards compatible import that is merged into the TOML config with a loud deprecation warning.
* Update `log` and any remaining places to stop importing `ontos_config`.

### 4. The log command is not “schema safe”

`log` builds YAML lists like `concepts: [a, b]` without quoting or YAML escaping. That will break for concepts with spaces, colons, brackets, or commas. Also it hand rolls frontmatter instead of reusing your schema serializer.

**What I’d do**

* Reuse one serializer for all frontmatter writing.
* Prefer YAML block lists for user supplied values to avoid escaping bugs.

### 5. Dead code and “ghost pathways”

In `cli.py` there is a wrapper mechanism for legacy scripts, but it appears unused now. That is classic “future footgun” territory because someone will assume it is live and build on it.

**What I’d do**

* If legacy script execution is still a supported mode, expose it explicitly as `ontos legacy <cmd>`.
* If it is not supported, delete the wrapper and the mapping to reduce cognitive load.

### 6. Tests are not currently runnable in the shipped artifact as is

When I try running the test suite from the sdist, collection fails early because some tests import modules that are not importable in that context. That usually means tests are coupled to a repo only layout rather than the installable package layout.

**What I’d do**

* Decide which tests are package tests versus repo integration tests.
* Package tests should run after `pip install -e .[dev]` with no special PYTHONPATH tricks.
* Repo integration tests can live under a separate folder and run in CI for the repo, but should not be part of the sdist test discovery.

### 7. Security posture is mostly fine but one pattern is risky in untrusted repos

Anywhere you inject project root into `PYTHONPATH` or import project local python modules, you are implicitly executing arbitrary code if someone runs Ontos inside an untrusted repository.

That might be acceptable, but it should be explicit in the docs as a trust boundary.

**What I’d do**

* Avoid importing repo local python modules for config.
* Prefer TOML only.
* If you keep python config, load it from a file path using a restricted loader and clearly document the risk.

## A tight improvement plan that will pay off fast

### Do these next, in this order

1. **Unify project root resolution** for all commands and hooks.
2. **Make `.ontos.toml` authoritative**, remove `ontos_config` imports from commands.
3. **Centralize frontmatter parsing and normalization** into one module and delete duplicates.
4. **Centralize doc scanning and indexing** so commands do not rescan and rebuild ad hoc.
5. **Fix log frontmatter writing** using the shared serializer and schema rules.
6. **Split tests into package vs repo integration** and make package tests run cleanly from an installed environment.
7. **Define and enforce one “type system” and one orphan policy** so `map`, `query`, `validate`, and `doctor` agree.

### Medium term, if you want this to feel “inevitable” to adopt

* Add a single JSON output schema for all commands that report structured data.
* Add a “lint” command that is the canonical validator and can run in CI and hooks.
* Consider incremental map generation using a cache keyed by file mtimes or git blobs so large repos stay fast.

## Bottom line

The product direction is good and the code is already a lot more structured than most early stage CLIs. The main thing holding it back is internal inconsistency: multiple ways to parse, validate, and reason about the same fields and paths. If you collapse those into one canonical pipeline and make config and root handling consistent, you will remove most of the sharp edges and the project will feel much more “solid” to new users.

[1]: https://pypi.org/project/ontos/ "ontos · PyPI"
[2]: https://github.com/ohjona/Project-Ontos "GitHub - ohjona/Project-Ontos: Project Ontos. Solving the context fragmentation in the age of AI and vibe coding."
