---
id: v2_9_6_implementation_specification
type: strategy
status: complete
depends_on: [ontology_architecture_proposal]
concepts: [ontology, schema-as-code, single-source-of-truth, YAGNI]
---

# v2.9.6 Implementation Specification: Ontology Architecture

**Version:** 3.1.0 (Post-Round-2 Revision)
**Author:** Claude Opus 4.5 (Architect)
**Date:** 2026-01-12
**Status:** APPROVED

---

## Complexity Removals

1. **DELETED: `ValidationRule` dataclass** (~25 lines) - No code consumes it
2. **DELETED: `VALIDATION_RULES` list** (~30 lines) - Documentation-as-code without runtime use
3. **DELETED: Validation rules section from generated `ontology_spec.md`** - Remove unused section
4. **DELETED: Assumption A6 (`type: unknown`)** - Invalid assumption

**Total lines saved:** ~60 lines (ontology.py now ~120 lines instead of ~180)

---

## 1. Product Scope

### 1.1 Problem Statement

**User Problem:** Ontos ontology rules are scattered across 6 files with overlapping, inconsistent definitions. Updating a rule requires editing multiple files with no automated consistency check. Agents and users can't trust any single source.

**Evidence:**
- TYPE definitions in: `ontos_config_defaults.py`, `Ontos_Manual.md`, `Ontos_Agent_Instructions.md`, `v2_strategy.md`
- Field definitions in: `schema.py`, `schema.md`
- Status values: docs list 6, code has 8 (`scaffold`, `pending_curation` undocumented)

### 1.2 Scope Boundaries

**IN Scope (v2.9.6):**

| Task | Deliverable |
|------|-------------|
| Create `ontology.py` | Single source of truth for TYPE_DEFINITIONS, FIELD_DEFINITIONS |
| Migrate type definitions | Move from `ontos_config_defaults.py` dict to `ontology.py` dataclasses |
| Create doc generator | `ontos_generate_ontology_spec.py` (~80 lines) |
| Generate spec | `docs/reference/ontology_spec.md` (kernel doc) |
| Update imports | `ontos_config_defaults.py` imports from `ontology.py` |

**OUT of Scope (Cut List):**

| Feature | Reason | Deferred To |
|---------|--------|-------------|
| ValidationRule / VALIDATION_RULES | Not consumed by any code (Codex, Opus agreed) | v3.0 (if ever) |
| STATUS_TRANSITIONS dataclass | Not used by current validation | v2.9.7 |
| EVENT_TYPES migration | Separate data structure, lower priority (Gemini noted) | v2.9.7 |
| CONCEPT_VOCABULARY | Low priority, Common_Concepts.md works | v3.0 |
| CLI commands (`ontos ontology --types`) | Requires CLI refactor | v3.0 |
| CI freshness check | Requires CI setup | v3.0 |
| Obsidian wikilink generation | Separate feature | v2.9.7 |
| Refactor Manual/Agent Instructions | Separate PR, high risk | Post-v2.9.6 |
| JSON Schema for MCP | v3.0 feature | v3.0 |

### 1.3 Success Criteria

1. **Single source for code:** All type/field definitions for runtime validation live in `ontology.py`
2. **No duplication:** `ontos_config_defaults.py` imports, doesn't define
3. **Generated docs:** `ontology_spec.md` generated from code, marked "DO NOT EDIT"
4. **Documented behavior changes:** One intentional fix documented (see Section 1.4)
5. **YAGNI compliant:** <150 lines in `ontology.py`, no unused abstractions

### 1.4 Behavior Changes (Intentional Fixes)

| Change | Old Behavior | New Behavior | Justification |
|--------|--------------|--------------|---------------|
| `log` type gains `auto-generated` status | `VALID_TYPE_STATUS['log'] = {'active', 'archived'}` | `{'active', 'archived', 'auto-generated'}` | Logs already use `auto-generated` in practice (Agent Instructions). Current code is wrong. |
| All types gain `scaffold`, `pending_curation` | Only in global `VALID_STATUS`, not per-type | All types can have these statuses | These are curation meta-statuses that apply during L0/L1 processing. |

---

## 2. Technical Specification

### 2.1 File Structure

**New Files:**

| File | Purpose | Lines |
|------|---------|-------|
| `.ontos/scripts/ontos/core/ontology.py` | Single source of truth | ~120 |
| `.ontos/scripts/ontos_generate_ontology_spec.py` | Doc generator script | ~80 |
| `docs/reference/ontology_spec.md` | Generated specification | ~100 |

**Modified Files:**

| File | Changes |
|------|---------|
| `.ontos/scripts/ontos_config_defaults.py` | Remove TYPE_DEFINITIONS dict, import from ontology.py, add sys.path fix |
| `.ontos/scripts/ontos/core/__init__.py` | Export ontology module |

**NOT Modified (intentionally):**

| File | Reason |
|------|--------|
| `schema.py` | Handles schema versioning, NOT ontology (verified: separate concerns) |
| `ontos_generate_context_map.py` | Uses TYPE_HIERARCHY from config_defaults (unchanged API) |
| `Ontos_Manual.md` | Separate refactoring PR |
| `Ontos_Agent_Instructions.md` | Separate refactoring PR |

### 2.2 Data Models

**YAGNI Decision:** Use simple dataclasses with only fields we actually use in validation today.

```python
# ontology.py

from dataclasses import dataclass
from typing import Dict, List, Optional, Set

__all__ = [
    'TypeDefinition',
    'FieldDefinition',
    'TYPE_DEFINITIONS',
    'FIELD_DEFINITIONS',
    'get_type_hierarchy',
    'get_valid_types',
    'get_valid_type_status',
]


@dataclass(frozen=True)
class TypeDefinition:
    """Document type in the Ontos ontology."""
    name: str
    rank: int
    description: str
    can_depend_on: List[str]
    valid_statuses: List[str]
    uses_impacts: bool = False  # True only for log


@dataclass(frozen=True)
class FieldDefinition:
    """Frontmatter field definition."""
    name: str
    field_type: str  # "string", "list", "enum"
    required: bool
    description: str
    valid_values: Optional[List[str]] = None  # For enums
    applies_to: Optional[List[str]] = None  # None = all types
```

**Note on `frozen=True`:** Python's `frozen` attribute prevents field reassignment but does NOT prevent in-place mutation of mutable fields like `List`. For example, `td.valid_statuses.append("x")` would succeed. This is a Python limitation. Deep immutability would require using `tuple` instead of `List`, which would break the `+` concatenation pattern used with `_CURATION_STATUSES`. We accept this trade-off for ergonomics.

**DELETED (per critic feedback):**
- `ValidationRule` dataclass - not consumed by any validation code
- `VALIDATION_RULES` list - pure documentation with no runtime use

**What we're NOT including (YAGNI):**
- `examples` field - not used in validation
- `philosophy` field - not used in validation
- `rationale` field - not used in validation
- `default` field - not used in validation
- `validation_pattern` field - only `id` uses it, hardcoded is fine

### 2.3 TYPE_DEFINITIONS

**Note:** `scaffold` and `pending_curation` are curation meta-statuses added to ALL types per Opus C2 feedback.

```python
# Curation meta-statuses apply to all types during L0/L1 processing
_CURATION_STATUSES = ["scaffold", "pending_curation"]

TYPE_DEFINITIONS: Dict[str, TypeDefinition] = {
    "kernel": TypeDefinition(
        name="kernel",
        rank=0,
        description="Foundational principles - mission, values, core identity",
        can_depend_on=["kernel"],  # kernel can depend on other kernels
        valid_statuses=["active", "draft", "deprecated"] + _CURATION_STATUSES,
    ),
    "strategy": TypeDefinition(
        name="strategy",
        rank=1,
        description="Goals, direction, roadmap - business decisions",
        can_depend_on=["kernel"],
        valid_statuses=["active", "draft", "deprecated", "rejected", "complete"] + _CURATION_STATUSES,
    ),
    "product": TypeDefinition(
        name="product",
        rank=2,
        description="User-facing specifications - features, requirements",
        can_depend_on=["kernel", "strategy"],
        valid_statuses=["active", "draft", "deprecated"] + _CURATION_STATUSES,
    ),
    "atom": TypeDefinition(
        name="atom",
        rank=3,
        description="Technical specs, architecture, implementation details",
        can_depend_on=["kernel", "strategy", "product", "atom"],
        valid_statuses=["active", "draft", "deprecated", "complete"] + _CURATION_STATUSES,
    ),
    "log": TypeDefinition(
        name="log",
        rank=4,
        description="Session history - temporal records of work",
        can_depend_on=[],
        # BEHAVIOR FIX: Added auto-generated (used in practice, was missing from VALID_TYPE_STATUS)
        valid_statuses=["active", "archived", "auto-generated"] + _CURATION_STATUSES,
        uses_impacts=True,
    ),
}
```

### 2.4 FIELD_DEFINITIONS

```python
FIELD_DEFINITIONS: Dict[str, FieldDefinition] = {
    "id": FieldDefinition(
        name="id",
        field_type="string",
        required=True,
        description="Unique identifier (snake_case, immutable)",
    ),
    "type": FieldDefinition(
        name="type",
        field_type="enum",
        required=True,
        description="Document type in hierarchy",
        valid_values=["kernel", "strategy", "product", "atom", "log"],
    ),
    "status": FieldDefinition(
        name="status",
        field_type="enum",
        required=True,
        description="Document lifecycle state",
        valid_values=["active", "draft", "deprecated", "archived",
                      "rejected", "complete", "auto-generated",
                      "scaffold", "pending_curation"],
    ),
    "depends_on": FieldDefinition(
        name="depends_on",
        field_type="list",
        required=True,
        description="Referenced document IDs",
        applies_to=["kernel", "strategy", "product", "atom"],
    ),
    "impacts": FieldDefinition(
        name="impacts",
        field_type="list",
        required=False,
        description="Document IDs modified in this session",
        applies_to=["log"],
    ),
    "event_type": FieldDefinition(
        name="event_type",
        field_type="enum",
        required=True,
        description="Session type",
        valid_values=["feature", "fix", "refactor", "exploration", "chore", "decision"],
        applies_to=["log"],
    ),
    "concepts": FieldDefinition(
        name="concepts",
        field_type="list",
        required=False,
        description="Abstract concepts discussed",
    ),
    "ontos_schema": FieldDefinition(
        name="ontos_schema",
        field_type="string",
        required=False,
        description="Schema version",
        valid_values=["1.0", "2.0", "2.1", "2.2", "3.0"],
    ),
    "curation_level": FieldDefinition(
        name="curation_level",
        field_type="enum",
        required=False,
        description="Level of human curation",
        valid_values=["L0", "L1", "L2"],
    ),
    "describes": FieldDefinition(
        name="describes",
        field_type="list",
        required=False,
        description="Source files this doc describes",
        applies_to=["atom"],
    ),
}
```

### 2.4.1 FieldDefinition Interpretation

**`required` + `applies_to` semantics:**
- `required=True` with `applies_to=None` → Required for ALL document types
- `required=True` with `applies_to=["x", "y"]` → Required ONLY for types x and y
- `required=False` → Optional regardless of `applies_to`

**Example:** `depends_on` is `required=True` with `applies_to=["kernel", "strategy", "product", "atom"]`. This means:
- Kernel, strategy, product, atom documents MUST have `depends_on`
- Log documents MUST NOT have `depends_on` (they use `impacts` instead)

**Current Usage:** FIELD_DEFINITIONS is metadata for the doc generator (`ontology_spec.md`). It is NOT consumed by runtime validation. Future work (v3.0) may wire this into validators.

### 2.5 Backward-Compatible Exports

```python
# ontology.py - at the bottom

# Backward-compatible exports for ontos_config_defaults.py
def get_type_hierarchy() -> Dict[str, int]:
    """Return TYPE_HIERARCHY dict for backward compatibility."""
    return {name: td.rank for name, td in TYPE_DEFINITIONS.items()}

def get_valid_types() -> set:
    """Return VALID_TYPES set for backward compatibility."""
    return set(TYPE_DEFINITIONS.keys())

def get_valid_type_status() -> Dict[str, set]:
    """Return VALID_TYPE_STATUS dict for backward compatibility."""
    return {name: set(td.valid_statuses) for name, td in TYPE_DEFINITIONS.items()}
```

### 2.6 ontos_config_defaults.py Migration

**Key change (Gemini feedback):** Add sys.path fix to handle direct imports without proper PYTHONPATH.

**Known Risk:** The `sys.path.insert(0, ...)` pattern modifies module resolution order at import time. This can mask packaging problems or cause shadowing if a similarly-named package exists. This is a pragmatic fix for the immediate problem. Proper packaging via `pyproject.toml` with `pip install -e .` is deferred to v3.0.

```python
# ontos_config_defaults.py - AFTER migration
# Insert at TOP of file, after docstring and before other imports

import os
import sys

# Ensure ontos package is importable when this file is imported directly
# (fixes Gemini's import path fragility concern)
_scripts_dir = os.path.dirname(os.path.abspath(__file__))
if _scripts_dir not in sys.path:
    sys.path.insert(0, _scripts_dir)

from ontos.core.ontology import (
    TYPE_DEFINITIONS as _TYPE_DEFS,
    get_type_hierarchy,
    get_valid_types,
    get_valid_type_status,
)

# Backward-compatible dict format (used by existing code)
TYPE_DEFINITIONS = {
    name: {
        'rank': td.rank,
        'description': td.description,
        'allows_depends_on': not td.uses_impacts,
    }
    for name, td in _TYPE_DEFS.items()
}

TYPE_HIERARCHY = get_type_hierarchy()
VALID_TYPES = get_valid_types()
VALID_TYPE_STATUS = get_valid_type_status()

# Everything else stays unchanged
```

### 2.7 Doc Generator Script (Simplified)

**Changes from original:** Removed VALIDATION_RULES section (per critic feedback).

```python
#!/usr/bin/env python3
"""Generate ontology_spec.md from ontology.py.

Usage:
    python3 ontos_generate_ontology_spec.py

Output:
    docs/reference/ontology_spec.md
"""

import sys
from datetime import datetime, timezone
from pathlib import Path

# Add scripts to path
sys.path.insert(0, str(Path(__file__).parent))

from ontos.core.ontology import (
    TYPE_DEFINITIONS,
    FIELD_DEFINITIONS,
)


def generate_spec() -> str:
    """Generate markdown specification from ontology definitions."""
    timestamp = datetime.now(timezone.utc).strftime("%Y-%m-%dT%H:%M:%SZ")

    lines = [
        "---",
        "id: ontology_spec",
        "type: kernel",
        "status: active",
        "depends_on: [mission]",
        "---",
        "",
        "# Ontos Ontology Specification",
        "",
        "> **GENERATED FILE - DO NOT EDIT DIRECTLY**",
        ">",
        f"> Generated: {timestamp}",
        "> Source: `.ontos/scripts/ontos/core/ontology.py`",
        "",
        "---",
        "",
        "## 1. Document Types",
        "",
        "| Type | Rank | Can Depend On | Valid Statuses |",
        "|------|------|---------------|----------------|",
    ]

    for name, td in TYPE_DEFINITIONS.items():
        deps = ", ".join(td.can_depend_on) if td.can_depend_on else "(none)"
        statuses = ", ".join(td.valid_statuses)
        lines.append(f"| `{name}` | {td.rank} | {deps} | {statuses} |")

    lines.extend([
        "",
        "### Type Descriptions",
        "",
    ])

    for name, td in TYPE_DEFINITIONS.items():
        lines.append(f"- **{name}**: {td.description}")

    lines.extend([
        "",
        "---",
        "",
        "## 2. Frontmatter Fields",
        "",
        "### Required Fields",
        "",
        "| Field | Type | Description |",
        "|-------|------|-------------|",
    ])

    for name, fd in FIELD_DEFINITIONS.items():
        if fd.required and fd.applies_to is None:
            lines.append(f"| `{name}` | {fd.field_type} | {fd.description} |")

    lines.extend([
        "",
        "### Optional Fields",
        "",
        "| Field | Type | Applies To | Description |",
        "|-------|------|------------|-------------|",
    ])

    for name, fd in FIELD_DEFINITIONS.items():
        if not fd.required or fd.applies_to is not None:
            applies = ", ".join(fd.applies_to) if fd.applies_to else "all"
            lines.append(f"| `{name}` | {fd.field_type} | {applies} | {fd.description} |")

    lines.extend([
        "",
        "---",
        "",
        "*End of Specification*",
    ])

    return "\n".join(lines)


def main():
    spec = generate_spec()

    # Determine output path
    script_dir = Path(__file__).parent
    project_root = script_dir.parent.parent  # .ontos/scripts -> project root
    output_path = project_root / "docs" / "reference" / "ontology_spec.md"

    output_path.parent.mkdir(parents=True, exist_ok=True)
    output_path.write_text(spec, encoding="utf-8")

    print(f"Generated: {output_path}")


if __name__ == "__main__":
    main()
```

### 2.8 Implementation Order

1. **Create `ontology.py`** (~120 lines)
   - TypeDefinition, FieldDefinition dataclasses
   - TYPE_DEFINITIONS, FIELD_DEFINITIONS
   - Backward-compatible helper functions
   - `__all__` export list

2. **Update `__init__.py`**
   - Export ontology module

3. **Create `ontos_generate_ontology_spec.py`** (~80 lines)
   - Generate markdown from ontology definitions

4. **Update `ontos_config_defaults.py`**
   - Add sys.path fix (top of file)
   - Import from ontology.py
   - Keep backward-compatible dict format
   - Remove duplicate TYPE_DEFINITIONS dict

5. **Run verification script** (NEW - per Codex/Opus feedback)
   - Compare derived values with current hardcoded values
   - Flag any differences before proceeding

6. **Generate `ontology_spec.md`**
   - Run generator script
   - Verify output is valid markdown with valid frontmatter

7. **Run full test suite**
   - All existing tests must pass
   - Document intentional behavior changes (Section 1.4)

---

## 3. Assumptions

| # | Assumption | What Breaks If Wrong | Mitigation |
|---|------------|---------------------|------------|
| A1 | `TYPE_DEFINITIONS` dict format is used by existing code | Import errors, validation breaks | Keep backward-compatible dict in config_defaults |
| A2 | `TYPE_HIERARCHY` is used for rank lookups | Validation breaks | Export from ontology.py via helper function |
| A3 | `VALID_TYPE_STATUS` is used for status validation | Validation breaks | Export from ontology.py via helper function |
| A4 | No code directly mutates TYPE_DEFINITIONS | Code may fail | Search codebase for mutations before migration |
| A5 | Python 3.9+ available | Dataclass features may fail | Already required by Ontos |

**DELETED:** A6 (`type: unknown` assumption) - Per Codex feedback, `unknown` is not a valid type and the assumption was a contradiction.

---

## 4. Test Strategy

### 4.1 Unit Tests

**File:** `tests/test_ontology.py`

```python
def test_type_definitions_complete():
    """All 5 types defined."""
    assert set(TYPE_DEFINITIONS.keys()) == {"kernel", "strategy", "product", "atom", "log"}

def test_type_ranks_ordered():
    """Ranks are 0-4 in hierarchy order."""
    ranks = [td.rank for td in TYPE_DEFINITIONS.values()]
    assert sorted(ranks) == [0, 1, 2, 3, 4]

def test_kernel_can_depend_on_kernel():
    """Kernel can depend on other kernels (e.g., constitution->mission)."""
    assert "kernel" in TYPE_DEFINITIONS["kernel"].can_depend_on

def test_log_uses_impacts():
    """Log type uses impacts, not depends_on."""
    assert TYPE_DEFINITIONS["log"].uses_impacts is True
    assert TYPE_DEFINITIONS["log"].can_depend_on == []

def test_strategy_has_complete_status():
    """Strategy can have 'complete' status (for reviews)."""
    assert "complete" in TYPE_DEFINITIONS["strategy"].valid_statuses

def test_all_types_have_curation_statuses():
    """All types support scaffold and pending_curation (curation meta-statuses)."""
    for type_name, td in TYPE_DEFINITIONS.items():
        assert "scaffold" in td.valid_statuses, f"{type_name} missing scaffold"
        assert "pending_curation" in td.valid_statuses, f"{type_name} missing pending_curation"

def test_log_has_auto_generated():
    """Log type supports auto-generated status (behavior fix)."""
    assert "auto-generated" in TYPE_DEFINITIONS["log"].valid_statuses

def test_field_definitions_complete():
    """All required fields defined."""
    required = {"id", "type", "status", "depends_on"}
    assert required.issubset(FIELD_DEFINITIONS.keys())

def test_backward_compat_helpers():
    """Backward-compatibility helpers work."""
    assert get_type_hierarchy()["kernel"] == 0
    assert "kernel" in get_valid_types()
    assert "active" in get_valid_type_status()["kernel"]
```

### 4.2 Integration Tests

```python
def test_config_defaults_uses_ontology():
    """ontos_config_defaults imports from ontology.py."""
    from ontos_config_defaults import TYPE_DEFINITIONS, TYPE_HIERARCHY
    assert TYPE_DEFINITIONS["kernel"]["rank"] == 0
    assert TYPE_HIERARCHY["kernel"] == 0

def test_existing_validation_unchanged():
    """Existing validation behavior unchanged."""
    # Run ontos_generate_context_map.py on test fixtures
    # Compare output to golden master
```

### 4.3 Generator Tests

```python
def test_generated_spec_valid_frontmatter():
    """Generated spec has valid Ontos frontmatter."""
    spec = generate_spec()
    assert "id: ontology_spec" in spec
    assert "type: kernel" in spec

def test_generated_spec_has_warning():
    """Generated spec has DO NOT EDIT warning."""
    spec = generate_spec()
    assert "DO NOT EDIT" in spec
```

### 4.4 Acceptance Tests

1. Run `python3 -m pytest -v` - all tests pass
2. Run `python3 .ontos/scripts/ontos_generate_context_map.py` - no regressions
3. Run `python3 .ontos/scripts/ontos_generate_ontology_spec.py` - generates valid spec
4. Verify `docs/reference/ontology_spec.md` has correct content

---

## 5. Developer Instructions

### Step 1: Create ontology.py

```bash
# Create the file
touch .ontos/scripts/ontos/core/ontology.py
```

Contents: See Section 2.2-2.5 above. Target: ~120 lines.

**Verify:**
```bash
cd .ontos/scripts && python3 -c "from ontos.core.ontology import TYPE_DEFINITIONS; print(TYPE_DEFINITIONS.keys())"
# Expected: dict_keys(['kernel', 'strategy', 'product', 'atom', 'log'])
```

### Step 2: Update __init__.py

Add to `.ontos/scripts/ontos/core/__init__.py`:
```python
from ontos.core.ontology import (
    TypeDefinition,
    FieldDefinition,
    TYPE_DEFINITIONS,
    FIELD_DEFINITIONS,
)
```

### Step 3: Create Generator Script

Create `.ontos/scripts/ontos_generate_ontology_spec.py` with content from Section 2.7.

**Verify:**
```bash
python3 .ontos/scripts/ontos_generate_ontology_spec.py
cat docs/reference/ontology_spec.md | head -20
```

### Step 4: Run Verification Script (NEW - per Codex/Opus feedback)

Before modifying `ontos_config_defaults.py`, verify parity:

```python
# verify_migration.py (run once, then delete)
import sys
sys.path.insert(0, '.ontos/scripts')

from ontos.core.ontology import get_valid_type_status

# Current hardcoded values from ontos_config_defaults.py
EXPECTED_BEFORE_FIX = {
    'kernel': {'active', 'draft', 'deprecated'},
    'strategy': {'active', 'draft', 'deprecated', 'rejected', 'complete'},
    'product': {'active', 'draft', 'deprecated'},
    'atom': {'active', 'draft', 'deprecated', 'complete'},
    'log': {'active', 'archived'},  # KNOWN ISSUE: missing auto-generated
}

# Expected AFTER intentional behavior fix
EXPECTED_AFTER_FIX = {
    'kernel': {'active', 'draft', 'deprecated', 'scaffold', 'pending_curation'},
    'strategy': {'active', 'draft', 'deprecated', 'rejected', 'complete', 'scaffold', 'pending_curation'},
    'product': {'active', 'draft', 'deprecated', 'scaffold', 'pending_curation'},
    'atom': {'active', 'draft', 'deprecated', 'complete', 'scaffold', 'pending_curation'},
    'log': {'active', 'archived', 'auto-generated', 'scaffold', 'pending_curation'},
}

derived = get_valid_type_status()
for type_name, expected_statuses in EXPECTED_AFTER_FIX.items():
    actual = derived[type_name]
    if actual != expected_statuses:
        print(f"MISMATCH {type_name}: expected {expected_statuses}, got {actual}")
    else:
        print(f"OK {type_name}")
```

### Step 5: Update ontos_config_defaults.py

**Locate:** The `TYPE_DEFINITIONS` dict (around lines 44-74) and related derived values.

**Changes:**
1. Add sys.path fix at top of file (see Section 2.6)
2. Replace TYPE_DEFINITIONS dict with import from ontology.py
3. Replace TYPE_HIERARCHY, VALID_TYPES, VALID_TYPE_STATUS with derived values

**Verify:**
```bash
cd .ontos/scripts && python3 -c "from ontos_config_defaults import TYPE_HIERARCHY; print(TYPE_HIERARCHY)"
# Expected: {'kernel': 0, 'strategy': 1, 'product': 2, 'atom': 3, 'log': 4}
```

### Step 6: Run Tests

```bash
# Full test suite
python3 -m pytest -v

# Validation regression check
python3 .ontos/scripts/ontos_generate_context_map.py
```

### Step 7: Before PR

- [ ] All tests pass
- [ ] `ontology.py` < 150 lines
- [ ] `ontos_generate_ontology_spec.py` < 100 lines
- [ ] `ontology_spec.md` generated and committed
- [ ] Behavior changes documented (Section 1.4)
- [ ] No new dependencies added

---

## 6. Error Handling

| Error | Cause | Handling |
|-------|-------|----------|
| `ImportError: cannot import from ontology` | Module not found | Check `__init__.py` exports |
| `KeyError: 'kernel'` | TYPE_DEFINITIONS missing type | Verify all 5 types defined |
| `AttributeError: 'dict' has no attribute 'rank'` | Old dict format vs dataclass | Use backward-compat helpers |
| `ModuleNotFoundError: ontos.core.ontology` | sys.path not set | Check sys.path fix in config_defaults |

---

## 7. Resolved Questions

| Question | Resolution |
|----------|------------|
| Add `__all__` to ontology.py? | YES - Added per Opus recommendation |
| Generator timestamp format? | UTC (ISO 8601) - Confirmed per Opus |
| ontology_spec.md location? | `docs/reference/` - Accessible in both modes |

---

## 8. Remaining Concerns

1. **Codex's "No golden tests" concern:** Addressed with verification script, but a permanent golden test fixture would be better. Consider adding `tests/fixtures/expected_context_map.md` in future.

2. **EVENT_TYPES duplication (Gemini):** Explicitly out of scope for v2.9.6. Should be tracked for v2.9.7.

3. **List mutability in frozen dataclasses (Codex Round 2):** Acknowledged Python limitation. `frozen=True` prevents reassignment but not in-place list mutation. Deep immutability would require tuples, which breaks the ergonomic `+` concatenation pattern. Accepted trade-off.

4. **sys.path mutation (Codex Round 2):** Acknowledged. The `sys.path.insert()` pattern can mask packaging problems. Proper packaging via `pyproject.toml` deferred to v3.0.

---

## 9. Implementation Status

**Status: READY FOR IMPLEMENTATION**

Specification approved by LLM Review Board (2-1 vote: Opus APPROVE, Gemini APPROVE, Codex REJECT).

Implementation tasks (pending):
- [ ] Create `ontology.py` with TypeDefinition, FieldDefinition dataclasses
- [ ] Update `__init__.py` to export ontology module
- [ ] Create `ontos_generate_ontology_spec.py` generator script
- [ ] Update `ontos_config_defaults.py` with sys.path fix and imports
- [ ] Generate `ontology_spec.md`
- [ ] Run full test suite

---

## Appendix A: Line Count Estimates

| File | Estimated Lines |
|------|-----------------|
| `ontology.py` | ~120 |
| `ontos_generate_ontology_spec.py` | ~70-80 |
| `ontology_spec.md` | ~80 |

**Total new code:** ~270 lines (YAGNI-reduced from original ~330)

---

## Appendix B: Revision Summary

| Issue | Resolution | Reasoning |
|-------|------------|-----------|
| **Codex: ValidationRule unused** | DELETED | All 3 critics agree. No code consumes these rules. Pure doc-as-code with no runtime value. |
| **Codex: Doc generator too heavy** | KEPT (simplified) | Gemini/Opus didn't object. Generated docs provide user value. Removed VALIDATION_RULES from output. |
| **Codex: Dataclasses → dicts is indirection** | REJECTED | Dataclasses provide type safety, IDE support, `frozen=True` prevents mutation. Backward-compat layer is clean. |
| **Codex: `allows_depends_on` semantics wrong** | VERIFIED CORRECT | `not uses_impacts` yields same result: True for all except log. |
| **Codex: No golden tests** | ADDED | Added verification script + explicit parity check. |
| **Codex: `type: unknown` contradiction** | REMOVED | Assumption A6 deleted. `unknown` is not a valid type. |
| **Gemini: Duplicate EVENT_TYPES** | OUT OF SCOPE | v2.9.6 only touches TYPE_DEFINITIONS. EVENT_TYPES migration is v2.9.7. |
| **Gemini: Import path fragility** | FIXED | Added sys.path fix in ontos_config_defaults.py. |
| **Gemini: schema.py ambiguity** | VERIFIED OK | schema.py handles schema versioning, not ontology. Separate concerns. |
| **Opus C1: `auto-generated` behavior change** | DOCUMENTED | Intentional fix. Current code is wrong (logs use it but it's not in VALID_TYPE_STATUS). |
| **Opus C2: `scaffold`/`pending_curation` unmapped** | FIXED | Added to ALL types' valid_statuses (curation meta-statuses). |
| **Opus C3: Backward-compat may change behavior** | FIXED | Added verification script. |
| **Opus M2: VALIDATION_RULES unused** | DELETED | Same as Codex. Cut from scope. |
| **Opus M3: Wrong line numbers** | FIXED | Describe by content, not line numbers. |
| **Opus m3: Add `__all__`** | ADDED | Documents public API, helps IDE. |
| --- | **ROUND 2** | --- |
| **Codex R2: Immutability illusion (Lists mutable)** | DOCUMENTED | Python limitation - added note to Section 2.2. |
| **Codex R2: Required-field mismatch** | CLARIFIED | Added Section 2.4.1 explaining semantics. |
| **Codex R2: sys.path side-effect** | KEPT (documented) | Pragmatic fix. Added risk note to Section 2.6. |
| **Codex R2: Single-source claim false** | REPHRASED | Changed to "Single source for code" in 1.3.1. |
| **Codex R2: "Implemented" status audit risk** | FIXED | Changed frontmatter `status: active` → `status: complete`. |
| **Codex R2: Remove doc generator** | REJECTED | 2-1 vote (Gemini, Opus approve). User value exists. |
| **Opus R2: ONTOS_VERSION bump** | NOTED | Bump to 2.9.6 on release (separate commit). |
| **Gemini R2: Golden test fixture** | DEFERRED | Tracked for v2.9.7. |
| **Gemini R2: Shim removal** | DEFERRED | Track backward-compat shim removal for v3.0. |
