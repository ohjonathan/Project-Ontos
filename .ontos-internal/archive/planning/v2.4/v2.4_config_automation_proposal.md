---
id: v2_4_config_automation_proposal
type: strategy
status: draft
depends_on: [v2_strategy, mission]
---

# Ontos v2.4 Proposal: Configuration Automation & UX Overhaul

**Authors:** Jonathan Oh, Claude Code
**Date:** 2025-12-15 (Fourth revision after v4 architectural review)
**Status:** APPROVED - Implementation starting
**Version:** 1.4

---

## Executive Summary

This document proposes a significant UX improvement to Ontos configuration. The goal is to reduce friction for new users while preserving power-user flexibility.

**Key changes from v1.0:**
- **Session Appending Model** (from Gemini) - One log per branch per day, not per push
- **Quality Signals** (from Claude) - `status: auto-generated` for lint warnings
- **Environment Variable Support** (from Codex) - `ONTOS_SOURCE` for CI/shared machines

**Key changes from v1.1 (v2 feedback):**
- **üî¥ CRITICAL: No consolidation in pre-push** - Creates "Dirty Push" paradox (Gemini/Claude consensus)
- **Branch validation in frontmatter** - Prevents wrong-log-appended bugs (Claude)
- **Exact match before glob** - Fixes greedy pattern matching (Claude)
- **Visible warnings on skip** - "Zero friction" ‚â† "zero visibility" (Claude)
- **Commit deduplication** - Prevents duplicate entries on amend+push (Claude)
- **`--enhance` flag** - Agent workflow for enriching auto-generated logs (Claude)
- **Hook timeout** - Prevents slow hooks from frustrating users (Codex)

**Key changes from v1.2 (v3 feedback):**
- **üî¥ CRITICAL: Honest framing of "Automated Mode"** - Git lifecycle means auto-created logs are NOT in the pushed commit (Gemini)
- **Robust append parsing** - Line-by-line parsing instead of fragile regex (Gemini)
- **Comprehensive non-decisions documentation** - Why we deliberately rejected certain features

**Key changes from v1.3 (v4 feedback):**
- **Missing section fallback** - Graceful handling when `## Raw Session History` is absent (Claude v4)
- **`--enhance` specification** - Detailed behavior for agent workflow (Claude v4)
- **Collision scenario clarity** - When `-2` suffix actually triggers (Claude v4)
- **`--reconfig` preserves custom settings** - Don't clobber unknown config options (Codex v4)
- **Context map auto-regeneration** - Prevents stale context maps (bug fix)
- **Note:** Gemini v4 reviewed stale v1.2; their "BLOCKED" status is invalid (issues already fixed)

---

## 1. Problem Statement

### 1.1 Current Pain Points

1. **Configuration is fragmented and technical**
   - Users must understand 10+ individual settings
   - No clear guidance on which settings work well together
   - Default values assume "strict team mode" which frustrates solo devs

2. **Maintenance rituals are forgotten**
   - `Consolidate Ontos` is documented but rarely executed
   - No enforcement or automation for log cleanup
   - Active logs grow unbounded in most projects

3. **Installation doesn't capture user intent**
   - `ontos_init.py` creates config but doesn't ask preferences
   - Users must manually edit `ontos_config.py` to customize
   - No guided setup for different use cases

4. **Archiving ceremony creates friction**
   - Pre-push hook blocks until manual archive
   - Users resort to `--no-verify` to bypass
   - Context is lost when ceremony is skipped

---

## 2. Design Evolution

### 2.1 Original Design (v1.0)

Three modes: `automated`, `prompted`, `advisory`
- Automated mode creates log on every push
- Simple and intuitive

### 2.2 Reviewer Feedback Summary

| Reviewer | Key Insight | Impact |
|----------|-------------|--------|
| **Claude** | Auto-generated logs need quality signal | Add `status: auto-generated` |
| **Codex** | Need env var support for CI | Add `ONTOS_SOURCE` |
| **Gemini** | 5 pushes = 5 logs is noise ("Ghost Logs") | **Session Appending model** |

### 2.3 The "Ghost Log" Problem (Gemini's Insight)

**Original model (flawed):**
```
Push #1 ‚Üí creates 2025-12-14_feature-login.md
Push #2 ‚Üí creates 2025-12-14_feature-login-2.md  ‚Üê noise
Push #3 ‚Üí creates 2025-12-14_feature-login-3.md  ‚Üê more noise
```

A developer pushing WIP commits throughout the day would generate multiple empty logs. This floods the Context Map with low-value nodes‚Äîworse than nothing because it creates false confidence.

**Why this matters:**
> "If a log contains no manual curation and is just auto-generated from the branch name and diff, it is functionally identical to a git commit. You are duplicating git history into Markdown without adding the 'Ontological' value (the *why*)." ‚Äî Gemini

### 2.4 The Solution: Session Appending

**Revised model:**
```
Push #1 ‚Üí creates 2025-12-14_feature-login.md (new log)
Push #2 ‚Üí appends to 2025-12-14_feature-login.md (same log)
Push #3 ‚Üí appends to 2025-12-14_feature-login.md (same log)
```

**Result:** One log per branch per day, accumulating commits. This:
- Prevents ghost log pollution
- Maintains 1:1 relationship with eventual squashed merge
- Still captures all commit history within the log

**Implementation:** `ontos_end_session.py` gains `--append` behavior:
1. Check if log exists for this branch + today's date
2. If yes ‚Üí append new commits to "Raw Session History" section
3. If no ‚Üí create new log

---

## 3. Revised Architecture

### 3.1 Two-Tier Configuration (Unchanged)

The core model remains: **Modes + Individual Overrides**

```python
# Tier 1: Choose a mode (sets sensible defaults)
ONTOS_MODE = "automated"

# Tier 2: Override specific settings if needed
# AUTO_ARCHIVE_ON_PUSH = True  # uncomment to override
```

### 3.2 Mode Presets (Revised)

| Setting | `automated` | `prompted` | `advisory` |
|---------|-------------|------------|------------|
| `AUTO_ARCHIVE_ON_PUSH` | True | False | False |
| `ENFORCE_ARCHIVE_BEFORE_PUSH` | False | True | False |
| `REQUIRE_SOURCE_IN_LOGS` | False | True | False |
| `AUTO_CONSOLIDATE` | True | True | False |

**Note on AUTO_CONSOLIDATE (v1.2):** This setting controls behavior in `Maintain Ontos`, NOT during push. Even in `automated` mode, consolidation never runs silently during `git push`‚Äîonly during explicit maintenance.

**Note on mode naming:** We considered alternatives (`autopilot`/`guided`/`relaxed`) but kept original names because:
- "Automated" clearly means "does things automatically"
- "Prompted" clearly means "prompts you to act"
- "Advisory" clearly means "advises but doesn't enforce"

### 3.3 New: Status Field for Auto-Generated Logs

**Why:** Claude identified that auto-generated logs need a quality signal so users know which logs need human enhancement.

```yaml
---
id: log_20251214_feature_login
type: log
status: auto-generated  # NEW: signals this needs review
event_type: feature
concepts: []
impacts: []
---
```

**Lint behavior:**
```
$ python3 ontos_generate_context_map.py --lint

‚ö†Ô∏è  Data Quality Warnings:
   - 3 auto-generated logs need human review:
     - log_20251214_feature_login
     - log_20251214_fix_auth
     - log_20251215_chore_deps
```

**Why not reject minimal logs entirely?**

Gemini argued "minimal auto-log is worse than no log." We disagree because:
1. A log with branch name, date, and commits IS a breadcrumb‚Äîuseful for reconstruction
2. The ghost log problem was about *quantity*, not *quality*‚Äîsession appending solves this
3. Marking as `auto-generated` lets users enhance later without blocking workflow

### 3.4 ~~New: Consolidation in Pre-Push Hook~~ REMOVED (v1.2)

**Original plan (v1.1):** Pre-push hook triggers consolidation if log count exceeds threshold.

**Why removed:** Both Gemini and Claude independently identified a critical flaw‚Äîthe "Dirty Push" Paradox:

```
1. User runs `git push`
2. Pre-push hook runs consolidation ‚Üí moves files, updates decision_history.md
3. Hook exits 0 (success)
4. Push sends ORIGINAL state to remote (before consolidation)
5. User now has DIRTY working tree with uncommitted consolidation changes
6. User must run `git add . && git commit && git push` AGAIN
```

This defeats the "zero friction" goal. Mutating files during pre-push creates more work, not less.

**Revised approach:** Consolidation is ADVISORY only in pre-push:

```python
# In ontos_pre_push_check.py (all modes)

if count_active_logs() > LOG_RETENTION_COUNT:
    print(f"‚ö†Ô∏è  {count} logs exceed threshold. Run 'Maintain Ontos' to consolidate.")
    # Do NOT run consolidation here - just warn
```

**Where consolidation happens:**
1. **Manual:** Run `python3 .ontos/scripts/ontos_consolidate.py`
2. **In `Maintain Ontos`:** If `AUTO_CONSOLIDATE = True`, maintenance runs consolidation
3. **Never during push** - no silent file mutations during git operations

This aligns with Gemini's recommendation: "Automated mode should automate *capture* (logging), not *janitorial work* (consolidation), because janitorial work requires a commit."

### 3.5 CRITICAL: Git Lifecycle Limitation (v1.3)

**Why this section exists:** Gemini v3 identified a fundamental Git limitation that affects ALL auto-archive implementations, not just consolidation.

**The "Left Behind" Paradox:**
```
1. User commits code (Commit A)
2. User runs `git push`
3. Pre-push hook creates/modifies log.md
4. Hook passes (exit 0)
5. Git pushes Commit A to remote
6. PROBLEM: log.md is NOT in Commit A
7. Remote never sees the log (it's sitting locally, uncommitted)
8. Local working tree is now dirty
```

**This is a Git architectural constraint, not a bug.** Pre-push hooks run AFTER commits are finalized. You cannot add files to a commit that's already being pushed.

**Our honest response:**

Instead of claiming "zero friction automation," we acknowledge the limitation:

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ             üìù SESSION LOG AUTO-GENERATED                  ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                            ‚îÇ
‚îÇ  Created: .ontos-internal/logs/2025-12-15_feature-x.md    ‚îÇ
‚îÇ  Status: auto-generated (needs enrichment)                ‚îÇ
‚îÇ                                                            ‚îÇ
‚îÇ  This log will be included in your NEXT commit.           ‚îÇ
‚îÇ  To include it now: git add . && git commit --amend       ‚îÇ
‚îÇ                                                            ‚îÇ
‚îÇ  Push proceeding with current commits...                   ‚îÇ
‚îÇ                                                            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**What "Automated Mode" actually means (v1.3 clarification):**
- ‚úÖ Auto-CREATES the log file (no manual `Archive Ontos` needed)
- ‚úÖ Auto-APPENDS to existing log (session appending)
- ‚ùå Does NOT include log in the current push (Git limitation)
- ‚úÖ Log is included in the NEXT commit/push

**Why this is acceptable:**
1. Most developers push multiple times per session‚Äîthe log gets included naturally
2. The log still captures context, even if slightly delayed
3. Being honest about limitations builds trust
4. Users who want true automation can use `ontos push` wrapper (future enhancement)

**Why we rejected the `ontos push` wrapper (for now):**
See Section 8: What We're NOT Doing.

### 3.6 Environment Variable Support

**Why:** Codex identified that `DEFAULT_SOURCE` doesn't support CI or shared machines.

**Resolution order:**
1. `ONTOS_SOURCE` environment variable (highest priority)
2. `DEFAULT_SOURCE` in config
3. `git config user.name`
4. Prompt user (if interactive)

```python
def get_source():
    return (
        os.environ.get('ONTOS_SOURCE') or
        getattr(config, 'DEFAULT_SOURCE', None) or
        get_git_user_name() or
        prompt_for_source()
    )
```

**Use case:** CI pipelines can set `ONTOS_SOURCE=CI Bot` without modifying config.

### 3.7 Dirty Git Check (Revised v1.2)

**Why:** Codex identified that auto-archiving with uncommitted changes could create confusing partial logs.

**Behavior:** In automated mode, if `git status` shows uncommitted changes:
```
‚ö†Ô∏è  Uncommitted changes detected. Skipping auto-archive.
    Commit your changes first, or run 'Archive Ontos' manually.
```

**v1.2 clarification: "Zero friction" ‚â† "zero visibility"**

Claude v2 correctly identified that silent skips are confusing‚Äîusers don't know their session wasn't logged. The warning above is printed visibly, even though it doesn't block the push. This maintains zero friction (push proceeds) while ensuring transparency (user knows what happened).

### 3.8 Hook Timeout (v1.2)

**Why:** Codex identified that slow hooks create `--no-verify` pressure.

**Behavior:** Pre-push hook operations have a maximum timeout:
```python
HOOK_TIMEOUT_SECONDS = 10  # Fail gracefully, don't hang

try:
    result = subprocess.run(cmd, timeout=HOOK_TIMEOUT_SECONDS)
except subprocess.TimeoutExpired:
    print("‚ö†Ô∏è  Ontos check timed out. Proceeding with push.")
    print("    Run 'Maintain Ontos' to check status.")
```

**Why timeout instead of block?**

A hanging hook is worse than a skipped check. Users will reach for `--no-verify` if Ontos becomes unpredictable. Better to degrade gracefully and let maintenance catch issues later.

### 3.9 Agent Workflow Enhancement (v1.2, detailed v1.4)

**Why:** Claude v2 identified that agents need a way to enrich auto-generated logs.

**Problem:** In automated mode, pre-push creates `status: auto-generated` logs. When an agent later runs `Archive Ontos`, the existing script says "Log already exists" and exits.

**Solution:** Add `--enhance` flag to `ontos_end_session.py`:

```bash
python3 .ontos/scripts/ontos_end_session.py --enhance
# Opens most recent auto-generated log for enrichment
```

#### `--enhance` Detailed Specification (v1.4)

**What `--enhance` does:**

1. **Find target log:**
   ```python
   def find_enhance_target() -> Optional[str]:
       """Find most recent auto-generated log for current branch."""
       branch = get_current_branch()
       logs = glob.glob(f"{LOGS_DIR}/*_{slugify(branch)}*.md")

       for log in sorted(logs, reverse=True):  # Most recent first
           frontmatter = parse_frontmatter(log)
           if frontmatter.get('status') == 'auto-generated':
               return log

       return None  # No auto-generated log found
   ```

2. **Print file path:** (so agent knows what to edit)
   ```
   üìù Enhancing: .ontos-internal/logs/2025-12-15_feature-login.md
      Status: auto-generated ‚Üí active (after you fill in details)
   ```

3. **Read and display current content:**
   - Print the log content for the agent to see
   - Highlight empty sections that need filling

4. **Agent fills in sections:**
   - Goal (required)
   - Key Decisions (required)
   - Alternatives Considered (required)
   - Concepts (if empty)
   - Impacts (if empty)

5. **Update status field:**
   ```python
   # Agent or script changes:
   status: auto-generated  ‚Üí  status: active
   ```

6. **Exit codes:**
   - `0`: Success, log enhanced
   - `1`: No auto-generated log found for this branch
   - `2`: Log found but already `active` status

**Agent workflow updated:**
```markdown
### "Archive Ontos" (When Log Exists)

If a log exists with `status: auto-generated`:
1. Run `python3 .ontos/scripts/ontos_end_session.py --enhance`
2. Script prints the log path and current content
3. Fill in Goal, Key Decisions, Alternatives Considered
4. Add concepts and verify impacts
5. Change status from `auto-generated` to `active`
6. Commit the enriched log

If no auto-generated log exists:
- Script exits with code 1
- Run normal `Archive Ontos` flow to create new log
```

This preserves the commit history captured by auto-archive while allowing agents to add the "ontological value" (the *why*).

### 3.10 Context Map Auto-Regeneration (v1.4)

**Why:** The context map is a derived artifact that can become stale when source documents change. If someone edits a log file but doesn't regenerate the context map, broken links or outdated information persist until manually fixed.

**Problem discovered:** A log file had `impacts: [ontos_changelog]` referencing a non-existent document. The log was later fixed to `impacts: []`, but the context map wasn't regenerated‚Äîcausing a stale "broken link" error.

**Solution:** Auto-regenerate context map in pre-push hook:

```python
# In ontos_pre_push_check.py

def regenerate_context_map():
    """Ensure context map is always current before push."""
    result = subprocess.run([
        "python3", ".ontos/scripts/ontos_generate_context_map.py"
    ], capture_output=True, text=True, timeout=HOOK_TIMEOUT_SECONDS)

    if result.returncode != 0:
        print("‚ö†Ô∏è  Context map generation failed. Proceeding anyway.")
        return

    # Check if context map changed
    diff_result = subprocess.run(
        ["git", "diff", "--name-only", "Ontos_Context_Map.md"],
        capture_output=True, text=True
    )

    if diff_result.stdout.strip():
        print("üìù Context map updated (will be in next commit)")
        # Note: Cannot add to current push (Git lifecycle limitation)
```

**Behavior:**
- Runs silently in pre-push hook (all modes)
- Respects `HOOK_TIMEOUT_SECONDS` (won't hang)
- If context map changes, prints notification
- Changes included in NEXT commit (same as auto-archive‚ÄîGit lifecycle limitation)

**Why not validate instead of regenerate?**

1. **Simpler:** Regeneration is idempotent; validation requires hash comparison
2. **Self-healing:** Even if user forgets, the next push fixes it
3. **Fast:** Context map generation is typically <1 second

**Note:** This has the same "Left Behind" limitation as auto-archive (Section 3.5). The regenerated map won't be in the current push, but will be ready for the next commit.

---

## 4. Installation Flow (Revised)

### 4.1 Interactive Mode

```
Welcome to Project Ontos Setup
==============================

1. How should Ontos handle session archiving?

   [1] Fully Automatic (recommended for solo devs)
       - Auto-archives session on git push
       - One log per branch per day (appends on subsequent pushes)
       - Zero friction, best practices enforced silently

   [2] Prompted (recommended for teams) [DEFAULT]
       - Push blocked until you archive
       - You choose event type, slug, and details
       - More control, ensures quality

   [3] Advisory (minimal)
       - Push shows reminder only
       - You decide if/when to archive
       - Maximum flexibility, risk of forgetting

2. What name should appear in logs?

   Enter name (or blank to prompt each time): Claude Code

   Tip: Set ONTOS_SOURCE env var to override per-session

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Configuration saved to ontos_config.py
You can change these anytime by editing the file
or running: python3 ontos_init.py --reconfig
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
```

**Key changes:**
- Default is now `prompted` (press Enter without choosing)
- Removed separate consolidation question (follows mode automatically)
- Added tip about `ONTOS_SOURCE` env var

**Why default to prompted?**

> "Ontos is a *discipline* tool. If you default to 'Automated', users will generate weeks of empty logs, realize the Context Map is useless noise, and uninstall. You must force them to see the value of *curation* at least once before allowing them to automate it away." ‚Äî Gemini

We agree partially: the *default* should be prompted, but users who explicitly choose automated know what they want.

### 4.2 Non-Interactive Mode (New)

**Why:** Claude identified that CI environments need non-interactive setup.

```bash
python3 ontos_init.py --non-interactive --mode=automated --source="CI Bot"
```

Uses sensible defaults, no prompts. Essential for automated deployments.

---

## 5. Config File Structure (Revised)

### 5.1 Template-Based Generation

**Why:** Gemini identified that string concatenation is brittle.

**New approach:** Ship `.ontos/templates/ontos_config.py.template`:

```python
"""Ontos Configuration.

Generated by ontos_init.py. Edit this file to customize behavior.
Run `python3 ontos_init.py --reconfig` to reconfigure via prompts.
"""

# =============================================================================
# QUICK SETUP: Choose your mode
# =============================================================================
# "automated" - Zero friction, archives on push, auto-consolidates
# "prompted"  - Blocked until archived, you control details (DEFAULT)
# "advisory"  - Reminders only, maximum flexibility
#
# This sets sensible defaults. Override individual settings below if needed.

ONTOS_MODE = "{{MODE}}"

# Your name for log attribution (can override with ONTOS_SOURCE env var)
# Note: Template generator must properly quote this value
DEFAULT_SOURCE = {{SOURCE_QUOTED}}  # e.g., "Claude Code" or None

# =============================================================================
# ADVANCED: Individual settings (override mode defaults)
# =============================================================================
# Uncomment to customize. These override ONTOS_MODE defaults.

# --- Archiving Behavior ---
# AUTO_ARCHIVE_ON_PUSH = True        # Auto-create log on push
# ENFORCE_ARCHIVE_BEFORE_PUSH = True # Block push until archived
# REQUIRE_SOURCE_IN_LOGS = True      # Require --source flag

# --- Consolidation ---
# AUTO_CONSOLIDATE = True            # Auto-archive old logs in Maintain
# CONSOLIDATION_THRESHOLD_DAYS = 30  # Age threshold for consolidation

# --- Validation ---
# SMALL_CHANGE_THRESHOLD = 20        # Lines below this = "small change"
# LOG_RETENTION_COUNT = 15           # Warn when logs exceed this
```

**Why template over string concatenation?**

1. Easier to maintain‚Äîedit template, not Python code
2. Comments stay synchronized with options
3. Less error-prone‚Äîno escaping issues
4. Reviewable‚Äîtemplate is just a file

### 5.2 Config Debug Command (New)

**Why:** Codex suggested `ontos config show` for debugging.

```bash
$ python3 .ontos/scripts/ontos_config.py --show

Effective Configuration:
========================
ONTOS_MODE = "automated"
  ‚Üí AUTO_ARCHIVE_ON_PUSH = True (from mode)
  ‚Üí ENFORCE_ARCHIVE_BEFORE_PUSH = False (from mode)
  ‚Üí AUTO_CONSOLIDATE = True (from mode)

DEFAULT_SOURCE = "Claude Code" (explicit)
ONTOS_SOURCE env var = not set

Overrides: none
```

Helps users understand what settings are active and where they come from.

### 5.3 Reconfiguration Behavior (v1.4)

**Why:** Codex v4 correctly identified that `--reconfig` should not clobber user customizations.

**Problem:** User has `ontos_config.py` with custom settings (maybe even settings Ontos doesn't recognize). Running `--reconfig` could overwrite these.

**Solution:** Merge, don't replace:

```bash
$ python3 ontos_init.py --reconfig

Reconfiguring Ontos...

Current mode: automated
Custom overrides detected:
  - LOG_RETENTION_COUNT = 25 (non-default)
  - MY_CUSTOM_SETTING = "foo" (unknown to Ontos)

Keep these custom settings? [Y/n] y

[Mode selection prompts...]

Saving configuration...
  ‚úì Mode changed: automated ‚Üí prompted
  ‚úì Preserved: LOG_RETENTION_COUNT = 25
  ‚úì Preserved: MY_CUSTOM_SETTING = "foo" (unknown)

Configuration updated.
```

**Implementation:**

```python
def reconfig():
    """Reconfigure Ontos while preserving custom settings."""
    current_config = parse_existing_config()

    # Identify non-default values
    defaults = get_mode_defaults(current_config.get('ONTOS_MODE', 'prompted'))
    custom_overrides = {}
    unknown_settings = {}

    for key, value in current_config.items():
        if key not in KNOWN_SETTINGS:
            unknown_settings[key] = value
        elif key in defaults and value != defaults[key]:
            custom_overrides[key] = value

    # Show what will be preserved
    if custom_overrides or unknown_settings:
        print("Custom settings detected:")
        for k, v in {**custom_overrides, **unknown_settings}.items():
            print(f"  - {k} = {v}")

        if not confirm("Keep these custom settings?"):
            custom_overrides = {}
            unknown_settings = {}

    # Run interactive mode selection
    new_mode = prompt_for_mode()
    new_source = prompt_for_source()

    # Generate new config preserving customs
    generate_config(
        mode=new_mode,
        source=new_source,
        preserve=custom_overrides,
        unknown=unknown_settings  # Written to bottom of file
    )
```

**Why preserve unknown settings?**

1. **Future-proofing:** User might have settings for an Ontos plugin or fork
2. **Trust:** Clobbering unexplained values feels hostile
3. **Safety:** Better to preserve something weird than lose something important

**Note:** Unknown settings are written at the bottom of the generated config with a comment:
```python
# =============================================================================
# PRESERVED SETTINGS (not recognized by Ontos)
# =============================================================================
# These were in your previous config. Ontos doesn't know what they do,
# but we preserved them in case they're important.

MY_CUSTOM_SETTING = "foo"
```

---

## 6. Failure Modes (New Section)

**Why:** Claude identified this as a critical gap.

### 6.1 Fallback Chain for Auto-Archive

| Scenario | Fallback | Behavior |
|----------|----------|----------|
| Normal branch | Branch name ‚Üí slug | `feat/login` ‚Üí `login` |
| Blocked branch name (`main`, `master`) | Last commit subject | `fix: auth bug` ‚Üí `fix-auth-bug` |
| Detached HEAD | Last commit subject | Same as above |
| No commits since last archive | Skip | Don't create empty log |
| `DEFAULT_SOURCE` not set, no env var | `git config user.name` | Use git identity |
| All fallbacks fail | **Prompt user** | Never silently skip |

**Key principle:** Even in automated mode, a complete failure should surface, not disappear. Silent failures defeat the purpose of Ontos.

### 6.2 Slug Collision Handling

**Why:** Claude identified that same-day, same-branch pushes could collide.

With session appending, this is mostly solved (we append instead of create). But if somehow a collision occurs:

```
2025-12-14_feature-login.md     (first)
2025-12-14_feature-login-2.md   (collision fallback)
```

---

## 7. Implementation Scope (Revised)

### 7.1 Files to Modify

| File | Changes |
|------|---------|
| `ontos_config_defaults.py` | Add `ONTOS_MODE`, `AUTO_ARCHIVE_ON_PUSH`, mode presets, `HOOK_TIMEOUT_SECONDS` |
| `ontos_lib.py` | Add `resolve_config()` function (not new file) |
| `ontos_init.py` | New installation prompts, `--reconfig`, `--non-interactive`, config migration |
| `ontos_end_session.py` | Add `--auto` flag, `--enhance` flag (v1.2), session appending logic, `status: auto-generated`, branch validation (v1.2), commit deduplication (v1.2) |
| `ontos_pre_push_check.py` | Auto-archive logic, consolidation **warning** (not trigger - v1.2), dirty git check with visible warning (v1.2), hook timeout (v1.2), context map auto-regeneration (v1.4) |
| `ontos_generate_context_map.py` | Lint warning for auto-generated logs |

### 7.2 New Files

| File | Purpose |
|------|---------|
| `.ontos/templates/ontos_config.py.template` | Config file template with proper quoting (v1.2) |

### 7.3 Tests to Add

- Mode preset resolution
- Session appending (existing log detection, append behavior)
- **v1.2:** Branch validation in frontmatter
- **v1.2:** Exact match before glob for log detection
- **v1.2:** Commit deduplication on append
- Auto-archive on push (mock git operations)
- Branch prefix ‚Üí event type inference
- Fallback chain for slug/source
- Dirty git detection **with visible warning** (v1.2)
- **v1.2:** Hook timeout handling
- Non-interactive mode
- **v1.2:** `--enhance` flag for agent workflow
- **v1.2:** Config migration in `--reconfig`
- **v1.4:** Context map auto-regeneration in pre-push

---

## 8. What We're NOT Doing (And Why)

This section documents features we **deliberately chose not to implement** and explains our reasoning. This is critical for future reviewers to understand that these are conscious decisions, not oversights.

### 8.1 Rejected Features (Will Not Implement)

#### `ontos push` Wrapper Command
**Proposed by:** Gemini v3
**What it would do:** Replace `git push` with `ontos push` that does: archive ‚Üí stage ‚Üí commit ‚Üí push
**Why rejected:**
1. **Breaking change:** Forces users to learn new command, breaks muscle memory
2. **Forgettable:** Users will accidentally use `git push` and get confused
3. **Scope creep:** Ontos is a context tool, not a Git replacement
4. **Workaround exists:** Users can manually commit the auto-generated log before next push

**What we do instead:** Be honest about the Git limitation (Section 3.5). Auto-create the log, tell users it will be in their next commit.

---

#### Personas ("solo", "team", "compliance")
**Proposed by:** Codex v1, v2, v3 (three times)
**What it would do:** Add persona overlays on top of modes with different retention limits, attribution rules, etc.
**Why rejected:**
1. **Over-engineering:** Three modes already cover the friction spectrum
2. **Combinatorial explosion:** 3 modes √ó 3 personas = 9 configurations to test/document
3. **Unclear benefit:** No user has requested this; it's anticipating problems that may not exist
4. **Violates YAGNI:** "You Aren't Gonna Need It" ‚Äî add complexity when needed, not before

**What we do instead:** Users who need custom configurations can override individual settings.

---

#### Telemetry / Observability
**Proposed by:** Codex v1, v2, v3 (three times)
**What it would do:** Collect usage metrics (bypass rate, consolidation frequency, etc.)
**Why rejected:**
1. **Contradicts core philosophy:** Ontos is "local-first, no API keys, no vendor lock-in"
2. **Privacy concerns:** Even "opt-in" telemetry creates trust issues
3. **Maintenance burden:** Telemetry infrastructure requires ongoing support
4. **Alternative exists:** Users can inspect `.ontos-internal/` manually if they want metrics

**What we do instead:** `Maintain Ontos` can print local statistics without sending data anywhere.

---

#### Checksum Mode Drift Detection
**Proposed by:** Codex v1, v2, v3 (three times)
**What it would do:** Store checksum of mode-derived settings, detect when user edits diverge from preset
**Why rejected:**
1. **Magic behavior:** Users would see warnings they don't understand
2. **Paternalistic:** If a user edits their config, they know what they're doing
3. **Debugging nightmare:** "Why is Ontos complaining about drift?"
4. **Unnecessary:** `--show` command already displays effective config

**What we do instead:** Provide `--show` command for users to inspect their effective configuration.

---

#### `BRANCH_PREFIX_MAP` Configuration
**Proposed by:** Claude v1, v2
**What it would do:** Allow custom mapping of branch prefixes to event types
**Why rejected:**
1. **Workaround exists:** Users can manually specify `--event-type` when needed
2. **Complexity vs. benefit:** Adding config options for rare cases bloats the system
3. **Demand-driven:** If legacy projects with non-standard conventions (`feature-*`, `bugfix-*`, `hotfix/*`) create adoption friction, we can add this in a future version

**What we do instead:** Support standard prefixes (`feat/`, `fix/`, `chore/`). Users with non-standard conventions can specify `--event-type` manually. If demand emerges, we'll reconsider this for v2.5+.

---

#### Mode Renaming (`autopilot`/`guided`/`relaxed`)
**Proposed by:** Claude v1
**What it would do:** Rename modes to more "friendly" names
**Why rejected:**
1. **Current names are clear:** "Automated" means automatic, "Prompted" means prompts, "Advisory" means advice
2. **"Autopilot" is misleading:** Implies hands-off, but user still needs to commit logs (Git limitation)
3. **Bike-shedding:** This is a cosmetic change that doesn't improve functionality

**What we do instead:** Keep `automated`/`prompted`/`advisory` with clear descriptions in the installer.

---

#### Performance Optimization for >10k Files
**Proposed by:** Codex v2, v3
**What it would do:** Add batching, progress bars, resumable operations for large repos
**Why rejected:**
1. **Premature optimization:** No evidence users have 10k+ logs
2. **Misuse indicator:** If you have 10k logs, you've misunderstood Ontos (logs should be consolidated)
3. **Scope creep:** This is enterprise-scale tooling for a developer context tool

**What we do instead:** Encourage consolidation; warn when log count exceeds threshold.

---

#### Single-Toggle `PRE_PUSH_BEHAVIOR` Instead of Modes
**Proposed by:** Claude v2
**What it would do:** Replace modes with orthogonal toggles (when to archive √ó strictness level)
**Why rejected:**
1. **Modes are more intuitive:** Users understand "pick a mode" better than "configure two orthogonal settings"
2. **Combinatorial confusion:** 2 settings √ó 3 options each = 9 combinations, harder to document
3. **Current system works:** We can revisit if users request unsupported combinations

**What we do instead:** Three modes with individual overrides for power users.

---

### 8.2 Deferred Features (May Implement Later)

#### `ontos push` Wrapper (Optional Enhancement)
**Status:** Deferred to v2.5+
**What it would do:** Provide TRUE zero-friction automation for users who want it
**Why deferred:**
1. Not required for v2.4 goals
2. Can be added as an optional tool without changing core behavior
3. Need to see if users actually request this after trying "auto-create + next commit" model

---

#### Mode Orthogonality Refactor
**Proposed by:** Claude v2
**Status:** Deferred to v2.5+ if users request unsupported mode combinations
**What it would do:** Separate "when to archive" from "strictness level"
**Why deferred:**
1. Current modes cover common use cases
2. Would require significant refactoring
3. No evidence of demand for combinations like "auto-archive + block on failure"

---

#### Pluggable Retention Policies
**Proposed by:** Codex v2
**Status:** Deferred indefinitely
**What it would do:** Configure retention by tag, age, or other criteria
**Why deferred:**
1. Current threshold-based retention is sufficient
2. Enterprise feature for enterprise problems we don't have
3. Can be added later if compliance-heavy teams adopt Ontos

---

### 8.3 Why This Section Exists

**For future reviewers (especially Gemini):**

These decisions are **deliberate**. We have considered these features across three rounds of architectural review and chosen not to implement them for specific reasons.

If you're reviewing this document and want to propose one of these features again, please:
1. Acknowledge that we've already considered it
2. Provide NEW evidence or arguments not covered above
3. Explain why the tradeoffs have changed

This prevents circular discussions where the same features are proposed and rejected repeatedly.

---

## 9. Migration Path

### 9.1 Existing Users

- `ontos_config.py` continues to work as-is
- No `ONTOS_MODE` ‚Üí individual settings respected (backward compatible)
- Running `ontos_init.py --reconfig` offers migration to new system

### 9.2 New Users

- Installation prompts for mode selection
- Default is `prompted` if user just presses Enter
- Config file generated from template

### 9.3 Backward Compatibility

All existing settings remain valid. The mode system is purely additive. Users who never touch `ONTOS_MODE` see no change.

---

## 10. Success Metrics

| Metric | Target |
|--------|--------|
| New user setup time | < 2 minutes |
| `--no-verify` usage | Reduced (users don't need to bypass) |
| Consolidation rate | Increased (actually happens in automated mode) |
| Ghost logs | Zero (session appending prevents them) |
| Auto-generated logs enhanced | Lint warns, users act |

---

## 11. Known Limitations

### 11.1 CI/CD Blindspot

**Limitation:** Automated mode is local-only. PR merges via GitHub UI won't create logs.

**Why acceptable:** Ontos is designed for capturing developer context during work. Merge commits are administrative, not context-rich. If needed, a GitHub Action could be added later.

### 11.2 Squash Merge Alignment

**Limitation:** Multiple logs over several days for one branch will exist, even if the PR is squash-merged into one commit.

**Why acceptable:** The logs capture the *journey*, not just the destination. Session appending ensures one log per day per branch, which is reasonable granularity.

---

## 12. Recommendation

**Proceed with implementation.** The v1.3 design addresses all critical concerns from THREE rounds of architectural review:

**From v1.0 ‚Üí v1.1:**
1. ‚úÖ Ghost log problem ‚Üí Session appending
2. ‚úÖ Quality signal ‚Üí `status: auto-generated`
3. ‚úÖ Silent failures ‚Üí Defined fallback chain
4. ‚úÖ CI support ‚Üí `ONTOS_SOURCE` env var + `--non-interactive`

**From v1.1 ‚Üí v1.2:**
5. ‚úÖ "Dirty Push" paradox ‚Üí Consolidation removed from pre-push (warn only)
6. ‚úÖ Wrong-log-appended ‚Üí Branch validation in frontmatter
7. ‚úÖ Greedy glob pattern ‚Üí Exact match first
8. ‚úÖ Silent skips ‚Üí Visible warnings ("zero friction" ‚â† "zero visibility")
9. ‚úÖ Duplicate commits ‚Üí Deduplication on append
10. ‚úÖ Agent workflow gap ‚Üí `--enhance` flag
11. ‚úÖ Slow hook frustration ‚Üí Hook timeout with graceful degradation

**From v1.2 ‚Üí v1.3:**
12. ‚úÖ Git lifecycle limitation ‚Üí Honest framing of "Automated Mode" (Section 3.5)
13. ‚úÖ Fragile append regex ‚Üí Robust line-by-line parsing (Appendix B)
14. ‚úÖ Repeated reviewer proposals ‚Üí Comprehensive non-decisions section (Section 8)

**Reviewer feedback status:**
- Gemini v3: "Left Behind" paradox ‚Üí ADDRESSED with honest framing
- Claude v3: Empty file (no feedback)
- Codex v3: Same as v1/v2 ‚Üí Features deliberately rejected (documented in Section 8)

**Suggested version:** v2.4.0 (minor version bump‚Äînew feature, backward compatible)

---

## Appendix A: Reviewer Feedback Analysis

### What We Adopted (v1.0 ‚Üí v1.1)

| Feedback | Source | Implementation |
|----------|--------|----------------|
| Session appending | Gemini | One log per branch/day, append on subsequent pushes |
| `status: auto-generated` | Claude | New status value, lint warnings |
| Failure mode documentation | Claude | Fallback chain, never silently fail |
| ~~Consolidation in pre-push~~ | ~~Gemini~~ | ~~Trigger when log count > threshold~~ (REVERSED in v1.2) |
| `ONTOS_SOURCE` env var | Codex | Resolution: env ‚Üí config ‚Üí git ‚Üí prompt |
| `--non-interactive` flag | Claude | For CI/CD environments |
| Config template file | Gemini | `.ontos/templates/ontos_config.py.template` |
| Slug collision handling | Claude | Counter suffix as fallback |
| `--show` config debug | Codex | Print resolved values |
| Default mode = prompted | Gemini | Explicit Enter = prompted, not automated |
| Dirty git check | Codex | Skip auto-archive if uncommitted changes |

### What We Adopted (v1.1 ‚Üí v1.2)

| Feedback | Source | Implementation |
|----------|--------|----------------|
| **üî¥ Remove consolidation from pre-push** | Gemini+Claude | "Dirty Push" paradox‚Äîwarn only, never mutate during push |
| Branch name in frontmatter | Claude | Validates append is to correct log, prevents wrong-log-appended |
| Exact match before glob | Claude | Fixes greedy pattern matching `login*` ‚Üí `login-flow` |
| Template quoting fix | Claude | `{{SOURCE_QUOTED}}` generates valid Python |
| Visible skip warnings | Claude | "Zero friction" ‚â† "zero visibility" |
| Commit deduplication | Claude | Skip already-present hashes on append |
| `--enhance` flag | Claude | Agent workflow for enriching auto-generated logs |
| Hook timeout | Codex | Graceful degradation for slow hooks |
| Config migration | Gemini | `--reconfig` handles existing configs |

### What We Rejected

| Feedback | Source | Reason |
|----------|--------|--------|
| Mode renaming | Claude | Original names are intuitive enough |
| Personas | Codex | Over-engineering; 3 modes is sufficient |
| Telemetry | Codex | Contradicts local-first philosophy |
| `BRANCH_PREFIX_MAP` | Claude | Edge case; not worth complexity |
| Checksum drift detection | Codex | Magic behavior; users who edit know what they're doing |
| >10k file optimization | Codex | Premature; misuse of Ontos |
| Single-toggle alternative | Claude | Modes more intuitive than orthogonal settings |
| "Minimal log is worse than no log" | Gemini | Disagree; breadcrumb is useful, session appending solves quantity |

### What We Adopted (v1.2 ‚Üí v1.3)

| Feedback | Source | Implementation |
|----------|--------|----------------|
| Git lifecycle limitation honesty | Gemini v3 | Section 3.5: Acknowledge auto-created logs are NOT in pushed commit |
| Robust append parsing | Gemini v3 | Appendix B: Line-by-line parsing instead of fragile regex |

### What We Adopted (v1.3 ‚Üí v1.4)

| Feedback | Source | Implementation |
|----------|--------|----------------|
| `--enhance` detailed specification | Claude v4 | Section 3.9: find_enhance_target(), exit codes, agent workflow |
| Collision scenario clarity | Claude v4 | Appendix B: Exact scenario when `-2` triggers |
| Missing section fallback | Claude v4 | Appendix B: Graceful handling when `## Raw Session History` absent |
| `--reconfig` preserves custom settings | Codex v4 | Section 5.3: Merge don't replace, preserve unknown settings |
| Soften `BRANCH_PREFIX_MAP` rejection | Claude v4 | Section 8.1: Acknowledge legacy projects, demand-driven reconsideration |
| Context map auto-regeneration | Bug fix | Section 3.10: Auto-regenerate in pre-push to prevent stale maps |

### What We Rejected (v1.3 ‚Üí v1.4)

| Feedback | Source | Reason | Times Proposed |
|----------|--------|--------|----------------|
| Gemini v4 feedback | Gemini v4 | Reviewed stale v1.2; all issues already fixed in v1.3 | N/A |
| Personas | Codex v4 | Over-engineering, YAGNI | 4 |
| Telemetry | Codex v4 | Contradicts local-first philosophy | 4 |
| Checksum drift detection | Codex v4 | Magic behavior, unnecessary | 4 |
| `ontos push` wrapper | Gemini v3 | Breaking change, scope creep, workaround exists | 1 |

**Note:** See Section 8 for comprehensive reasoning on all rejected features.

### What We Deferred

| Feedback | Source | Reason |
|----------|--------|--------|
| Mode orthogonality refactor | Claude v2 | Valid but modes are simpler for v2.4. Revisit if users request unsupported combinations. |
| `ontos push` wrapper (optional) | Gemini v3 | Can add as optional tool in v2.5+ if users request true zero-friction |
| Pluggable retention policies | Codex v2 | Enterprise feature for problems we don't have yet |

---

## Appendix B: Session Appending Implementation Detail (Revised v1.3)

### Detection Logic (Fixed v1.2)

**Problem (v1.1):** The glob pattern `{today}_{branch_slug}*.md` was too greedy‚Äîit matched `login-flow.md` when searching for `login`.

**Solution:** Exact match first, then collision variants:

```python
def find_existing_log_for_today(branch_slug: str, branch_name: str) -> Optional[str]:
    """Find existing log for this branch created today.

    v1.2: Exact match first, then collision variants. Validates branch name.
    """
    today = datetime.now().strftime('%Y-%m-%d')

    # 1. Try exact match first (most common case)
    exact = os.path.join(LOGS_DIR, f"{today}_{branch_slug}.md")
    if os.path.exists(exact):
        if validate_branch_in_log(exact, branch_name):
            return exact
        # Log exists but for different branch - collision!
        print(f"‚ö†Ô∏è  Slug collision: {exact} belongs to different branch")

    # 2. Check collision variants (-2, -3, etc.)
    for i in range(2, 10):
        variant = os.path.join(LOGS_DIR, f"{today}_{branch_slug}-{i}.md")
        if os.path.exists(variant):
            if validate_branch_in_log(variant, branch_name):
                return variant

    return None  # No existing log found


def validate_branch_in_log(log_path: str, expected_branch: str) -> bool:
    """Check if log's frontmatter branch matches expected.

    v1.2: Prevents wrong-log-appended bugs.
    """
    content = read_file(log_path)
    # Extract branch from frontmatter
    match = re.search(r'^branch:\s*(.+)$', content, re.MULTILINE)
    if match:
        return match.group(1).strip() == expected_branch
    # Legacy logs without branch field - assume match
    return True
```

### Frontmatter Enhancement (v1.2)

**Problem:** `feat/login` and `fix/login` both map to slug `login`, causing wrong-log-appended bugs.

**Solution:** Store full branch name in frontmatter:

```yaml
---
id: log_20251214_login
type: log
status: auto-generated
branch: feat/login  # NEW v1.2: validates append is to correct log
event_type: feature
concepts: []
impacts: []
---
```

### Collision Scenario Clarity (v1.4)

**Claude v4 asked:** "When does the `-2` suffix actually trigger?"

**Answer:** The `-2` suffix triggers in ONE specific scenario:

**Scenario: Same slug, different branches, same day**
```
1. 9am:  Push on feat/login ‚Üí creates 2025-12-15_login.md (branch: feat/login)
2. 11am: Push on fix/login  ‚Üí slug is also "login"
3. Validation: 2025-12-15_login.md exists, but branch field says "feat/login"
4. Result: Create 2025-12-15_login-2.md (branch: fix/login)
```

**Scenarios where `-2` does NOT trigger:**

| Scenario | What Happens |
|----------|--------------|
| Same branch, multiple pushes | Appends to existing log |
| Same branch, next day | Creates new dated log |
| Different branch, different slug | Creates separate log |
| Branch renamed mid-day | Creates new log with new slug (old log orphaned) |

**The collision fallback is rare because:**
1. Most branch naming conventions produce unique slugs
2. Branch validation catches most cases
3. It's an edge case for teams with very generic branch names

**Implementation:**
```python
def create_log_for_branch(branch: str, commits: list) -> str:
    """Create new log, handling slug collisions."""
    slug = slugify(branch)
    today = datetime.now().strftime('%Y-%m-%d')

    # Try base filename first
    base_path = f"{LOGS_DIR}/{today}_{slug}.md"
    if not os.path.exists(base_path):
        return create_log_at(base_path, branch, commits)

    # Check if existing log is for same branch (append case)
    if validate_branch_in_log(base_path, branch):
        return base_path  # Caller should append, not create

    # Collision: same slug, different branch. Try -2, -3, etc.
    for i in range(2, 100):
        variant_path = f"{LOGS_DIR}/{today}_{slug}-{i}.md"
        if not os.path.exists(variant_path):
            return create_log_at(variant_path, branch, commits)
        if validate_branch_in_log(variant_path, branch):
            return variant_path  # Found existing log for this branch

    raise RuntimeError(f"Too many slug collisions for {slug}")
```

### Append Behavior (Revised v1.4)

**v1.3 change:** Gemini v3 correctly identified that the original regex-based approach was fragile‚Äîformatters or whitespace changes could break it.

**v1.4 change:** Claude v4 identified missing fallback when `## Raw Session History` section is absent.

**Original (fragile):**
```python
# BAD: Relies on exact whitespace
content.replace("```\n\n---", f"{new_history}\n```\n\n---")
```

**Revised (robust with fallback):**
```python
def append_to_log(log_path: str, new_commits: list) -> bool:
    """Append new commits to existing log's Raw Session History.

    v1.2: Deduplicates commits to handle amend+push scenarios.
    v1.3: Robust line-by-line parsing instead of fragile regex.
    v1.4: Fallback behavior when section is missing.

    Returns:
        True if append succeeded, False if fallback needed.
    """
    lines = read_file(log_path).splitlines()

    # Extract existing commit hashes to prevent duplicates
    existing_hashes = set()
    for line in lines:
        match = re.match(r'^([a-f0-9]{7,40}) -', line)
        if match:
            existing_hashes.add(match.group(1)[:7])

    # Filter out duplicates
    unique_commits = [c for c in new_commits if c.hash[:7] not in existing_hashes]

    if not unique_commits:
        print("‚ÑπÔ∏è  No new commits to append (all already present)")
        return True

    # Find Raw Session History section using line-by-line parsing
    output_lines = []
    in_history_section = False
    in_code_block = False
    inserted = False

    for line in lines:
        output_lines.append(line)

        # Detect start of Raw Session History section
        if line.strip() == "## Raw Session History":
            in_history_section = True
            continue

        # Detect code block boundaries within history section
        if in_history_section and line.strip().startswith("```"):
            if not in_code_block:
                in_code_block = True
            else:
                # End of code block - insert new commits BEFORE closing ```
                if not inserted:
                    output_lines.pop()  # Remove the closing ```
                    for commit in unique_commits:
                        output_lines.append(format_commit(commit))
                    output_lines.append(line)  # Re-add closing ```
                    inserted = True
                in_code_block = False
                in_history_section = False

    # v1.4: Fallback if section was missing
    if not inserted:
        print(f"‚ö†Ô∏è  Could not find '## Raw Session History' section in {log_path}")
        print(f"    Creating new log instead of appending.")
        return False  # Signal caller to create new log

    write_file(log_path, "\n".join(output_lines))
    print(f"üìù Appended {len(unique_commits)} commits to {log_path}")
    return True
```

**Caller handles fallback:**
```python
def auto_archive(branch: str, commits: list):
    existing_log = find_existing_log_for_today(slugify(branch), branch)

    if existing_log:
        success = append_to_log(existing_log, commits)
        if success:
            return  # Done

        # Fallback: section was missing, create new log
        print("    Falling back to new log creation...")

    # Create new log (either no existing log, or append failed)
    create_new_log(branch, commits)
```

**Why this is better:**
1. **Whitespace-agnostic:** Doesn't depend on exact `\n\n` patterns
2. **Formatter-resistant:** Works regardless of how Prettier/linters format the file
3. **Debuggable:** Line-by-line logic is easier to trace than regex
4. **Extensible:** Can add more sections to parse if needed
5. **v1.4: Graceful fallback:** If section is missing, creates new log instead of silent failure

---

*Document history:*
- *v1.0: 2025-12-14 ‚Äî Initial proposal*
- *v1.1: 2025-12-14 ‚Äî Revised after Claude/Codex/Gemini v1 review (Session Appending, status:auto-generated)*
- *v1.2: 2025-12-15 ‚Äî Revised after Claude/Codex/Gemini v2 review (Dirty Push fix, branch validation, exact match, deduplication, --enhance, hook timeout)*
- *v1.3: 2025-12-15 ‚Äî Revised after Claude/Codex/Gemini v3 review (Git lifecycle honesty, robust append parsing, comprehensive non-decisions)*
- *v1.4: 2025-12-15 ‚Äî Revised after v4 review (--enhance spec, collision clarity, missing section fallback, --reconfig preservation, BRANCH_PREFIX_MAP softened, context map auto-regeneration)*

*Document revised 2025-12-15 after FOUR rounds of architectural review by Claude, Codex, and Gemini. APPROVED for implementation.*
