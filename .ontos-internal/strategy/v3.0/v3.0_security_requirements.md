---
id: v3_0_security_requirements
type: strategy
status: draft
depends_on: [technical_architecture]
concepts: [security, architecture, v3, installation, configuration]
---

# v3.0 Security Requirements

**Author:** Claude Code (Opus 4.5) as Chief Architect
**Date:** 2025-12-24
**Version:** 1.0.0
**Status:** DRAFT — Pending LLM Review Board Approval

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Context: The v2.9.4 Security Discussion](#2-context-the-v294-security-discussion)
3. [Requirement 1: AST-Based Config Parsing](#3-requirement-1-ast-based-config-parsing)
4. [Requirement 2: Strict Mode Flag](#4-requirement-2-strict-mode-flag)
5. [Requirement 3: Cross-Platform Install Locking](#5-requirement-3-cross-platform-install-locking)
6. [Implementation Phases](#6-implementation-phases)
7. [Open Questions for LLM Review Board](#7-open-questions-for-llm-review-board)
8. [Security Testing Strategy](#8-security-testing-strategy)
9. [Risk Analysis](#9-risk-analysis)
10. [Revision History](#10-revision-history)

---

## 1. Executive Summary

This document specifies three security improvements for v3.0, originating from the v2.9.4 Architecture Board review. These improvements were intentionally deferred from v2.x due to the **zero-dependency invariant** (v2.x uses Python stdlib only).

| Requirement | v2.x Limitation | v3.0 Solution | Priority |
|-------------|-----------------|---------------|----------|
| **Config Parsing** | Regex-based `split('=', 1)` breaks on multi-line values | Python `ast.literal_eval()` | HIGH |
| **Strict Mode** | `--latest` silently falls back to GitHub API | `--strict` flag fails instead of fallback | MEDIUM |
| **Install Locking** | Concurrent installs may corrupt `.ontos/` | Cross-platform file locking via `filelock` | MEDIUM |

**Why v3.0:** v3.0 permits external dependencies (PyPI distribution), enabling production-grade solutions that were impossible within v2.x's stdlib-only constraint.

**Risk Level:** MEDIUM — These are hardening improvements, not patches for actively exploited vulnerabilities. The v2.x behavior is documented and acceptable for typical use cases.

---

## 2. Context: The v2.9.4 Security Discussion

### 2.1 Origin

During the v2.9.4 PR review (PR #36), Codex (GPT-5) raised three security concerns with the `install.py` implementation:

1. **Config Parsing:** The `read_user_config()` function uses `line.split('=', 1)` which correctly handles single-line values but breaks on multi-line Python literals:

   ```python
   # This works (single-line):
   EXCLUDE_DIRS = ["node_modules", "venv"]

   # This breaks (multi-line):
   EXCLUDE_DIRS = [
       "node_modules",
       "venv",
   ]
   ```

2. **Silent Fallback:** The `--latest` flag attempts `git ls-remote` first, but silently falls back to GitHub API if git is unavailable. A security-conscious user may want strict behavior.

3. **Race Condition:** Two concurrent `install.py` processes could corrupt the `.ontos/` directory. No locking mechanism exists.

### 2.2 Architecture Board Decision (2025-12-24)

The Architecture Board (Claude, Codex, Gemini) reviewed these concerns and decided:

| Concern | Decision | Rationale |
|---------|----------|-----------|
| Config parsing | **Defer to v3.0** | Multi-line configs rare in practice; requires AST parsing (stdlib) or TOML (external) |
| Silent fallback | **By design for v2.x** | Resilience over strictness for adoption; add `--strict` in v3.0 |
| Install locking | **Out of scope for v2.x** | Cross-platform locking requires `filelock` (external dependency) |

**Documented limitation:** v2.x `install.py` config merge works correctly for single-line values only. Multi-line values should be consolidated to single lines.

---

## 3. Requirement 1: AST-Based Config Parsing

### 3.1 Problem Statement

The current `read_user_config()` implementation (v2.9.4) uses string splitting:

```python
def read_user_config() -> dict:
    config_path = Path.cwd() / "ontos_config.py"
    if not config_path.exists():
        return {}

    config = {}
    with open(config_path) as f:
        for line in f:
            line = line.strip()
            if line and not line.startswith('#') and '=' in line:
                parts = line.split('=', 1)
                if len(parts) == 2:
                    key = parts[0].strip()
                    if key.isupper():
                        config[key] = parts[1].strip()
    return config
```

**Failure Mode:** Multi-line values are partially parsed, leading to incorrect or invalid config values.

### 3.2 Proposed Solution: ast.literal_eval()

Use Python's `ast` module for safe parsing of Python literals:

```python
import ast
from pathlib import Path
from typing import Any

def read_user_config() -> dict[str, Any]:
    """Parse ontos_config.py using Python AST.

    Safely extracts top-level assignments where:
    - Target is a simple name (e.g., EXCLUDE_DIRS)
    - Value is a literal (string, list, dict, int, float, bool, None)

    Ignores:
    - Function calls, imports, class definitions
    - Non-literal values (e.g., Path("..."), os.environ.get(...))

    Security: ast.literal_eval() only evaluates Python literals,
    preventing code execution from malicious config files.
    """
    config_path = Path.cwd() / "ontos_config.py"
    if not config_path.exists():
        return {}

    try:
        tree = ast.parse(config_path.read_text())
    except SyntaxError as e:
        # Invalid Python syntax - return empty config
        # Consider: should we warn the user?
        return {}

    config: dict[str, Any] = {}
    for node in ast.iter_child_nodes(tree):
        if isinstance(node, ast.Assign):
            # Only handle simple assignments: NAME = value
            for target in node.targets:
                if isinstance(target, ast.Name) and target.id.isupper():
                    try:
                        # ast.literal_eval is safe - only evaluates literals
                        value = ast.literal_eval(ast.unparse(node.value))
                        config[target.id] = value
                    except (ValueError, TypeError, SyntaxError):
                        # Non-literal value (e.g., function call) - skip
                        pass

    return config
```

### 3.3 Compatibility Matrix

| Config Pattern | v2.x (split) | v3.0 (AST) |
|----------------|--------------|------------|
| `NAME = "value"` | ✅ | ✅ |
| `NAME = ["a", "b"]` (single line) | ✅ | ✅ |
| `NAME = ["a",\n    "b"]` (multi-line) | ❌ | ✅ |
| `NAME = {"key": "val"}` | ⚠️ partial | ✅ |
| `NAME = Path("...")` | ❌ | ❌ (non-literal) |
| `NAME = os.getenv(...)` | ❌ | ❌ (non-literal) |

### 3.4 Security Considerations

- **Safe by design:** `ast.literal_eval()` only evaluates Python literals (strings, numbers, tuples, lists, dicts, booleans, None). It cannot execute arbitrary code.
- **No code injection:** Unlike `eval()` or `exec()`, AST parsing prevents malicious config files from executing code.
- **Graceful degradation:** Invalid syntax or non-literal values are silently skipped (or optionally warned).

### 3.5 Open Design Questions

1. **Warning on parse failure:** Should we emit a warning when a config file has syntax errors or non-literal values? Trade-off: user awareness vs. noise.

2. **Fallback behavior:** If AST parsing fails entirely, should we fall back to the v2.x split-based parser? Trade-off: compatibility vs. consistency.

3. **Config file format:** Should v3.0 support TOML (`ontos.toml`) in addition to or instead of Python config? Trade-off: simplicity vs. standard formats.

---

## 4. Requirement 2: Strict Mode Flag

### 4.1 Problem Statement

The current `install.py --latest` behavior:

```
1. Try: git ls-remote to get latest tag
2. If git unavailable: silently fall back to GitHub API
3. If API fails: exit with error
```

**Concern (Codex):** A security-conscious user may want strict behavior where the absence of git is a hard failure, not a silent fallback.

### 4.2 Current Behavior (v2.x): By Design

The silent fallback was an intentional design choice for v2.x:

```python
def get_latest_version() -> str | None:
    """Get latest version from git or GitHub API.

    v2.x Design: Resilience over strictness.
    Rationale: Users without git should still be able to install.
    The fallback is well-tested and secure (HTTPS to GitHub API).
    """
    # Try git first (faster, no network dependency on GitHub API)
    latest = get_latest_version_from_git()
    if latest:
        return latest

    # Fall back to GitHub API (requires network, but no git)
    return get_latest_version_from_api()
```

### 4.3 Proposed Solution: --strict Flag

Add a `--strict` flag that disables fallback behavior:

```python
def get_latest_version(strict: bool = False) -> str | None:
    """Get latest version from git or GitHub API.

    Args:
        strict: If True, fail if git is unavailable instead of falling back.

    Returns:
        Version string or None if not found.

    Raises:
        SystemExit: If strict=True and git is unavailable.
    """
    latest = get_latest_version_from_git()
    if latest:
        return latest

    if strict:
        sys.exit(
            "Error: --strict specified but git is unavailable.\n"
            "Install git or use --version to specify an explicit version."
        )

    # Fallback to API (non-strict mode)
    return get_latest_version_from_api()
```

**CLI Usage:**

```bash
# Default behavior (v2.x compatible): fallback enabled
python3 install.py --latest

# Strict behavior (v3.0): no fallback
python3 install.py --latest --strict

# Explicit version (always strict by nature)
python3 install.py --version 3.0.0
```

### 4.4 Scope of --strict

The `--strict` flag could potentially affect other behaviors. Define the scope:

| Behavior | Default | --strict |
|----------|---------|----------|
| Git unavailable for `--latest` | Fallback to API | **Exit with error** |
| Checksum mismatch | Exit with error | Exit with error (same) |
| Network timeout | Exit with error | Exit with error (same) |
| Config parse warning | Silent | **Exit with error** (TBD) |

### 4.5 Open Design Questions

1. **Scope creep:** Should `--strict` also affect config parsing (fail on warnings)? Trade-off: predictability vs. flexibility.

2. **Environment variable:** Should there be `ONTOS_STRICT=1` for CI/CD environments? Trade-off: discoverability vs. convenience.

3. **Default in v4.0:** Should `--strict` become the default in a future version? Trade-off: security-first vs. adoption-first.

---

## 5. Requirement 3: Cross-Platform Install Locking

### 5.1 Problem Statement

Two concurrent `install.py` processes could:

1. Both pass the "fresh install" check
2. Both attempt to extract files to `.ontos/`
3. Result in corrupted or mixed-version installation

**Real-world scenario:** User runs `install.py` in one terminal, gets impatient, runs it again in another terminal.

### 5.2 v2.x Limitation

Cross-platform file locking requires external dependencies:

- **Unix:** `fcntl.flock()` (stdlib) works, but is Unix-only
- **Windows:** `msvcrt.locking()` (stdlib) works, but is Windows-only
- **Cross-platform:** Requires `filelock` (PyPI) or similar

Since v2.x prohibits external dependencies, proper locking was deferred.

### 5.3 Proposed Solution: filelock Library

Use the `filelock` library (MIT licensed, widely adopted):

```python
from filelock import FileLock, Timeout
from pathlib import Path

LOCK_FILE = Path.cwd() / ".ontos.lock"
LOCK_TIMEOUT = 30  # seconds

def install_with_lock():
    """Perform installation with exclusive lock.

    Prevents concurrent installations from corrupting the .ontos/ directory.
    Lock file is created at project root and cleaned up on success.
    """
    lock = FileLock(LOCK_FILE, timeout=LOCK_TIMEOUT)

    try:
        with lock:
            # Perform installation
            verify_checksum()
            extract_bundle()
            run_init()
            print("Installation complete!")
    except Timeout:
        sys.exit(
            f"Error: Another installation is in progress.\n"
            f"If this is incorrect, delete {LOCK_FILE} and try again."
        )
    finally:
        # Clean up lock file on success
        if LOCK_FILE.exists():
            LOCK_FILE.unlink()
```

### 5.4 Lock Semantics

| Scenario | Behavior |
|----------|----------|
| First install starts | Acquires lock, proceeds |
| Second install during first | Waits up to 30s, then fails with clear message |
| First install completes | Releases lock, deletes lock file |
| Install crashes mid-way | Lock file remains; stale lock detection needed |
| User deletes lock file manually | Next install proceeds normally |

### 5.5 Stale Lock Detection

**Problem:** If `install.py` crashes or is killed, the lock file remains.

**Solution:** Use PID-based stale lock detection (from v2.8 implementation plan):

```python
import os
import json

def is_lock_stale(lock_file: Path) -> bool:
    """Check if lock file is stale (owning process no longer running).

    Lock file format: {"pid": 12345, "timestamp": "2025-12-24T10:00:00"}
    """
    if not lock_file.exists():
        return True

    try:
        data = json.loads(lock_file.read_text())
        pid = data.get("pid")
        if pid is None:
            return True

        # Check if process is still running
        try:
            os.kill(pid, 0)  # Signal 0 = check existence only
            return False  # Process is running
        except ProcessLookupError:
            return True  # Process no longer exists
        except PermissionError:
            return False  # Process exists but we can't signal it
    except (json.JSONDecodeError, KeyError):
        return True  # Corrupted lock file
```

### 5.6 Open Design Questions

1. **Lock file location:** Should the lock be in `.ontos/.lock` (hidden) or `.ontos.lock` (visible)? Trade-off: visibility vs. clutter.

2. **Timeout duration:** Is 30 seconds appropriate? Slow networks might need longer. Trade-off: responsiveness vs. false positives.

3. **Lock file cleanup:** Should we always delete the lock file, or leave it for debugging? Trade-off: cleanliness vs. diagnostics.

4. **filelock alternatives:** Should we consider `portalocker` or a stdlib-based wrapper? Trade-off: dependency count vs. reliability.

---

## 6. Implementation Phases

### 6.1 Phase 1: v3.0.0 Core Release

**Scope:** Include all three requirements in the initial v3.0 release.

| Requirement | PR | Dependencies |
|-------------|-----|--------------|
| AST Config Parsing | PR #A | None (stdlib) |
| --strict Flag | PR #B | None (stdlib) |
| Install Locking | PR #C | `filelock` |

**Rationale:** These are security improvements that should ship with v3.0, not as incremental patches.

### 6.2 Phase 2: v3.0.x Hardening

Potential follow-up work based on user feedback:

- **v3.0.1:** Add `--strict` environment variable support
- **v3.0.2:** Add config format warning/migration (Python → TOML)
- **v3.0.3:** Lock file timeout configurability

---

## 7. Open Questions for LLM Review Board

The following questions require resolution before implementation:

### Q1: Config File Format Migration

**Question:** Should v3.0 support TOML (`ontos.toml`) as an alternative to Python config (`ontos_config.py`)?

**Options:**
- **(A) Python only:** Keep `ontos_config.py`, use AST parsing. Maintains backward compatibility.
- **(B) TOML only:** Migrate to `ontos.toml`. Cleaner format, better tooling support.
- **(C) Both with precedence:** Support both, prefer TOML if present. Flexibility at the cost of complexity.

**Recommendation:** (A) for v3.0, consider (B) for v4.0.

### Q2: --strict Default Behavior

**Question:** Should `--strict` become the default in a future version?

**Options:**
- **(A) Never default:** Always opt-in. Maintains adoption-first approach.
- **(B) Default in v4.0:** After one major version of warning period.
- **(C) Environment-based:** Default to strict in CI (detected by `CI=true` env var).

**Recommendation:** (C) provides security without breaking interactive use.

### Q3: filelock vs. Alternatives

**Question:** Which locking library should v3.0 use?

**Options:**
- **(A) filelock:** Most popular (20M+ downloads/month), MIT licensed, well-maintained.
- **(B) portalocker:** Feature-rich, but heavier dependency.
- **(C) Custom wrapper:** Use stdlib fcntl/msvcrt with platform detection. Zero dependencies but more code.

**Recommendation:** (A) — `filelock` is the community standard.

### Q4: Lock File Location and Cleanup

**Question:** Where should the lock file live, and should it persist after success?

**Options:**
- **(A) `.ontos.lock` at root, delete on success:** Visible during install, clean after.
- **(B) `.ontos/.lock`, persist:** Hidden, useful for debugging.
- **(C) Temp directory:** Platform temp dir, always cleaned by OS eventually.

**Recommendation:** (A) — visible during install helps users understand what's happening.

### Q5: AST Parse Failure Behavior

**Question:** What should happen if `ontos_config.py` has syntax errors?

**Options:**
- **(A) Silent skip:** Return empty config, proceed with defaults. Least disruptive.
- **(B) Warning only:** Print warning, proceed with defaults. User awareness.
- **(C) Fail in --strict:** Silent normally, fail if `--strict` specified.

**Recommendation:** (C) — aligns with the `--strict` philosophy.

---

## 8. Security Testing Strategy

### 8.1 Unit Tests

```python
# tests/test_security.py

class TestASTConfigParsing:
    def test_single_line_string(self):
        """Parse single-line string value."""

    def test_single_line_list(self):
        """Parse single-line list value."""

    def test_multi_line_list(self):
        """Parse multi-line list value (the key improvement)."""

    def test_syntax_error_graceful(self):
        """Handle syntax errors without crashing."""

    def test_non_literal_skip(self):
        """Skip non-literal values like Path() or os.getenv()."""

    def test_malicious_config_safe(self):
        """Ensure malicious code in config is not executed."""


class TestStrictMode:
    def test_latest_with_git(self):
        """--latest uses git when available."""

    def test_latest_fallback_without_strict(self):
        """--latest falls back to API without --strict."""

    def test_latest_fails_with_strict(self):
        """--latest --strict fails when git unavailable."""

    def test_explicit_version_ignores_strict(self):
        """--version X.Y.Z works regardless of --strict."""


class TestInstallLocking:
    def test_single_install_succeeds(self):
        """Single installation acquires and releases lock."""

    def test_concurrent_install_waits(self):
        """Second install waits for first to complete."""

    def test_concurrent_install_timeout(self):
        """Second install fails after timeout with clear message."""

    def test_stale_lock_detection(self):
        """Stale lock from dead process is detected and overridden."""

    def test_lock_cleanup_on_success(self):
        """Lock file is deleted after successful install."""
```

### 8.2 Integration Tests

- **CI Matrix:** Test on Linux, macOS, Windows
- **Concurrent Install:** Spawn two processes, verify only one succeeds
- **Config Variations:** Test with 10+ real-world config patterns

### 8.3 Security Audit Checklist

- [ ] AST parsing cannot execute arbitrary code
- [ ] `--strict` cannot be bypassed by environment manipulation
- [ ] Lock file cannot be used for denial-of-service (timeout is reasonable)
- [ ] Stale lock detection cannot be fooled by PID reuse
- [ ] All error messages are informative without leaking sensitive paths

---

## 9. Risk Analysis

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| AST parsing breaks on edge case Python syntax | Low | Medium | Comprehensive test suite, fallback option |
| `--strict` causes adoption friction | Medium | Low | Clear documentation, default remains non-strict |
| `filelock` dependency has vulnerability | Low | High | Pin version, monitor CVEs, consider vendoring |
| Lock timeout too short for slow networks | Medium | Low | Make timeout configurable |
| Users confused by lock file | Low | Low | Clear error messages, auto-cleanup |

---

## 10. Revision History

| Version | Date | Author | Changes |
|---------|------|--------|---------|
| 1.0.0 | 2025-12-24 | Claude Code (Opus 4.5) | Initial draft from v2.9.4 Architecture Board decision |

---

*End of document. Pending LLM Review Board approval.*
