---
id: v2_8_implementation_plan
type: strategy
status: active
depends_on: [master_plan_v4, v2_7_1_implementation_plan]
concepts: [architecture, refactor, cli, context-object]
---

# v2.8 Implementation Plan

**Author:** Claude Code (Opus 4.5) as Chief Architect
**Date:** 2025-12-20
**Version:** 2.0.1 (Approved by LLM Review Board)
**Goal:** Prepare architecture for v3.0 (MCP Server) through Context Object Refactor and Unified CLI
**Status:** APPROVED — Ready for Implementation

---

## LLM Review Board Approval

| Reviewer | Round 1 | Round 2 | Final Grade |
|----------|---------|---------|-------------|
| **Claude Opus 4.5** | A- (gaps identified) | A | APPROVED |
| **Codex** | Approved with concerns | Approved with minor clarifications | APPROVED |
| **Gemini** | Approve with recommendations | "Unequivocally approved" | APPROVED |

**Approval Date:** 2025-12-20

### Round 2 Summary

**Claude:** All gaps closed (atomicity, warning output, migration guide, lock implementation). Grade upgraded from A- to A.

**Codex:** Plan aligns well with master plan. Minor non-blocking notes:
- Windows portability note for rename atomicity (POSIX-only)
- Consider tiny git provider interface for MCP testing (deferred to v3.0)
- Add warnings filter in conftest when v2.9 deprecations go live
- Document sys.path ordering to prevent PyPI collision

**Gemini:** "Outstanding piece of architectural work... unequivocally APPROVED FOR IMPLEMENTATION."

---

## Revision History

| Version | Date | Changes |
|---------|------|---------|
| 1.0.0 | 2025-12-20 | Initial draft with 10 open questions |
| 2.0.0 | 2025-12-20 | Incorporated LLM Review Board feedback (Claude, Codex, Gemini) |
| 2.0.1 | 2025-12-20 | LLM Review Board Round 2 approval |

### Key Changes in v2.0.0

1. **Two-phase commit** — Replaced sequential writes with temp-then-rename for true atomicity
2. **Stale lock detection** — Added PID liveness checking to lock implementation
3. **Phased PR strategy** — Replaced single atomic PR with 3 stable, reviewable PRs
4. **Shell testing strategy** — Added explicit CLI dispatcher tests
5. **Migration guide** — Added Section 10 for v2.7.1 → v2.8 upgrade path
6. **Impure function marking** — Explicit documentation of subprocess-calling functions
7. **SessionContext scope limits** — Documented what SessionContext should NOT do
8. **Chief Architect decisions** — Resolved all 10 open questions with rationale

---

## Executive Summary

v2.8 is an **architectural refactoring release** with two major features:

1. **Context Object Refactor** — Split `ontos_lib.py` into pure logic (`ontos/core/`) and I/O (`ontos/ui/`), introduce `SessionContext` dataclass with transaction boundaries.

2. **Unified CLI** — Create `ontos.py` dispatcher to replace direct script invocation, preparing users for v3.0 syntax.

**Why Now:** v3.0 will expose Ontos functionality via MCP Server. The current architecture mixes I/O with logic, making it impossible to expose as an API. v2.8 creates the clean separation required.

**Risk Level:** HIGH — This is the highest-risk V2 release. A flawed execution could destabilize the platform. (Per Gemini review)

**Current State:** v2.7.1 stable (225 tests, 0 validation issues)
**Target State:** v2.8 with clean architecture ready for v3.0

---

## Table of Contents

1. [Current Architecture Analysis](#1-current-architecture-analysis)
2. [Feature 1: Context Object Refactor](#2-feature-1-context-object-refactor)
3. [Feature 2: Unified CLI](#3-feature-2-unified-cli)
4. [Implementation Phases](#4-implementation-phases)
5. [LLM Review Board Decisions](#5-llm-review-board-decisions)
6. [Success Criteria](#6-success-criteria)
7. [Risk Analysis](#7-risk-analysis)
8. [Testing Strategy](#8-testing-strategy)
9. [Appendix: Master Plan References](#9-appendix-master-plan-references)
10. [Migration Guide](#10-migration-guide)
11. [Deferred Items](#11-deferred-items-out-of-scope-for-v28)

---

## 1. Current Architecture Analysis

### 1.1 Script Inventory

| Script | Lines | Has main() | Uses argparse | Purpose |
|--------|-------|------------|---------------|---------|
| `ontos_lib.py` | 1,286 | No | No | Shared library |
| `ontos_end_session.py` | 1,693 | Yes | Yes | Archive sessions |
| `ontos_generate_context_map.py` | 1,223 | Yes | Yes | Generate context map |
| `ontos_consolidate.py` | 396 | Yes | Yes | Archive old logs |
| `ontos_verify.py` | 262 | Yes | Yes | Verify describes dates |
| `ontos_maintain.py` | 250 | Yes | Yes | Maintenance tasks |
| `ontos_query.py` | 234 | Yes | Yes | Query documents |
| Others (10) | ~2,900 | Mixed | Mixed | Various utilities |

**Total:** ~7,900 lines across 17 scripts

### 1.2 Current I/O Violations in ontos_lib.py

The library currently contains **7 print() statements** that violate the "Functional Core, Imperative Shell" principle:

| Line | Statement | Context |
|------|-----------|---------|
| 94 | `print("WARN: git not found...")` | Git fallback |
| 100 | `print("WARN: git command timed out...")` | Git timeout |
| 558 | `print(f"WARN: {w}")` | Validation warning |
| 641 | `print(f"Error parsing YAML...")` | YAML error |
| 987-989 | `print()` x3 | Deprecation warning |

**Problem:** These print statements prevent the library from being used in non-CLI contexts (API, MCP Server, tests).

### 1.3 Current State Access Patterns

Scripts currently access state through multiple patterns:

```python
# Pattern 1: Direct function calls with implicit config
from ontos_lib import get_logs_dir, resolve_config
logs_dir = get_logs_dir()  # Uses config internally

# Pattern 2: Config module import
from ontos_config import DOCS_DIR, AUTO_ARCHIVE_ON_PUSH

# Pattern 3: Environment variable fallback
source = os.environ.get('ONTOS_SOURCE', config.DEFAULT_SOURCE)
```

**Problem:** State is scattered across module-level variables, environment variables, and config imports. This makes testing difficult and prevents dependency injection.

---

## 2. Feature 1: Context Object Refactor

### 2.1 Design: SessionContext Dataclass

Per the Master Plan (Section 3.1), we implement a transactional session pattern:

```python
from dataclasses import dataclass, field
from pathlib import Path
from typing import Dict, List, Optional
from enum import Enum
import os
import time

class FileOperation(Enum):
    WRITE = "write"
    DELETE = "delete"
    MOVE = "move"

@dataclass
class PendingWrite:
    """A buffered file operation."""
    operation: FileOperation
    path: Path
    content: Optional[str] = None  # For WRITE
    destination: Optional[Path] = None  # For MOVE

@dataclass
class SessionContext:
    """Captures all state for an Ontos session.

    This is the single source of truth for:
    - Repository configuration
    - Environment state
    - Pending file operations (transaction buffer)

    SCOPE LIMITS (v2.0.0):
    SessionContext should NOT:
    - Handle output formatting (that's OutputHandler's job)
    - Contain I/O providers (keep git calls as marked impure functions)
    - Cache parsed documents (keep it focused on transaction state)
    - Grow beyond config + env + writes + diagnostics
    """
    # Immutable state (set at creation)
    repo_root: Path
    config: Dict
    cwd: Path = field(default_factory=Path.cwd)
    env: Dict[str, str] = field(default_factory=lambda: dict(os.environ))

    # Mutable state (changes during session)
    pending_writes: List[PendingWrite] = field(default_factory=list)
    warnings: List[str] = field(default_factory=list)
    errors: List[str] = field(default_factory=list)

    @classmethod
    def from_repo(cls, repo_root: Path) -> 'SessionContext':
        """Factory method to create context from repository path.

        This encapsulates config loading logic.
        """
        from ontos_config import resolve_config
        config = resolve_config(repo_root)
        return cls(repo_root=repo_root, config=config)

    def buffer_write(self, path: Path, content: str) -> None:
        """Buffer a file write for later commit."""
        self.pending_writes.append(PendingWrite(
            operation=FileOperation.WRITE,
            path=path,
            content=content
        ))

    def buffer_delete(self, path: Path) -> None:
        """Buffer a file deletion for later commit."""
        self.pending_writes.append(PendingWrite(
            operation=FileOperation.DELETE,
            path=path
        ))

    def buffer_move(self, source: Path, destination: Path) -> None:
        """Buffer a file move for later commit."""
        self.pending_writes.append(PendingWrite(
            operation=FileOperation.MOVE,
            path=source,
            destination=destination
        ))

    def commit(self) -> List[Path]:
        """Execute all buffered operations with two-phase commit.

        ATOMICITY: Uses temp-then-rename pattern. If any operation fails,
        previous temp files are cleaned up. Rename is atomic on POSIX.

        Returns:
            List of paths successfully modified.

        Raises:
            IOError: If a write operation fails.
            RuntimeError: If lock cannot be acquired.
        """
        if not self.pending_writes:
            return []

        lock_path = self.repo_root / '.ontos' / 'write.lock'
        if not self._acquire_lock(lock_path):
            raise RuntimeError(
                "Could not acquire write lock. "
                "Another Ontos process may be running."
            )

        staged: List[tuple[Path, Path]] = []  # (temp, final)
        modified: List[Path] = []

        try:
            # Phase 1: Write to temp files
            for op in self.pending_writes:
                if op.operation == FileOperation.WRITE:
                    op.path.parent.mkdir(parents=True, exist_ok=True)
                    temp = op.path.with_suffix(op.path.suffix + '.tmp')
                    temp.write_text(op.content)
                    staged.append((temp, op.path))
                elif op.operation == FileOperation.DELETE:
                    if op.path.exists():
                        # For delete, we stage by tracking what to delete
                        staged.append((None, op.path))
                elif op.operation == FileOperation.MOVE:
                    if op.path.exists():
                        staged.append((op.path, op.destination))

            # Phase 2: Atomic rename/apply
            for temp, final in staged:
                if temp is None:
                    # Delete operation
                    final.unlink()
                    modified.append(final)
                elif temp != final:
                    # Write or Move: rename temp to final (atomic on POSIX)
                    temp.rename(final)
                    modified.append(final)

        except Exception as e:
            # Cleanup temp files on failure
            for temp, final in staged:
                if temp is not None and temp != final and temp.exists():
                    temp.unlink(missing_ok=True)
            self.error(f"Commit failed: {e}")
            raise

        finally:
            self._release_lock(lock_path)
            self.pending_writes.clear()

        return modified

    def rollback(self) -> None:
        """Discard all buffered operations."""
        self.pending_writes.clear()

    def warn(self, message: str) -> None:
        """Record a warning (does not print)."""
        self.warnings.append(message)

    def error(self, message: str) -> None:
        """Record an error (does not print)."""
        self.errors.append(message)

    def _acquire_lock(self, lock_path: Path, timeout: float = 5.0) -> bool:
        """Acquire a simple file lock with stale detection.

        Uses atomic file creation (O_CREAT | O_EXCL). If a stale lock
        is detected (holding process is dead), it is automatically removed.

        Args:
            lock_path: Path to lock file
            timeout: Maximum seconds to wait

        Returns:
            True if lock acquired, False if timeout
        """
        lock_path.parent.mkdir(parents=True, exist_ok=True)
        start = time.time()

        while time.time() - start < timeout:
            try:
                fd = os.open(str(lock_path), os.O_CREAT | os.O_EXCL | os.O_WRONLY)
                os.write(fd, str(os.getpid()).encode())
                os.close(fd)
                return True
            except FileExistsError:
                # Check if holding process is still alive
                try:
                    pid = int(lock_path.read_text().strip())
                    os.kill(pid, 0)  # Raises if process doesn't exist
                except (ProcessLookupError, ValueError, OSError):
                    # Stale lock - process is dead, remove it
                    try:
                        lock_path.unlink()
                    except FileNotFoundError:
                        pass
                    continue
                time.sleep(0.1)

        return False

    def _release_lock(self, lock_path: Path) -> None:
        """Release the file lock."""
        try:
            lock_path.unlink()
        except FileNotFoundError:
            pass  # Already released
```

### 2.2 Output Handling (Separate from SessionContext)

Per Chief Architect review: **Output formatting does NOT belong in SessionContext.**

```python
# ontos/ui/output.py
class OutputHandler:
    """Handles all output formatting and display.

    This is the ONLY place that knows about emoji and formatting.
    """
    def __init__(self, quiet: bool = False):
        self.quiet = quiet

    def display_warnings(self, warnings: List[str]) -> None:
        """Display collected warnings after commit."""
        if self.quiet:
            return
        for w in warnings:
            print(f"Warning: {w}")

    def display_errors(self, errors: List[str]) -> None:
        """Display collected errors."""
        for e in errors:
            print(f"Error: {e}")

    def success(self, message: str) -> None:
        """Display a success message."""
        if not self.quiet:
            print(message)
```

### 2.3 Script Usage Pattern

```python
# How scripts should use SessionContext
def main():
    output = OutputHandler(quiet=args.quiet)
    ctx = SessionContext.from_repo(Path.cwd())

    try:
        # Do work, buffer writes via ctx.buffer_write()
        result = some_operation(ctx)
        modified = ctx.commit()
        output.success(f"Modified {len(modified)} files")
    except Exception as e:
        ctx.rollback()
        output.display_errors([str(e)])
        return 1
    finally:
        output.display_warnings(ctx.warnings)

    return 0
```

### 2.4 Library Split Strategy

**Current structure:**
```
.ontos/scripts/
├── ontos_lib.py          # Mixed pure + impure
├── ontos_config.py       # Config wrapper
├── ontos_config_defaults.py
└── ontos_*.py            # Scripts (impure)
```

**Proposed structure:**
```
.ontos/scripts/
├── ontos/                 # New package
│   ├── __init__.py
│   ├── core/              # Pure logic (no I/O except marked impure)
│   │   ├── __init__.py
│   │   ├── context.py     # SessionContext
│   │   ├── frontmatter.py # Parsing, validation
│   │   ├── graph.py       # Dependency analysis
│   │   ├── history.py     # Decision history generation
│   │   └── staleness.py   # Describes/staleness logic
│   └── ui/                # I/O layer
│       ├── __init__.py
│       ├── cli.py         # Unified CLI dispatcher
│       ├── output.py      # OutputHandler
│       └── prompts.py     # Interactive input
├── ontos_lib.py           # DEPRECATED: Shim for backwards compat
├── ontos_config.py        # Unchanged
└── ontos_*.py             # Scripts (refactored to use core/)
```

### 2.5 Function Classification with Impurity Marking

| Function | Target Location | Pure? | Notes |
|----------|-----------------|-------|-------|
| `parse_frontmatter()` | core/frontmatter | Yes | |
| `normalize_describes()` | core/staleness | Yes | |
| `validate_describes_field()` | core/staleness | Yes | |
| `generate_decision_history()` | core/history | Yes | |
| `check_staleness()` | core/staleness | **IMPURE** | Calls `get_file_modification_date` |
| `get_file_modification_date()` | core/staleness | **IMPURE** | Calls `subprocess.run` |
| `get_logs_dir()` | core/context | Yes | With injected config |
| `resolve_config()` | core/context | Yes | With injected config |
| `_warn_deprecated()` | ui/output | No | Prints |

**Impure Function Documentation Pattern:**

```python
def get_file_modification_date(path: Path, repo_root: Path) -> Optional[str]:
    """Get last modification date from git.

    IMPURE: This function calls subprocess.run() to execute git commands.
    For testing, mock this function directly:

        with patch('ontos.core.staleness.get_file_modification_date') as mock:
            mock.return_value = '2025-12-20'
            result = check_staleness(doc, ctx)

    Args:
        path: File path to check
        repo_root: Repository root for git context

    Returns:
        ISO date string or None if git unavailable
    """
    try:
        result = subprocess.run(
            ['git', 'log', '-1', '--format=%cs', str(path)],
            cwd=repo_root,
            capture_output=True,
            text=True,
            timeout=5
        )
        if result.returncode == 0:
            return result.stdout.strip()
    except (subprocess.TimeoutExpired, FileNotFoundError):
        pass
    return None
```

### 2.6 Backwards Compatibility Shim

```python
# ontos_lib.py (DEPRECATED - backwards compatibility shim)
"""
DEPRECATED: Import from ontos.core instead.
This module will be removed in v3.0.

v2.8: Silent operation (no warnings)
v2.9: DeprecationWarning on import
v3.0: Module removed
"""
# Direct re-exports (no __getattr__ overhead)
from ontos.core.frontmatter import parse_frontmatter, normalize_depends_on
from ontos.core.staleness import (
    ModifiedSource, normalize_describes, parse_describes_verified,
    validate_describes_field, detect_describes_cycles, check_staleness,
    get_file_modification_date, clear_git_cache
)
from ontos.core.history import (
    ParsedLog, parse_log_for_history, sort_logs_deterministically,
    generate_decision_history
)
from ontos.core.context import SessionContext
# ... all other re-exports
```

---

## 3. Feature 2: Unified CLI

### 3.1 Design: ontos.py Dispatcher

**Current invocation:**
```bash
python3 .ontos/scripts/ontos_end_session.py -e feature
python3 .ontos/scripts/ontos_generate_context_map.py --strict
python3 .ontos/scripts/ontos_verify.py --all
```

**Proposed invocation:**
```bash
python3 ontos.py log -e feature          # Archive session
python3 ontos.py map --strict            # Generate context map
python3 ontos.py verify --all            # Verify describes
python3 ontos.py init                    # Initialize project
python3 ontos.py maintain                # Run maintenance
```

### 3.2 Command Mapping

| New Command | Old Script | Aliases |
|-------------|------------|---------|
| `ontos.py log` | `ontos_end_session.py` | `archive`, `session` |
| `ontos.py map` | `ontos_generate_context_map.py` | `context`, `generate` |
| `ontos.py verify` | `ontos_verify.py` | `check` |
| `ontos.py init` | `ontos_init.py` | `setup` |
| `ontos.py maintain` | `ontos_maintain.py` | `maintenance` |
| `ontos.py consolidate` | `ontos_consolidate.py` | `archive-old` |
| `ontos.py query` | `ontos_query.py` | `search`, `find` |
| `ontos.py update` | `ontos_update.py` | `upgrade` |

### 3.3 CLI Implementation

```python
#!/usr/bin/env python3
"""Ontos CLI - Unified command interface.

Usage:
    python3 ontos.py <command> [options]
    python3 ontos.py --help
    python3 ontos.py --version

Commands:
    log         Archive a session (creates log file)
    map         Generate context map
    verify      Verify describes dates
    init        Initialize Ontos in a project
    maintain    Run maintenance tasks
    consolidate Archive old logs
    query       Search documents
    update      Update Ontos scripts

Examples:
    python3 ontos.py log -e feature         # Log a feature session
    python3 ontos.py map --strict           # Generate with strict validation
    python3 ontos.py verify --all           # Verify all stale docs
"""

import sys
from pathlib import Path

# Add scripts directory to path for imports
SCRIPTS_DIR = Path(__file__).parent / '.ontos' / 'scripts'
sys.path.insert(0, str(SCRIPTS_DIR))

COMMANDS = {
    'log': ('ontos_end_session', 'Archive a session'),
    'map': ('ontos_generate_context_map', 'Generate context map'),
    'verify': ('ontos_verify', 'Verify describes dates'),
    'init': ('ontos_init', 'Initialize Ontos'),
    'maintain': ('ontos_maintain', 'Run maintenance'),
    'consolidate': ('ontos_consolidate', 'Archive old logs'),
    'query': ('ontos_query', 'Search documents'),
    'update': ('ontos_update', 'Update Ontos'),
}

ALIASES = {
    'archive': 'log', 'session': 'log',
    'context': 'map', 'generate': 'map',
    'check': 'verify',
    'setup': 'init',
    'maintenance': 'maintain',
    'archive-old': 'consolidate',
    'search': 'query', 'find': 'query',
    'upgrade': 'update',
}

def main():
    if len(sys.argv) < 2 or sys.argv[1] in ('-h', '--help'):
        print(__doc__)
        return 0

    if sys.argv[1] in ('-V', '--version'):
        from ontos_config_defaults import ONTOS_VERSION
        print(f"Ontos {ONTOS_VERSION}")
        return 0

    command = sys.argv[1]
    command = ALIASES.get(command, command)

    if command not in COMMANDS:
        print(f"Unknown command: {command}")
        print(f"Available: {', '.join(sorted(COMMANDS.keys()))}")
        return 1

    module_name, _ = COMMANDS[command]

    # Import and run the module
    import importlib
    module = importlib.import_module(module_name)

    # Replace sys.argv for the subcommand
    sys.argv = [module_name + '.py'] + sys.argv[2:]

    return module.main()

if __name__ == '__main__':
    sys.exit(main() or 0)
```

### 3.4 Deprecation Strategy

**Phase 1 (v2.8):** Introduce `ontos.py`, no deprecation warnings. Silent transition.

**Phase 2 (v2.9):** Add deprecation warnings to direct script usage and old imports.

**Phase 3 (v3.0):** Scripts become internal-only, `pip install ontos` replaces local scripts.

### 3.5 Location of ontos.py

**Decision: Project root (`./ontos.py`)**

Rationale: Easy discovery, matches v3.0 pattern, superior UX over cleanliness concerns.

---

## 4. Implementation Phases

### CRITICAL: Phased PR Strategy

Per Chief Architect review and Gemini's "In-Between State Risk" insight, implementation MUST use multiple stable PRs, not a single atomic PR.

**Why:** A 7,900+ line single PR is:
- Impossible to review effectively
- Creates massive merge conflict risk
- Violates incremental change principles

**The backwards-compat shim enables safe phasing** — each PR leaves the codebase in a working state.

---

### PR #1: Library Structure (Days 1-2)

**Goal:** Create new package structure with backwards-compat shim.

| Task | Description | Risk |
|------|-------------|------|
| 1.1 | Create `ontos/` package structure | Low |
| 1.2 | Create `ontos/core/context.py` with SessionContext | Medium |
| 1.3 | Move pure functions to `ontos/core/` | Medium |
| 1.4 | Mark impure functions with docstrings | Low |
| 1.5 | Create backwards-compat shim in `ontos_lib.py` | Low |
| 1.6 | Verify all existing tests pass (via shim) | Low |

**Exit Criteria:**
- All 225+ tests pass unchanged (using shim)
- `from ontos_lib import X` still works
- `from ontos.core.X import Y` also works
- Zero behavior change

---

### PR #2: Script Refactoring (Day 3)

**Goal:** Update scripts to use new imports and SessionContext.

| Task | Description | Risk |
|------|-------------|------|
| 2.1 | Refactor `ontos_generate_context_map.py` to use context | High |
| 2.2 | Refactor `ontos_end_session.py` to use context | High |
| 2.3 | Update remaining scripts to new imports | Medium |
| 2.4 | Verify all file writes go through context | Medium |
| 2.5 | Update tests to use new imports | Medium |

**Exit Criteria:**
- All tests pass with new imports
- Scripts use SessionContext for file operations
- Shim still works for external users

---

### PR #3: Unified CLI (Day 4)

**Goal:** Add `ontos.py` dispatcher.

| Task | Description | Risk |
|------|-------------|------|
| 3.1 | Create `ontos.py` dispatcher in project root | Low |
| 3.2 | Test all command mappings | Low |
| 3.3 | Test all aliases | Low |
| 3.4 | Add --help for each command | Low |

**Exit Criteria:**
- All commands work via `ontos.py`
- Old script paths still work
- Help text is accurate

---

### PR #4: Documentation & Polish (Day 5)

**Goal:** Update documentation and finalize release.

| Task | Description | Risk |
|------|-------------|------|
| 4.1 | Update Manual with new CLI syntax | Low |
| 4.2 | Update Agent Instructions | Low |
| 4.3 | Write migration guide | Low |
| 4.4 | Version bump to 2.8.0 | Low |
| 4.5 | Final test suite run | Low |

**Exit Criteria:**
- Documentation reflects v2.8 features
- Migration guide complete
- All tests pass
- Ready for release

---

## 5. LLM Review Board Decisions

### Review Process

| Round | Focus | Outcome |
|-------|-------|---------|
| Round 1 | Initial review of v1.0.0 | Identified gaps, voted on 10 open questions |
| Chief Architect | Critical review of reviews | Refined solutions, resolved disagreements |
| Round 2 | Review of v2.0.0 | **APPROVED** by all three reviewers |

### Round 1 Reviewers
- **Claude Opus 4.5** — Practical, actionable feedback
- **Codex** — Risk-focused, identified package collision concern
- **Gemini** — Structured, identified "In-Between State Risk"

### Resolved Questions

| Q# | Question | Decision | Rationale |
|----|----------|----------|-----------|
| **Q1** | Subprocess abstraction | **C: Keep in core, mark as impure** | Only 2 functions use subprocess. Over-abstraction for 2 functions is architectural astronautics. Mark with docstrings, mock in tests. |
| **Q2** | Deprecation (imports) | **B: v2.9** | Silent transition in v2.8. Don't punish early adopters. |
| **Q3** | Deprecation (CLI) | **B: v2.9** | Same reasoning. v2.8 introduces, v2.9 warns, v3.0 removes. |
| **Q4** | ontos.py location | **A: Project root** | Visibility > cleanliness. Matches v3.0 pattern. |
| **Q5** | SessionContext granularity | **B: Standard** | Config + env + cwd + pending_writes + warnings. Matches master plan requirements. |
| **Q6** | Transaction scope | **A: Per-command** | Simple mental model. Shell owns transaction lifecycle. |
| **Q7** | Package name | **A: `ontos/`** | Simple, matches v3.0. Collision concern is theoretical (v3.0 replaces local scripts entirely). |
| **Q8** | Test migration | **C: Both paths via shim** | Shim makes this a false choice. Tests work with old imports, can migrate gradually. |
| **Q9** | Config injection | **B: Class method factory** | `SessionContext.from_repo(path)` encapsulates config loading. |
| **Q10** | File locking | **C: PID lock with stale detection** | Zero-dependency, handles crashed processes. |

### Key Refinements from Review

| Issue | Source | Resolution |
|-------|--------|------------|
| `commit()` not atomic | Claude, Codex | Two-phase commit (temp-then-rename) |
| Stale lock detection | Chief Architect | PID liveness check in `_acquire_lock()` |
| Output in SessionContext | Claude → Chief Architect | Moved to separate `OutputHandler` |
| Single atomic PR | Gemini | Replaced with 4 phased PRs |
| Shell testability | Gemini | Added Section 8.4 |
| Migration guide | Claude | Added Section 10 |

---

## 6. Success Criteria

v2.8 is complete when:

### Core Requirements

1. `ontos/core/` package exists with pure functions
2. `SessionContext` dataclass implemented with two-phase commit
3. No print() statements in `ontos/core/`
4. Impure functions marked with docstrings
5. Backwards-compat shim works for all existing imports
6. `ontos.py` CLI dispatcher works for all commands
7. Lock implementation includes stale detection

### Testing Requirements

8. All 225+ tests pass
9. New tests for SessionContext (commit/rollback/locking)
10. CLI commands work identically to old scripts
11. CLI dispatcher tests (aliases, help, unknown commands)

### Documentation Requirements

12. Manual updated with new CLI syntax
13. Migration guide for v2.7.1 → v2.8

### Quality Requirements

14. Strict validation passes
15. No new warnings in test suite
16. Performance unchanged (no regression)

---

## 7. Risk Analysis

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Breaking existing scripts | Medium | High | Backwards-compat shim, phased PRs |
| Partial merge breaks codebase | Medium | High | Each PR is stable; shim enables this |
| Over-engineering SessionContext | Low | Medium | Documented scope limits |
| Lock contention | Low | Medium | Stale detection, 5s timeout |
| CLI command confusion | Low | Low | Clear aliases, good help text |

### Rollback Plan

If v2.8 causes issues:

1. Revert PR by PR (each is independent)
2. `ontos_lib.py` shim ensures old code still works
3. No user data is affected (this is code-only change)

---

## 8. Testing Strategy

### 8.1 Unit Tests — SessionContext

```python
# test_context.py
class TestSessionContext:
    def test_buffer_write(self):
        ctx = SessionContext(repo_root=Path('/tmp'), config={})
        ctx.buffer_write(Path('/tmp/test.md'), 'content')
        assert len(ctx.pending_writes) == 1

    def test_commit_creates_file(self, tmp_path):
        ctx = SessionContext(repo_root=tmp_path, config={})
        ctx.buffer_write(tmp_path / 'test.md', 'content')
        modified = ctx.commit()
        assert (tmp_path / 'test.md').read_text() == 'content'
        assert len(modified) == 1

    def test_commit_is_atomic(self, tmp_path):
        """Verify temp-then-rename pattern."""
        ctx = SessionContext(repo_root=tmp_path, config={})
        ctx.buffer_write(tmp_path / 'test.md', 'content')

        # Patch rename to fail
        with patch.object(Path, 'rename', side_effect=IOError("fail")):
            with pytest.raises(IOError):
                ctx.commit()

        # Temp file should be cleaned up
        assert not (tmp_path / 'test.md.tmp').exists()
        # Original should not exist (never created)
        assert not (tmp_path / 'test.md').exists()

    def test_rollback_clears_buffer(self):
        ctx = SessionContext(repo_root=Path('/tmp'), config={})
        ctx.buffer_write(Path('/tmp/test.md'), 'content')
        ctx.rollback()
        assert len(ctx.pending_writes) == 0

    def test_warn_collects_warnings(self):
        ctx = SessionContext(repo_root=Path('/tmp'), config={})
        ctx.warn("Test warning")
        assert "Test warning" in ctx.warnings

    def test_from_repo_factory(self, tmp_path):
        # Create minimal config
        (tmp_path / 'ontos_config.py').write_text('')
        ctx = SessionContext.from_repo(tmp_path)
        assert ctx.repo_root == tmp_path
```

### 8.2 Unit Tests — Locking

```python
# test_locking.py
class TestLocking:
    def test_acquire_lock_success(self, tmp_path):
        ctx = SessionContext(repo_root=tmp_path, config={})
        lock_path = tmp_path / '.ontos' / 'write.lock'
        assert ctx._acquire_lock(lock_path)
        assert lock_path.exists()
        assert lock_path.read_text() == str(os.getpid())
        ctx._release_lock(lock_path)

    def test_stale_lock_detection(self, tmp_path):
        """Lock held by dead process should be removed."""
        lock_path = tmp_path / '.ontos' / 'write.lock'
        lock_path.parent.mkdir(parents=True)
        lock_path.write_text('99999999')  # Non-existent PID

        ctx = SessionContext(repo_root=tmp_path, config={})
        assert ctx._acquire_lock(lock_path, timeout=1.0)
        ctx._release_lock(lock_path)

    def test_lock_contention_timeout(self, tmp_path):
        """Lock held by live process should timeout."""
        lock_path = tmp_path / '.ontos' / 'write.lock'
        lock_path.parent.mkdir(parents=True)
        lock_path.write_text(str(os.getpid()))  # Our own PID (alive)

        ctx = SessionContext(repo_root=tmp_path, config={})
        assert not ctx._acquire_lock(lock_path, timeout=0.5)
```

### 8.3 Integration Tests — Backwards Compat

```python
# test_shim.py
class TestBackwardsCompat:
    def test_old_import_works(self):
        """Shim preserves old import paths."""
        from ontos_lib import parse_frontmatter
        assert callable(parse_frontmatter)

    def test_new_import_works(self):
        """New import paths work."""
        from ontos.core.frontmatter import parse_frontmatter
        assert callable(parse_frontmatter)

    def test_same_function(self):
        """Old and new imports reference same function."""
        from ontos_lib import parse_frontmatter as old
        from ontos.core.frontmatter import parse_frontmatter as new
        assert old is new
```

### 8.4 CLI Dispatcher Tests

```python
# test_cli.py
class TestUnifiedCLI:
    def test_help_flag(self, tmp_path):
        result = subprocess.run(
            ['python3', 'ontos.py', '--help'],
            cwd=tmp_path,
            capture_output=True,
            text=True
        )
        assert result.returncode == 0
        assert 'Usage:' in result.stdout

    def test_version_flag(self, tmp_path):
        result = subprocess.run(
            ['python3', 'ontos.py', '--version'],
            cwd=tmp_path,
            capture_output=True,
            text=True
        )
        assert result.returncode == 0
        assert 'Ontos' in result.stdout

    def test_unknown_command(self, tmp_path):
        result = subprocess.run(
            ['python3', 'ontos.py', 'nonexistent'],
            cwd=tmp_path,
            capture_output=True,
            text=True
        )
        assert result.returncode == 1
        assert 'Unknown command' in result.stdout

    def test_alias_resolution(self, tmp_path):
        """Aliases should resolve to primary commands."""
        result = subprocess.run(
            ['python3', 'ontos.py', 'archive', '--help'],
            cwd=tmp_path,
            capture_output=True,
            text=True
        )
        assert result.returncode == 0  # 'archive' → 'log'

    def test_each_command_has_help(self, tmp_path):
        """Every command should respond to --help."""
        commands = ['log', 'map', 'verify', 'init', 'maintain',
                   'consolidate', 'query', 'update']
        for cmd in commands:
            result = subprocess.run(
                ['python3', 'ontos.py', cmd, '--help'],
                cwd=tmp_path,
                capture_output=True,
                text=True
            )
            assert result.returncode == 0, f"{cmd} --help failed"
```

### 8.5 Regression Tests

- Run existing test suite without modification
- Verify backwards-compat shim preserves behavior
- Compare output of old vs new CLI for same operations

---

## 9. Appendix: Master Plan References

### From Section 0 (Core Invariants)

> **4. Functional Core, Imperative Shell:** Logic must be separated from I/O. The "Brain" (Logic) never calls print() or input().

### From Section II (Roadmap)

> **v2.8 Context Object Refactor (Arch):** SessionContext dataclass. Split ontos.lib.core (Pure) vs ontos.lib.ui.
>
> **v2.8 Unified CLI (UX):** Dispatcher python3 ontos.py [init|log]. Deprecate direct script usage.

### From Section III.1 (Context Object Pattern)

> We must implement a Transactional Session pattern. The Core Logic never touches disk directly; it buffers changes.

### Watch-outs from LLM Consensus

> **Claude/Gemini:** CRITICAL. Do not hide state. Use "Transaction Boundaries" (commit/rollback) for file writes. Logic layer must capture all env state (CWD, Env Vars) to be testable.
>
> **Codex:** Ensure this wrapper handles sys.argv parsing robustly. Provide clear deprecation warnings for old scripts.

---

## 10. Migration Guide

### 10.1 Upgrading from v2.7.1 to v2.8

#### For End Users

**No action required.** All commands work identically.

| v2.7.1 Command | v2.8 Equivalent | Status |
|----------------|-----------------|--------|
| `python3 .ontos/scripts/ontos_end_session.py -e feature` | `python3 ontos.py log -e feature` | Both work |
| `python3 .ontos/scripts/ontos_generate_context_map.py` | `python3 ontos.py map` | Both work |
| `python3 .ontos/scripts/ontos_verify.py --all` | `python3 ontos.py verify --all` | Both work |

**Recommended:** Start using `ontos.py` commands for shorter syntax.

#### For Custom Integrations

**Imports:**
```python
# Old imports still work (v2.8, v2.9)
from ontos_lib import parse_frontmatter

# New imports available
from ontos.core.frontmatter import parse_frontmatter
```

**Direct script calls:**
```bash
# Still works
python3 .ontos/scripts/ontos_end_session.py

# New CLI available
python3 ontos.py log
```

#### For CI/CD Pipelines

No changes required. Existing commands continue to work.

**Optional upgrade:**
```yaml
# Before
- run: python3 .ontos/scripts/ontos_generate_context_map.py --strict --quiet

# After (cleaner)
- run: python3 ontos.py map --strict --quiet
```

### 10.2 Deprecation Timeline

| Version | Behavior |
|---------|----------|
| v2.8 | Both paths work, no warnings |
| v2.9 | Old paths emit DeprecationWarning |
| v3.0 | Old paths removed, `pip install ontos` only |

### 10.3 Upgrade Command

```bash
# Update Ontos scripts to v2.8
python3 .ontos/scripts/ontos_update.py

# Or with new CLI (after update)
python3 ontos.py update
```

---

## 11. Deferred Items (Out of Scope for v2.8)

Per Codex Round 2 feedback, the following items are noted but deferred:

| Item | Rationale | Target Version |
|------|-----------|----------------|
| Windows rename atomicity | POSIX-only for v2.8; add fallback if Windows support needed | v2.9 or v3.0 |
| Git provider interface | Current impure marking sufficient; full interface if MCP needs it | v3.0 |
| Warnings filter in conftest | Not needed until v2.9 when deprecation warnings activate | v2.9 |
| sys.path ordering docs | One-line note in migration guide sufficient for now | v3.0 |
| Binary writes/chmod | Text-only writes for v2.8; SessionContext scope limit | v3.0 if needed |

---

*End of v2.8 Implementation Plan v2.0.1*

*APPROVED by LLM Review Board (Claude, Codex, Gemini) on 2025-12-20.*
*Ready for implementation.*
