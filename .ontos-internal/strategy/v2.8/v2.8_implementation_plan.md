---
id: v2_8_implementation_plan
type: strategy
status: active
depends_on: [master_plan_v4, v2_7_1_implementation_plan]
concepts: [architecture, refactor, cli, context-object]
---

# v2.8 Implementation Plan

**Author:** Claude Code (Opus 4.5) as Chief Architect
**Date:** 2025-12-20 (updated 2025-12-22)
**Version:** 2.2.0
**Goal:** Prepare architecture for v3.0 (MCP Server) through Context Object Refactor and Unified CLI
**Status:** APPROVED â€” Ready for Implementation

---

## LLM Review Board Approval

| Reviewer | Round 1 | Round 2 | Final Grade |
|----------|---------|---------|-------------|
| **Claude Opus 4.5** | A- (gaps identified) | A | APPROVED |
| **Codex** | Approved with concerns | Approved with minor clarifications | APPROVED |
| **Gemini** | Approve with recommendations | "Unequivocally approved" | APPROVED |

**Approval Date:** 2025-12-20

### Round 2 Summary

**Claude:** All gaps closed (atomicity, warning output, migration guide, lock implementation). Grade upgraded from A- to A.

**Codex:** Plan aligns well with master plan. Minor non-blocking notes:
- Windows portability note for rename atomicity (POSIX-only)
- Consider tiny git provider interface for MCP testing (deferred to v3.0)
- Add warnings filter in conftest when v2.9 deprecations go live
- Document sys.path ordering to prevent PyPI collision

**Gemini:** "Outstanding piece of architectural work... unequivocally APPROVED FOR IMPLEMENTATION."

---

## Revision History

| Version | Date | Changes |
|---------|------|---------|
| 1.0.0 | 2025-12-20 | Initial draft with 10 open questions |
| 2.0.0 | 2025-12-20 | Incorporated LLM Review Board feedback (Claude, Codex, Gemini) |
| 2.0.1 | 2025-12-20 | LLM Review Board Round 2 approval |
| 2.1.0 | 2025-12-21 | Added Section 12: Implementation Progress (v2.8.1, v2.8.2, v2.8.3) |
| 2.2.0 | 2025-12-22 | Updated Section 12 for v2.8.3/v2.8.4 completion; expanded v2.8.5 tasks; fixed CLI mapping for missing `init` command |

### Key Changes in v2.0.0

1. **Two-phase commit** â€” Replaced sequential writes with temp-then-rename for true atomicity
2. **Stale lock detection** â€” Added PID liveness checking to lock implementation
3. **Phased PR strategy** â€” Replaced single atomic PR with 3 stable, reviewable PRs
4. **Shell testing strategy** â€” Added explicit CLI dispatcher tests
5. **Migration guide** â€” Added Section 10 for v2.7.1 â†’ v2.8 upgrade path
6. **Impure function marking** â€” Explicit documentation of subprocess-calling functions
7. **SessionContext scope limits** â€” Documented what SessionContext should NOT do
8. **Chief Architect decisions** â€” Resolved all 10 open questions with rationale

---

## Executive Summary

v2.8 is an **architectural refactoring release** with two major features:

1. **Context Object Refactor** â€” Split `ontos_lib.py` into pure logic (`ontos/core/`) and I/O (`ontos/ui/`), introduce `SessionContext` dataclass with transaction boundaries.

2. **Unified CLI** â€” Create `ontos.py` dispatcher to replace direct script invocation, preparing users for v3.0 syntax.

**Why Now:** v3.0 will expose Ontos functionality via MCP Server. The current architecture mixes I/O with logic, making it impossible to expose as an API. v2.8 creates the clean separation required.

**Risk Level:** HIGH â€” This is the highest-risk V2 release. A flawed execution could destabilize the platform. (Per Gemini review)

**Current State:** v2.7.1 stable (225 tests, 0 validation issues)
**Target State:** v2.8 with clean architecture ready for v3.0

---

## Table of Contents

1. [Current Architecture Analysis](#1-current-architecture-analysis)
2. [Feature 1: Context Object Refactor](#2-feature-1-context-object-refactor)
3. [Feature 2: Unified CLI](#3-feature-2-unified-cli)
4. [Implementation Phases](#4-implementation-phases)
5. [LLM Review Board Decisions](#5-llm-review-board-decisions)
6. [Success Criteria](#6-success-criteria)
7. [Risk Analysis](#7-risk-analysis)
8. [Testing Strategy](#8-testing-strategy)
9. [Appendix: Master Plan References](#9-appendix-master-plan-references)
10. [Migration Guide](#10-migration-guide)
11. [Deferred Items](#11-deferred-items-out-of-scope-for-v28)
12. [Implementation Progress](#12-implementation-progress)

---

## 1. Current Architecture Analysis

### 1.1 Script Inventory

| Script | Lines | Has main() | Uses argparse | Purpose |
|--------|-------|------------|---------------|---------|
| `ontos_lib.py` | 1,286 | No | No | Shared library |
| `ontos_end_session.py` | 1,693 | Yes | Yes | Archive sessions |
| `ontos_generate_context_map.py` | 1,223 | Yes | Yes | Generate context map |
| `ontos_consolidate.py` | 396 | Yes | Yes | Archive old logs |
| `ontos_verify.py` | 262 | Yes | Yes | Verify describes dates |
| `ontos_maintain.py` | 250 | Yes | Yes | Maintenance tasks |
| `ontos_query.py` | 234 | Yes | Yes | Query documents |
| Others (10) | ~2,900 | Mixed | Mixed | Various utilities |

**Total:** ~7,900 lines across 17 scripts

### 1.2 Current I/O Violations in ontos_lib.py

The library currently contains **7 print() statements** that violate the "Functional Core, Imperative Shell" principle:

| Line | Statement | Context |
|------|-----------|---------|
| 94 | `print("WARN: git not found...")` | Git fallback |
| 100 | `print("WARN: git command timed out...")` | Git timeout |
| 558 | `print(f"WARN: {w}")` | Validation warning |
| 641 | `print(f"Error parsing YAML...")` | YAML error |
| 987-989 | `print()` x3 | Deprecation warning |

**Problem:** These print statements prevent the library from being used in non-CLI contexts (API, MCP Server, tests).

### 1.3 Current State Access Patterns

Scripts currently access state through multiple patterns:

```python
# Pattern 1: Direct function calls with implicit config
from ontos_lib import get_logs_dir, resolve_config
logs_dir = get_logs_dir()  # Uses config internally

# Pattern 2: Config module import
from ontos_config import DOCS_DIR, AUTO_ARCHIVE_ON_PUSH

# Pattern 3: Environment variable fallback
source = os.environ.get('ONTOS_SOURCE', config.DEFAULT_SOURCE)
```

**Problem:** State is scattered across module-level variables, environment variables, and config imports. This makes testing difficult and prevents dependency injection.

---

## 2. Feature 1: Context Object Refactor

### 2.1 Design: SessionContext Dataclass

Per the Master Plan (Section 3.1), we implement a transactional session pattern:

```python
from dataclasses import dataclass, field
from pathlib import Path
from typing import Dict, List, Optional
from enum import Enum
import os
import time

class FileOperation(Enum):
    WRITE = "write"
    DELETE = "delete"
    MOVE = "move"

@dataclass
class PendingWrite:
    """A buffered file operation."""
    operation: FileOperation
    path: Path
    content: Optional[str] = None  # For WRITE
    destination: Optional[Path] = None  # For MOVE

@dataclass
class SessionContext:
    """Captures all state for an Ontos session.

    This is the single source of truth for:
    - Repository configuration
    - Environment state
    - Pending file operations (transaction buffer)

    SCOPE LIMITS (v2.0.0):
    SessionContext should NOT:
    - Handle output formatting (that's OutputHandler's job)
    - Contain I/O providers (keep git calls as marked impure functions)
    - Cache parsed documents (keep it focused on transaction state)
    - Grow beyond config + env + writes + diagnostics
    """
    # Immutable state (set at creation)
    repo_root: Path
    config: Dict
    cwd: Path = field(default_factory=Path.cwd)
    env: Dict[str, str] = field(default_factory=lambda: dict(os.environ))

    # Mutable state (changes during session)
    pending_writes: List[PendingWrite] = field(default_factory=list)
    warnings: List[str] = field(default_factory=list)
    errors: List[str] = field(default_factory=list)

    @classmethod
    def from_repo(cls, repo_root: Path) -> 'SessionContext':
        """Factory method to create context from repository path.

        This encapsulates config loading logic.
        """
        from ontos_config import resolve_config
        config = resolve_config(repo_root)
        return cls(repo_root=repo_root, config=config)

    def buffer_write(self, path: Path, content: str) -> None:
        """Buffer a file write for later commit."""
        self.pending_writes.append(PendingWrite(
            operation=FileOperation.WRITE,
            path=path,
            content=content
        ))

    def buffer_delete(self, path: Path) -> None:
        """Buffer a file deletion for later commit."""
        self.pending_writes.append(PendingWrite(
            operation=FileOperation.DELETE,
            path=path
        ))

    def buffer_move(self, source: Path, destination: Path) -> None:
        """Buffer a file move for later commit."""
        self.pending_writes.append(PendingWrite(
            operation=FileOperation.MOVE,
            path=source,
            destination=destination
        ))

    def commit(self) -> List[Path]:
        """Execute all buffered operations with two-phase commit.

        ATOMICITY: Uses temp-then-rename pattern. If any operation fails,
        previous temp files are cleaned up. Rename is atomic on POSIX.

        Returns:
            List of paths successfully modified.

        Raises:
            IOError: If a write operation fails.
            RuntimeError: If lock cannot be acquired.
        """
        if not self.pending_writes:
            return []

        lock_path = self.repo_root / '.ontos' / 'write.lock'
        if not self._acquire_lock(lock_path):
            raise RuntimeError(
                "Could not acquire write lock. "
                "Another Ontos process may be running."
            )

        staged: List[tuple[Path, Path]] = []  # (temp, final)
        modified: List[Path] = []

        try:
            # Phase 1: Write to temp files
            for op in self.pending_writes:
                if op.operation == FileOperation.WRITE:
                    op.path.parent.mkdir(parents=True, exist_ok=True)
                    temp = op.path.with_suffix(op.path.suffix + '.tmp')
                    temp.write_text(op.content)
                    staged.append((temp, op.path))
                elif op.operation == FileOperation.DELETE:
                    if op.path.exists():
                        # For delete, we stage by tracking what to delete
                        staged.append((None, op.path))
                elif op.operation == FileOperation.MOVE:
                    if op.path.exists():
                        staged.append((op.path, op.destination))

            # Phase 2: Atomic rename/apply
            for temp, final in staged:
                if temp is None:
                    # Delete operation
                    final.unlink()
                    modified.append(final)
                elif temp != final:
                    # Write or Move: rename temp to final (atomic on POSIX)
                    temp.rename(final)
                    modified.append(final)

        except Exception as e:
            # Cleanup temp files on failure
            for temp, final in staged:
                if temp is not None and temp != final and temp.exists():
                    temp.unlink(missing_ok=True)
            self.error(f"Commit failed: {e}")
            raise

        finally:
            self._release_lock(lock_path)
            self.pending_writes.clear()

        return modified

    def rollback(self) -> None:
        """Discard all buffered operations."""
        self.pending_writes.clear()

    def warn(self, message: str) -> None:
        """Record a warning (does not print)."""
        self.warnings.append(message)

    def error(self, message: str) -> None:
        """Record an error (does not print)."""
        self.errors.append(message)

    def _acquire_lock(self, lock_path: Path, timeout: float = 5.0) -> bool:
        """Acquire a simple file lock with stale detection.

        Uses atomic file creation (O_CREAT | O_EXCL). If a stale lock
        is detected (holding process is dead), it is automatically removed.

        Args:
            lock_path: Path to lock file
            timeout: Maximum seconds to wait

        Returns:
            True if lock acquired, False if timeout
        """
        lock_path.parent.mkdir(parents=True, exist_ok=True)
        start = time.time()

        while time.time() - start < timeout:
            try:
                fd = os.open(str(lock_path), os.O_CREAT | os.O_EXCL | os.O_WRONLY)
                os.write(fd, str(os.getpid()).encode())
                os.close(fd)
                return True
            except FileExistsError:
                # Check if holding process is still alive
                try:
                    pid = int(lock_path.read_text().strip())
                    os.kill(pid, 0)  # Raises if process doesn't exist
                except (ProcessLookupError, ValueError, OSError):
                    # Stale lock - process is dead, remove it
                    try:
                        lock_path.unlink()
                    except FileNotFoundError:
                        pass
                    continue
                time.sleep(0.1)

        return False

    def _release_lock(self, lock_path: Path) -> None:
        """Release the file lock."""
        try:
            lock_path.unlink()
        except FileNotFoundError:
            pass  # Already released
```

### 2.2 Output Handling (Separate from SessionContext)

Per Chief Architect review: **Output formatting does NOT belong in SessionContext.**

```python
# ontos/ui/output.py
class OutputHandler:
    """Handles all output formatting and display.

    This is the ONLY place that knows about emoji and formatting.
    """
    def __init__(self, quiet: bool = False):
        self.quiet = quiet

    def display_warnings(self, warnings: List[str]) -> None:
        """Display collected warnings after commit."""
        if self.quiet:
            return
        for w in warnings:
            print(f"Warning: {w}")

    def display_errors(self, errors: List[str]) -> None:
        """Display collected errors."""
        for e in errors:
            print(f"Error: {e}")

    def success(self, message: str) -> None:
        """Display a success message."""
        if not self.quiet:
            print(message)
```

### 2.3 Script Usage Pattern

```python
# How scripts should use SessionContext
def main():
    output = OutputHandler(quiet=args.quiet)
    ctx = SessionContext.from_repo(Path.cwd())

    try:
        # Do work, buffer writes via ctx.buffer_write()
        result = some_operation(ctx)
        modified = ctx.commit()
        output.success(f"Modified {len(modified)} files")
    except Exception as e:
        ctx.rollback()
        output.display_errors([str(e)])
        return 1
    finally:
        output.display_warnings(ctx.warnings)

    return 0
```

### 2.4 Library Split Strategy

**Current structure:**
```
.ontos/scripts/
â”œâ”€â”€ ontos_lib.py          # Mixed pure + impure
â”œâ”€â”€ ontos_config.py       # Config wrapper
â”œâ”€â”€ ontos_config_defaults.py
â””â”€â”€ ontos_*.py            # Scripts (impure)
```

**Proposed structure:**
```
.ontos/scripts/
â”œâ”€â”€ ontos/                 # New package
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ core/              # Pure logic (no I/O except marked impure)
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ context.py     # SessionContext
â”‚   â”‚   â”œâ”€â”€ frontmatter.py # Parsing, validation
â”‚   â”‚   â”œâ”€â”€ graph.py       # Dependency analysis
â”‚   â”‚   â”œâ”€â”€ history.py     # Decision history generation
â”‚   â”‚   â””â”€â”€ staleness.py   # Describes/staleness logic
â”‚   â””â”€â”€ ui/                # I/O layer
â”‚       â”œâ”€â”€ __init__.py
â”‚       â”œâ”€â”€ cli.py         # Unified CLI dispatcher
â”‚       â”œâ”€â”€ output.py      # OutputHandler
â”‚       â””â”€â”€ prompts.py     # Interactive input
â”œâ”€â”€ ontos_lib.py           # DEPRECATED: Shim for backwards compat
â”œâ”€â”€ ontos_config.py        # Unchanged
â””â”€â”€ ontos_*.py             # Scripts (refactored to use core/)
```

### 2.5 Function Classification with Impurity Marking

| Function | Target Location | Pure? | Notes |
|----------|-----------------|-------|-------|
| `parse_frontmatter()` | core/frontmatter | Yes | |
| `normalize_describes()` | core/staleness | Yes | |
| `validate_describes_field()` | core/staleness | Yes | |
| `generate_decision_history()` | core/history | Yes | |
| `check_staleness()` | core/staleness | **IMPURE** | Calls `get_file_modification_date` |
| `get_file_modification_date()` | core/staleness | **IMPURE** | Calls `subprocess.run` |
| `get_logs_dir()` | core/context | Yes | With injected config |
| `resolve_config()` | core/context | Yes | With injected config |
| `_warn_deprecated()` | ui/output | No | Prints |

**Impure Function Documentation Pattern:**

```python
def get_file_modification_date(path: Path, repo_root: Path) -> Optional[str]:
    """Get last modification date from git.

    IMPURE: This function calls subprocess.run() to execute git commands.
    For testing, mock this function directly:

        with patch('ontos.core.staleness.get_file_modification_date') as mock:
            mock.return_value = '2025-12-20'
            result = check_staleness(doc, ctx)

    Args:
        path: File path to check
        repo_root: Repository root for git context

    Returns:
        ISO date string or None if git unavailable
    """
    try:
        result = subprocess.run(
            ['git', 'log', '-1', '--format=%cs', str(path)],
            cwd=repo_root,
            capture_output=True,
            text=True,
            timeout=5
        )
        if result.returncode == 0:
            return result.stdout.strip()
    except (subprocess.TimeoutExpired, FileNotFoundError):
        pass
    return None
```

### 2.6 Backwards Compatibility Shim

```python
# ontos_lib.py (DEPRECATED - backwards compatibility shim)
"""
DEPRECATED: Import from ontos.core instead.
This module will be removed in v3.0.

v2.8: Silent operation (no warnings)
v2.9: DeprecationWarning on import
v3.0: Module removed
"""
# Direct re-exports (no __getattr__ overhead)
from ontos.core.frontmatter import parse_frontmatter, normalize_depends_on
from ontos.core.staleness import (
    ModifiedSource, normalize_describes, parse_describes_verified,
    validate_describes_field, detect_describes_cycles, check_staleness,
    get_file_modification_date, clear_git_cache
)
from ontos.core.history import (
    ParsedLog, parse_log_for_history, sort_logs_deterministically,
    generate_decision_history
)
from ontos.core.context import SessionContext
# ... all other re-exports
```

---

## 3. Feature 2: Unified CLI

### 3.1 Design: ontos.py Dispatcher

**Current invocation:**
```bash
python3 .ontos/scripts/ontos_end_session.py -e feature
python3 .ontos/scripts/ontos_generate_context_map.py --strict
python3 .ontos/scripts/ontos_verify.py --all
```

**Proposed invocation:**
```bash
python3 ontos.py log -e feature          # Archive session
python3 ontos.py map --strict            # Generate context map
python3 ontos.py verify --all            # Verify describes
python3 ontos.py init                    # Initialize project
python3 ontos.py maintain                # Run maintenance
```

### 3.2 Command Mapping

| New Command | Old Script | Aliases | Status |
|-------------|------------|---------|--------|
| `ontos.py log` | `ontos_end_session.py` | `archive`, `session` | âœ… v2.8.5 |
| `ontos.py map` | `ontos_generate_context_map.py` | `context`, `generate` | âœ… v2.8.5 |
| `ontos.py verify` | `ontos_verify.py` | `check` | âœ… v2.8.5 |
| `ontos.py init` | `ontos_init.py` | `setup` | ðŸ”² Deferred to v3.0 |
| `ontos.py maintain` | `ontos_maintain.py` | `maintenance` | âœ… v2.8.5 |
| `ontos.py consolidate` | `ontos_consolidate.py` | `archive-old` | âœ… v2.8.5 |
| `ontos.py query` | `ontos_query.py` | `search`, `find` | âœ… v2.8.5 |
| `ontos.py update` | `ontos_update.py` | `upgrade` | âœ… v2.8.5 |

> **Note:** `ontos_init.py` does not exist. The `init` command is deferred to v3.0 when Ontos becomes a pip-installable package.

### 3.3 CLI Implementation

```python
#!/usr/bin/env python3
"""Ontos CLI - Unified command interface.

Usage:
    python3 ontos.py <command> [options]
    python3 ontos.py --help
    python3 ontos.py --version

Commands:
    log         Archive a session (creates log file)
    map         Generate context map
    verify      Verify describes dates
    init        Initialize Ontos in a project
    maintain    Run maintenance tasks
    consolidate Archive old logs
    query       Search documents
    update      Update Ontos scripts

Examples:
    python3 ontos.py log -e feature         # Log a feature session
    python3 ontos.py map --strict           # Generate with strict validation
    python3 ontos.py verify --all           # Verify all stale docs
"""

import sys
from pathlib import Path

# Add scripts directory to path for imports
SCRIPTS_DIR = Path(__file__).parent / '.ontos' / 'scripts'
sys.path.insert(0, str(SCRIPTS_DIR))

COMMANDS = {
    'log': ('ontos_end_session', 'Archive a session'),
    'map': ('ontos_generate_context_map', 'Generate context map'),
    'verify': ('ontos_verify', 'Verify describes dates'),
    'init': ('ontos_init', 'Initialize Ontos'),
    'maintain': ('ontos_maintain', 'Run maintenance'),
    'consolidate': ('ontos_consolidate', 'Archive old logs'),
    'query': ('ontos_query', 'Search documents'),
    'update': ('ontos_update', 'Update Ontos'),
}

ALIASES = {
    'archive': 'log', 'session': 'log',
    'context': 'map', 'generate': 'map',
    'check': 'verify',
    'setup': 'init',
    'maintenance': 'maintain',
    'archive-old': 'consolidate',
    'search': 'query', 'find': 'query',
    'upgrade': 'update',
}

def main():
    if len(sys.argv) < 2 or sys.argv[1] in ('-h', '--help'):
        print(__doc__)
        return 0

    if sys.argv[1] in ('-V', '--version'):
        from ontos_config_defaults import ONTOS_VERSION
        print(f"Ontos {ONTOS_VERSION}")
        return 0

    command = sys.argv[1]
    command = ALIASES.get(command, command)

    if command not in COMMANDS:
        print(f"Unknown command: {command}")
        print(f"Available: {', '.join(sorted(COMMANDS.keys()))}")
        return 1

    module_name, _ = COMMANDS[command]

    # Import and run the module
    import importlib
    module = importlib.import_module(module_name)

    # Replace sys.argv for the subcommand
    sys.argv = [module_name + '.py'] + sys.argv[2:]

    return module.main()

if __name__ == '__main__':
    sys.exit(main() or 0)
```

### 3.4 Deprecation Strategy

**Phase 1 (v2.8):** Introduce `ontos.py`, no deprecation warnings. Silent transition.

**Phase 2 (v2.9):** Add deprecation warnings to direct script usage and old imports.

**Phase 3 (v3.0):** Scripts become internal-only, `pip install ontos` replaces local scripts.

### 3.5 Location of ontos.py

**Decision: Project root (`./ontos.py`)**

Rationale: Easy discovery, matches v3.0 pattern, superior UX over cleanliness concerns.

---

## 4. Implementation Phases

### CRITICAL: Phased PR Strategy

Per Chief Architect review and Gemini's "In-Between State Risk" insight, implementation MUST use multiple stable PRs, not a single atomic PR.

**Why:** A 7,900+ line single PR is:
- Impossible to review effectively
- Creates massive merge conflict risk
- Violates incremental change principles

**The backwards-compat shim enables safe phasing** â€” each PR leaves the codebase in a working state.

---

### PR #1: Library Structure (Days 1-2)

**Goal:** Create new package structure with backwards-compat shim.

| Task | Description | Risk |
|------|-------------|------|
| 1.1 | Create `ontos/` package structure | Low |
| 1.2 | Create `ontos/core/context.py` with SessionContext | Medium |
| 1.3 | Move pure functions to `ontos/core/` | Medium |
| 1.4 | Mark impure functions with docstrings | Low |
| 1.5 | Create backwards-compat shim in `ontos_lib.py` | Low |
| 1.6 | Verify all existing tests pass (via shim) | Low |

**Exit Criteria:**
- All 225+ tests pass unchanged (using shim)
- `from ontos_lib import X` still works
- `from ontos.core.X import Y` also works
- Zero behavior change

---

### PR #2: Script Refactoring (Day 3)

**Goal:** Update scripts to use new imports and SessionContext.

| Task | Description | Risk |
|------|-------------|------|
| 2.1 | Refactor `ontos_generate_context_map.py` to use context | High |
| 2.2 | Refactor `ontos_end_session.py` to use context | High |
| 2.3 | Update remaining scripts to new imports | Medium |
| 2.4 | Verify all file writes go through context | Medium |
| 2.5 | Update tests to use new imports | Medium |

**Exit Criteria:**
- All tests pass with new imports
- Scripts use SessionContext for file operations
- Shim still works for external users

---

### PR #3: Unified CLI (Day 4)

**Goal:** Add `ontos.py` dispatcher.

| Task | Description | Risk |
|------|-------------|------|
| 3.1 | Create `ontos.py` dispatcher in project root | Low |
| 3.2 | Test all command mappings | Low |
| 3.3 | Test all aliases | Low |
| 3.4 | Add --help for each command | Low |

**Exit Criteria:**
- All commands work via `ontos.py`
- Old script paths still work
- Help text is accurate

---

### PR #4: Documentation & Polish (Day 5)

**Goal:** Update documentation and finalize release.

| Task | Description | Risk |
|------|-------------|------|
| 4.1 | Update Manual with new CLI syntax | Low |
| 4.2 | Update Agent Instructions | Low |
| 4.3 | Write migration guide | Low |
| 4.4 | Version bump to 2.8.0 | Low |
| 4.5 | Final test suite run | Low |

**Exit Criteria:**
- Documentation reflects v2.8 features
- Migration guide complete
- All tests pass
- Ready for release

---

## 5. LLM Review Board Decisions

### Review Process

| Round | Focus | Outcome |
|-------|-------|---------|
| Round 1 | Initial review of v1.0.0 | Identified gaps, voted on 10 open questions |
| Chief Architect | Critical review of reviews | Refined solutions, resolved disagreements |
| Round 2 | Review of v2.0.0 | **APPROVED** by all three reviewers |

### Round 1 Reviewers
- **Claude Opus 4.5** â€” Practical, actionable feedback
- **Codex** â€” Risk-focused, identified package collision concern
- **Gemini** â€” Structured, identified "In-Between State Risk"

### Resolved Questions

| Q# | Question | Decision | Rationale |
|----|----------|----------|-----------|
| **Q1** | Subprocess abstraction | **C: Keep in core, mark as impure** | Only 2 functions use subprocess. Over-abstraction for 2 functions is architectural astronautics. Mark with docstrings, mock in tests. |
| **Q2** | Deprecation (imports) | **B: v2.9** | Silent transition in v2.8. Don't punish early adopters. |
| **Q3** | Deprecation (CLI) | **B: v2.9** | Same reasoning. v2.8 introduces, v2.9 warns, v3.0 removes. |
| **Q4** | ontos.py location | **A: Project root** | Visibility > cleanliness. Matches v3.0 pattern. |
| **Q5** | SessionContext granularity | **B: Standard** | Config + env + cwd + pending_writes + warnings. Matches master plan requirements. |
| **Q6** | Transaction scope | **A: Per-command** | Simple mental model. Shell owns transaction lifecycle. |
| **Q7** | Package name | **A: `ontos/`** | Simple, matches v3.0. Collision concern is theoretical (v3.0 replaces local scripts entirely). |
| **Q8** | Test migration | **C: Both paths via shim** | Shim makes this a false choice. Tests work with old imports, can migrate gradually. |
| **Q9** | Config injection | **B: Class method factory** | `SessionContext.from_repo(path)` encapsulates config loading. |
| **Q10** | File locking | **C: PID lock with stale detection** | Zero-dependency, handles crashed processes. |

### Key Refinements from Review

| Issue | Source | Resolution |
|-------|--------|------------|
| `commit()` not atomic | Claude, Codex | Two-phase commit (temp-then-rename) |
| Stale lock detection | Chief Architect | PID liveness check in `_acquire_lock()` |
| Output in SessionContext | Claude â†’ Chief Architect | Moved to separate `OutputHandler` |
| Single atomic PR | Gemini | Replaced with 4 phased PRs |
| Shell testability | Gemini | Added Section 8.4 |
| Migration guide | Claude | Added Section 10 |

---

## 6. Success Criteria

v2.8 is complete when:

### Core Requirements

1. `ontos/core/` package exists with pure functions
2. `SessionContext` dataclass implemented with two-phase commit
3. No print() statements in `ontos/core/`
4. Impure functions marked with docstrings
5. Backwards-compat shim works for all existing imports
6. `ontos.py` CLI dispatcher works for all commands
7. Lock implementation includes stale detection

### Testing Requirements

8. All 225+ tests pass
9. New tests for SessionContext (commit/rollback/locking)
10. CLI commands work identically to old scripts
11. CLI dispatcher tests (aliases, help, unknown commands)

### Documentation Requirements

12. Manual updated with new CLI syntax
13. Migration guide for v2.7.1 â†’ v2.8

### Quality Requirements

14. Strict validation passes
15. No new warnings in test suite
16. Performance unchanged (no regression)

---

## 7. Risk Analysis

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Breaking existing scripts | Medium | High | Backwards-compat shim, phased PRs |
| Partial merge breaks codebase | Medium | High | Each PR is stable; shim enables this |
| Over-engineering SessionContext | Low | Medium | Documented scope limits |
| Lock contention | Low | Medium | Stale detection, 5s timeout |
| CLI command confusion | Low | Low | Clear aliases, good help text |

### Rollback Plan

If v2.8 causes issues:

1. Revert PR by PR (each is independent)
2. `ontos_lib.py` shim ensures old code still works
3. No user data is affected (this is code-only change)

---

## 8. Testing Strategy

### 8.1 Unit Tests â€” SessionContext

```python
# test_context.py
class TestSessionContext:
    def test_buffer_write(self):
        ctx = SessionContext(repo_root=Path('/tmp'), config={})
        ctx.buffer_write(Path('/tmp/test.md'), 'content')
        assert len(ctx.pending_writes) == 1

    def test_commit_creates_file(self, tmp_path):
        ctx = SessionContext(repo_root=tmp_path, config={})
        ctx.buffer_write(tmp_path / 'test.md', 'content')
        modified = ctx.commit()
        assert (tmp_path / 'test.md').read_text() == 'content'
        assert len(modified) == 1

    def test_commit_is_atomic(self, tmp_path):
        """Verify temp-then-rename pattern."""
        ctx = SessionContext(repo_root=tmp_path, config={})
        ctx.buffer_write(tmp_path / 'test.md', 'content')

        # Patch rename to fail
        with patch.object(Path, 'rename', side_effect=IOError("fail")):
            with pytest.raises(IOError):
                ctx.commit()

        # Temp file should be cleaned up
        assert not (tmp_path / 'test.md.tmp').exists()
        # Original should not exist (never created)
        assert not (tmp_path / 'test.md').exists()

    def test_rollback_clears_buffer(self):
        ctx = SessionContext(repo_root=Path('/tmp'), config={})
        ctx.buffer_write(Path('/tmp/test.md'), 'content')
        ctx.rollback()
        assert len(ctx.pending_writes) == 0

    def test_warn_collects_warnings(self):
        ctx = SessionContext(repo_root=Path('/tmp'), config={})
        ctx.warn("Test warning")
        assert "Test warning" in ctx.warnings

    def test_from_repo_factory(self, tmp_path):
        # Create minimal config
        (tmp_path / 'ontos_config.py').write_text('')
        ctx = SessionContext.from_repo(tmp_path)
        assert ctx.repo_root == tmp_path
```

### 8.2 Unit Tests â€” Locking

```python
# test_locking.py
class TestLocking:
    def test_acquire_lock_success(self, tmp_path):
        ctx = SessionContext(repo_root=tmp_path, config={})
        lock_path = tmp_path / '.ontos' / 'write.lock'
        assert ctx._acquire_lock(lock_path)
        assert lock_path.exists()
        assert lock_path.read_text() == str(os.getpid())
        ctx._release_lock(lock_path)

    def test_stale_lock_detection(self, tmp_path):
        """Lock held by dead process should be removed."""
        lock_path = tmp_path / '.ontos' / 'write.lock'
        lock_path.parent.mkdir(parents=True)
        lock_path.write_text('99999999')  # Non-existent PID

        ctx = SessionContext(repo_root=tmp_path, config={})
        assert ctx._acquire_lock(lock_path, timeout=1.0)
        ctx._release_lock(lock_path)

    def test_lock_contention_timeout(self, tmp_path):
        """Lock held by live process should timeout."""
        lock_path = tmp_path / '.ontos' / 'write.lock'
        lock_path.parent.mkdir(parents=True)
        lock_path.write_text(str(os.getpid()))  # Our own PID (alive)

        ctx = SessionContext(repo_root=tmp_path, config={})
        assert not ctx._acquire_lock(lock_path, timeout=0.5)
```

### 8.3 Integration Tests â€” Backwards Compat

```python
# test_shim.py
class TestBackwardsCompat:
    def test_old_import_works(self):
        """Shim preserves old import paths."""
        from ontos_lib import parse_frontmatter
        assert callable(parse_frontmatter)

    def test_new_import_works(self):
        """New import paths work."""
        from ontos.core.frontmatter import parse_frontmatter
        assert callable(parse_frontmatter)

    def test_same_function(self):
        """Old and new imports reference same function."""
        from ontos_lib import parse_frontmatter as old
        from ontos.core.frontmatter import parse_frontmatter as new
        assert old is new
```

### 8.4 CLI Dispatcher Tests

```python
# test_cli.py
class TestUnifiedCLI:
    def test_help_flag(self, tmp_path):
        result = subprocess.run(
            ['python3', 'ontos.py', '--help'],
            cwd=tmp_path,
            capture_output=True,
            text=True
        )
        assert result.returncode == 0
        assert 'Usage:' in result.stdout

    def test_version_flag(self, tmp_path):
        result = subprocess.run(
            ['python3', 'ontos.py', '--version'],
            cwd=tmp_path,
            capture_output=True,
            text=True
        )
        assert result.returncode == 0
        assert 'Ontos' in result.stdout

    def test_unknown_command(self, tmp_path):
        result = subprocess.run(
            ['python3', 'ontos.py', 'nonexistent'],
            cwd=tmp_path,
            capture_output=True,
            text=True
        )
        assert result.returncode == 1
        assert 'Unknown command' in result.stdout

    def test_alias_resolution(self, tmp_path):
        """Aliases should resolve to primary commands."""
        result = subprocess.run(
            ['python3', 'ontos.py', 'archive', '--help'],
            cwd=tmp_path,
            capture_output=True,
            text=True
        )
        assert result.returncode == 0  # 'archive' â†’ 'log'

    def test_each_command_has_help(self, tmp_path):
        """Every command should respond to --help."""
        commands = ['log', 'map', 'verify', 'init', 'maintain',
                   'consolidate', 'query', 'update']
        for cmd in commands:
            result = subprocess.run(
                ['python3', 'ontos.py', cmd, '--help'],
                cwd=tmp_path,
                capture_output=True,
                text=True
            )
            assert result.returncode == 0, f"{cmd} --help failed"
```

### 8.5 Regression Tests

- Run existing test suite without modification
- Verify backwards-compat shim preserves behavior
- Compare output of old vs new CLI for same operations

---

## 9. Appendix: Master Plan References

### From Section 0 (Core Invariants)

> **4. Functional Core, Imperative Shell:** Logic must be separated from I/O. The "Brain" (Logic) never calls print() or input().

### From Section II (Roadmap)

> **v2.8 Context Object Refactor (Arch):** SessionContext dataclass. Split ontos.lib.core (Pure) vs ontos.lib.ui.
>
> **v2.8 Unified CLI (UX):** Dispatcher python3 ontos.py [init|log]. Deprecate direct script usage.

### From Section III.1 (Context Object Pattern)

> We must implement a Transactional Session pattern. The Core Logic never touches disk directly; it buffers changes.

### Watch-outs from LLM Consensus

> **Claude/Gemini:** CRITICAL. Do not hide state. Use "Transaction Boundaries" (commit/rollback) for file writes. Logic layer must capture all env state (CWD, Env Vars) to be testable.
>
> **Codex:** Ensure this wrapper handles sys.argv parsing robustly. Provide clear deprecation warnings for old scripts.

---

## 10. Migration Guide

### 10.1 Upgrading from v2.7.1 to v2.8

#### For End Users

**No action required.** All commands work identically.

| v2.7.1 Command | v2.8 Equivalent | Status |
|----------------|-----------------|--------|
| `python3 .ontos/scripts/ontos_end_session.py -e feature` | `python3 ontos.py log -e feature` | Both work |
| `python3 .ontos/scripts/ontos_generate_context_map.py` | `python3 ontos.py map` | Both work |
| `python3 .ontos/scripts/ontos_verify.py --all` | `python3 ontos.py verify --all` | Both work |

**Recommended:** Start using `ontos.py` commands for shorter syntax.

#### For Custom Integrations

**Imports:**
```python
# Old imports still work (v2.8, v2.9)
from ontos_lib import parse_frontmatter

# New imports available
from ontos.core.frontmatter import parse_frontmatter
```

**Direct script calls:**
```bash
# Still works
python3 .ontos/scripts/ontos_end_session.py

# New CLI available
python3 ontos.py log
```

#### For CI/CD Pipelines

No changes required. Existing commands continue to work.

**Optional upgrade:**
```yaml
# Before
- run: python3 .ontos/scripts/ontos_generate_context_map.py --strict --quiet

# After (cleaner)
- run: python3 ontos.py map --strict --quiet
```

### 10.2 Deprecation Timeline

| Version | Behavior |
|---------|----------|
| v2.8 | Both paths work, no warnings |
| v2.9 | Old paths emit DeprecationWarning |
| v3.0 | Old paths removed, `pip install ontos` only |

### 10.3 Upgrade Command

```bash
# Update Ontos scripts to v2.8
python3 .ontos/scripts/ontos_update.py

# Or with new CLI (after update)
python3 ontos.py update
```

---

## 11. Deferred Items (Out of Scope for v2.8)

Per Codex Round 2 feedback, the following items are noted but deferred:

| Item | Rationale | Target Version |
|------|-----------|----------------|
| Windows rename atomicity | POSIX-only for v2.8; add fallback if Windows support needed | v2.9 or v3.0 |
| Git provider interface | Current impure marking sufficient; full interface if MCP needs it | v3.0 |
| Warnings filter in conftest | Not needed until v2.9 when deprecation warnings activate | v2.9 |
| sys.path ordering docs | One-line note in migration guide sufficient for now | v3.0 |
| Binary writes/chmod | Text-only writes for v2.8; SessionContext scope limit | v3.0 if needed |

---

## 12. Implementation Progress

This section tracks the incremental implementation of v2.8 across multiple PRs.

### 12.1 Progress Overview

| Version | PR | Description | Grade | Status |
|---------|-----|-------------|-------|--------|
| v2.8.1 | #25 | Refactor `ontos_generate_context_map.py` | A- | âœ… Merged |
| v2.8.2 | #26 | Begin `ontos_end_session.py` refactoring | A- | âœ… Merged |
| v2.8.3 | #27 | Complete `ontos_end_session.py` to A+ | A+ | âœ… Merged |
| v2.8.4 | #28 | Refactor remaining scripts | A+ | âœ… Merged |
| **v2.8.5** | **#29** | **Unified CLI (`ontos.py`)** | Target: A+ | ðŸ”² In Progress |

---

### 12.2 v2.8.1: ontos_generate_context_map.py (PR #25) âœ…

**Status:** Merged
**Grade:** A-

**What Was Done:**
- Added SessionContext and OutputHandler imports
- Replaced direct file writes with `ctx.buffer_write()`
- Replaced `print()` with OutputHandler methods
- Added try/commit/except/rollback pattern
- Both context map and decision_history.md written atomically

**Minor Issues (Non-blocking):**
- Orphan `print()` in `scan_docs()` at line 206

---

### 12.3 v2.8.2: ontos_end_session.py Initial (PR #26) âœ…

**Status:** Merged
**Grade:** A-

**What Was Done:**
- main() owns SessionContext lifecycle
- try/except with rollback on error
- `create_log_file()` uses buffer_write + commit
- `_create_archive_marker()` accepts optional ctx
- 6 functions have OutputHandler
- Test updated to mock SessionContext

**Gaps (Addressed in v2.8.3):**
- 4 write functions still use direct `with open()`
- ctx not passed to `_create_archive_marker()` from caller
- `create_log_file()` commits immediately (breaks composability)
- ~40+ print statements remain unconverted

---

### 12.4 v2.8.3: Complete ontos_end_session.py to A+ (PR #27)

**Status:** IN PROGRESS
**Target Grade:** A+

#### 12.4.1 Gap Analysis

| Function | Lines | OutputHandler | buffer_write | Action |
|----------|-------|--------------|--------------|--------|
| `create_log_file()` | 1278-1373 | âœ… | âœ… | Fix commit timing |
| `_create_archive_marker()` | 1373-1395 | â€” | âœ… | Receive ctx from caller |
| `graduate_proposal()` | 123-200 | âœ… | âŒ | **Convert** |
| `append_to_log()` | 359-430 | âœ… | âŒ | **Convert** |
| `create_auto_log()` | 600-690 | âœ… | âŒ | **Convert** |
| `create_changelog()` | 922-960 | âœ… | âŒ | **Convert** |
| `add_to_decision_history()` | 230-280 | âŒ | âŒ | **Convert** |
| `update_changelog()` | 1000-1060 | âŒ | âŒ | **Convert** |

#### 12.4.2 Implementation Tasks

**Task A: Fix Transaction Composability [CRITICAL]**

Implement the `_owns_ctx` pattern so functions don't commit when ctx is passed from caller:

```python
def some_write_function(..., ctx: SessionContext = None) -> ReturnType:
    _owns_ctx = ctx is None
    if _owns_ctx:
        ctx = SessionContext.from_repo(Path.cwd())

    ctx.buffer_write(Path(filepath), content)

    if _owns_ctx:  # Only commit if WE created the context
        ctx.commit()

    return result
```

**Specific Changes:**

1. **Update create_log_file()** â€” Add `_owns_ctx` check, pass ctx to `_create_archive_marker()`
2. **Update main()** â€” Single commit at end after all buffered writes

**Task B: Convert Remaining Write Functions [HIGH]**

Each function needs:
- `ctx: SessionContext = None` parameter
- `_owns_ctx = ctx is None` pattern
- Replace `with open(..., 'w')` with `ctx.buffer_write()`
- Only commit if `_owns_ctx`

Functions to convert:
- `graduate_proposal()`
- `append_to_log()`
- `create_auto_log()`
- `create_changelog()`
- `add_to_decision_history()`
- `update_changelog()`

**Task C: Convert Remaining Print Statements [MEDIUM]**

~45 print statements remain across these functions:
- `check_stale_docs_warning()` (5)
- `prompt_graduation()` (4)
- `add_changelog_entry()` (3)
- `validate_concepts()` (3)
- `suggest_impacts()` (4)
- `auto_archive_session()` (6)
- `find_enhance_target()` (3)
- `prompt_changelog_entry()` (4)
- Scattered error paths (~13)

**Task D: Comprehensive Tests [HIGH]**

New tests needed:
- `test_create_log_file_does_not_commit_when_ctx_passed()`
- `test_main_commits_all_files_atomically()`
- `test_main_rollback_on_commit_failure()`
- `test_graduate_proposal_uses_buffer_write()`
- `test_append_to_log_uses_buffer_write()`
- `test_create_changelog_uses_buffer_write()`

#### 12.4.3 Success Criteria for A+

**Functional:**
- [ ] All 8 write functions use `ctx.buffer_write()`
- [ ] All write functions implement `_owns_ctx` pattern
- [ ] `create_log_file()` passes ctx to `_create_archive_marker()`
- [ ] `main()` commits once at end (single atomic transaction)
- [ ] All ~45 print statements converted to OutputHandler

**Tests:**
- [ ] Test: `create_log_file()` doesn't commit when ctx passed
- [ ] Test: `main()` commits all files atomically
- [ ] Test: Rollback on commit failure
- [ ] Test: Each converted function uses buffer_write
- [ ] All 243+ tests pass

**Quality:**
- [ ] No direct `with open(..., 'w')` remains (except reads)
- [ ] No raw `print()` statements remain (except interactive prompts)
- [ ] Consistent parameter order: `..., output=None, ctx=None`

#### 12.4.4 Estimated Effort

| Task | Description | Effort |
|------|-------------|--------|
| A | Fix transaction composability | 45 min |
| B | Convert 6 write functions | 1.5 hours |
| C | Convert ~45 print statements | 1 hour |
| D | Comprehensive tests | 1.5 hours |
| **Total** | | **~5 hours** |

#### 12.4.5 Standard Function Signature (Post v2.8.3)

All write functions should follow this pattern:

```python
def function_name(
    # Required positional args
    arg1: type,
    arg2: type,
    # Optional behavioral args
    quiet: bool = False,
    # v2.8 infrastructure (always last, always optional)
    output: OutputHandler = None,
    ctx: SessionContext = None
) -> ReturnType:
    """Docstring."""
    _owns_ctx = ctx is None
    if _owns_ctx:
        ctx = SessionContext.from_repo(Path.cwd())
    if output is None:
        output = OutputHandler(quiet=quiet)

    # ... function logic using ctx.buffer_write() ...

    if _owns_ctx:
        ctx.commit()

    return result
```

---

### 12.5 v2.8.4: Remaining Scripts (PR #28) âœ…

**Status:** Merged
**Grade:** A+

**Scripts Refactored:**
- `ontos_consolidate.py` (21 prints â†’ OutputHandler, 1 write â†’ buffer_write)
- `ontos_verify.py` (20 prints â†’ OutputHandler, 1 write â†’ buffer_write)
- `ontos_maintain.py` (25 prints â†’ OutputHandler, 2 writes â†’ buffer_write, **deduplication**)
- `ontos_query.py` (16 prints â†’ OutputHandler, read-only - no writes)

**Key Achievements:**
1. **Deduplication:** `graduate_proposal()` and `add_graduation_to_ledger()` were duplicated in `ontos_maintain.py`. Now imported from `ontos_end_session.py` (canonical source).
2. **`_owns_ctx` pattern:** All write functions implement transaction composability.
3. **OutputHandler:** All user-facing messages use OutputHandler methods.
4. **Tests:** New `tests/test_v284_refactor.py` with 5 tests:
   - `test_update_describes_verified_uses_buffer_write`
   - `test_update_describes_verified_owns_ctx_when_none_passed`
   - `test_graduate_proposal_is_imported_not_duplicated`
   - `test_add_graduation_to_ledger_not_in_maintain`
   - `test_append_to_decision_history_uses_buffer_write`

**Note:** `ontos_init.py` and `ontos_lint.py` do not exist (plan was outdated). The `init` command will be addressed in v2.8.5.

---

### 12.6 v2.8.5: Unified CLI (PR #29) ðŸ”²

**Status:** In Progress
**Target Grade:** A+

#### 12.6.1 Gap Analysis

**Files to Create:**
| File | Purpose |
|------|---------|
| `ontos.py` (project root) | Unified CLI dispatcher |

**CLI Command Mapping Issue:**
Section 3.2 references `ontos_init.py` for the `init` command, but this script **does not exist**.

**Decision Required:** Either:
- **Option A:** Remove `init` command from v2.8 CLI (defer to v3.0)
- **Option B:** Create minimal `ontos_init.py` stub that prints "Coming in v3.0"
- **Option C:** Create full `ontos_init.py` (scope creep risk)

**Recommendation:** Option A (remove from v2.8, cleaner)

#### 12.6.2 Implementation Tasks

**Task A: Create `ontos.py` Dispatcher [HIGH]**

Create the unified CLI dispatcher in project root per Section 3.3 design:

```python
#!/usr/bin/env python3
"""Ontos CLI - Unified command interface."""

COMMANDS = {
    'log': ('ontos_end_session', 'Archive a session'),
    'map': ('ontos_generate_context_map', 'Generate context map'),
    'verify': ('ontos_verify', 'Verify describes dates'),
    'maintain': ('ontos_maintain', 'Run maintenance'),
    'consolidate': ('ontos_consolidate', 'Archive old logs'),
    'query': ('ontos_query', 'Search documents'),
    'update': ('ontos_update', 'Update Ontos'),
}
# Note: 'init' deferred to v3.0 (ontos_init.py doesn't exist)
```

**Task B: Implement Command Routing [MEDIUM]**

- Parse `sys.argv[1]` as command name
- Resolve aliases to primary commands
- Import and execute the target module's `main()`
- Handle `--help` and `--version` flags

**Task C: Add Alias Support [LOW]**

```python
ALIASES = {
    'archive': 'log', 'session': 'log',
    'context': 'map', 'generate': 'map',
    'check': 'verify',
    'maintenance': 'maintain',
    'archive-old': 'consolidate',
    'search': 'query', 'find': 'query',
    'upgrade': 'update',
}
```

**Task D: CLI Dispatcher Tests [HIGH]**

New test file: `tests/test_cli.py`

Required tests:
- `test_help_flag()` â€” `python3 ontos.py --help` returns 0, shows usage
- `test_version_flag()` â€” `python3 ontos.py --version` shows version
- `test_unknown_command()` â€” Unknown command returns 1 with error
- `test_alias_resolution()` â€” `archive` â†’ `log`, etc.
- `test_each_command_has_help()` â€” Each command responds to `--help`
- `test_command_passthrough()` â€” Arguments passed to subcommand correctly

**Task E: Update Documentation [MEDIUM]**

Files to update:
- `docs/reference/Ontos_Manual.md` â€” Add unified CLI syntax examples
- `docs/reference/Ontos_Agent_Instructions.md` â€” Update command reference
- `Ontos_CHANGELOG.md` â€” Add v2.8 section with all changes

**Task F: Update Section 3 CLI Mapping [LOW]**

Remove `init` from command mapping or add footnote that it's deferred:

```python
# Section 3.2 - remove or mark as deferred:
# | `ontos.py init` | `ontos_init.py` | `setup` |  # DEFERRED to v3.0
```

#### 12.6.3 Success Criteria for A+

**Functional:**
- [ ] `ontos.py` exists in project root and is executable
- [ ] All 7 commands work: `log`, `map`, `verify`, `maintain`, `consolidate`, `query`, `update`
- [ ] All aliases resolve correctly
- [ ] `--help` shows usage for main CLI and each command
- [ ] `--version` shows current version
- [ ] Unknown commands show error with available commands list
- [ ] Arguments pass through to subcommands correctly

**Tests:**
- [ ] `tests/test_cli.py` with 6+ tests
- [ ] All tests pass including new CLI tests
- [ ] Test coverage for alias resolution
- [ ] Test coverage for error handling

**Documentation:**
- [ ] Manual updated with new CLI syntax
- [ ] Agent Instructions updated
- [ ] CHANGELOG includes v2.8 summary

**Quality:**
- [ ] No hardcoded paths (uses `Path(__file__).parent`)
- [ ] Error messages are user-friendly
- [ ] Consistent with existing CLI patterns

#### 12.6.4 Estimated Effort

| Task | Description | Effort |
|------|-------------|--------|
| A | Create ontos.py dispatcher | 30 min |
| B | Command routing logic | 30 min |
| C | Alias support | 15 min |
| D | CLI tests | 1 hour |
| E | Documentation updates | 45 min |
| F | Section 3 cleanup | 15 min |
| **Total** | | **~3.5 hours** |

---

*End of v2.8 Implementation Plan v2.1.0*

*APPROVED by LLM Review Board (Claude, Codex, Gemini) on 2025-12-20.*
*Implementation in progress.*
