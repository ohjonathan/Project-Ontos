---
id: v3_2_4_prea_adversarial_review
type: review
status: active
depends_on: [v3_2_4_proposal_library_maintenance, v3_2_4_discovery_design_report]
concepts: [adversarial-review, v3.2.4, rename, link-check, risk-assessment]
---

# v3.2.4 Pre-Phase A: Adversarial Review

> **Reviewer:** Claude Code (Adversarial)
> **Proposal under review:** `v3.2.4_Proposal_Library_Maintenance.md`
> **Date:** 2026-02-10

---

## Assumption Attack

| Assumption | Why It Might Be Wrong | Impact If Wrong |
|------------|----------------------|-----------------|
| Body-link zone detection (code fences, inline code) is sufficient for safe bare-ID replacement | Real IDs contain regex metacharacters (dots in `v3.0.4_Code_Review_Claude`), and `\b` word boundaries interact unpredictably with dots/hyphens. `\bv3\b` matches inside `v3.0.4_Code_Review_Claude` because `.` is a non-word character creating a boundary after `v3`. The proposal says "word-boundary-safe" but doesn't define what word boundary means for IDs containing `.`, `-`, and `_`. | False-positive rewrites corrupt unrelated references in body text. A rename of a short ID silently damages documents mentioning longer IDs that share the prefix separated by dots/hyphens. |
| `SessionContext` + clean git is adequate failure protection | Clean git is checked before `--apply`, but `SessionContext.commit()` Phase 2 has no rollback for already-renamed files (context.py:174-196). If rename 31 of 50 fails, files 1-30 have new content, 31-50 have old content. The user must `git checkout .` manually. The proposal says "full revert is always available via git" — true, but only if the user knows it failed. The current `commit()` return value (list of modified paths) is **never checked by any existing command** (scaffold, promote, migrate all ignore it). | User believes rename succeeded (command exits without clear error), doesn't revert, and the library is left in a partially-renamed state that neither `link-check` nor `ontos map` can diagnose as "half-renamed." |
| `--scope library` default is correct | The `library` scope (`docs/ + .ontos-internal/ + scan_paths`) doesn't exist in the codebase. Current `scan_documents` implementations (maintain.py:232-243, map.py:709-714) use `docs_dir + scan_paths` only. The proposal recommends this scope but it must be built from scratch, and its behavior must be consistent with how `map` and `maintain` scan — otherwise `link-check` will report different results than `ontos map` validation. | User runs `link-check --scope library`, sees 48 broken links. Runs `ontos map`, sees 38 errors. Different numbers for the same library. User loses trust in both tools. |
| Frontmatter comment destruction is acceptable | The proposal accepts comment stripping as a "known constraint" with mitigation via clean-git diffs. But `serialize_frontmatter()` doesn't do surgical field updates — it rewrites the ENTIRE frontmatter block. If `old_id` appears in 50 files' `depends_on`, all 50 get full frontmatter rewrites: field reordering, comment stripping, list format normalization (schema.py:295-387). The diff for a single ID rename becomes 50 files of noisy formatting changes obscuring the actual `depends_on` change. | Code review of rename diffs becomes impractical. The signal (one ID changed in `depends_on`) is buried in noise (field reordering, comment loss, list reformatting). Users skip review, defeating the purpose of clean-git safety. |
| Bare-ID token matching with word boundaries won't produce false positives | Real library data proves otherwise. IDs like `v3_2_1` are prefixes of `v3_2_1_activation_resilience_proposal` — `\b` correctly excludes this because `_` is a word character. But IDs with dots (`v3.0.4`) create unexpected boundaries: `v3` matches inside `v3.0.4` because `.` is a non-word char. More critically: 14 broken `depends_on` references use mixed dot/underscore conventions for the same logical ID (`v3.0.3_Implementation_Spec` vs `v3_0_3_implementation_spec`). These near-miss patterns are exactly where false positives live. | Rename corrupts body text by replacing partial ID matches. Or rename misses references written in an alternate convention (dots vs underscores), leaving the library in a state where the "same" ID exists in two conventions and neither is correct. |

---

## Failure Mode Analysis

| Failure | How It Happens | Would We Notice? | Severity |
|---------|----------------|-------------------|----------|
| `link-check` reports different results than `maintain` task 7 | `link-check` validates `depends_on` + `impacts` + `describes` + orphans with `--scope library`. Task 7 validates `depends_on` only via `build_graph()` with `docs + scan_paths` scope (maintain.py:549-578). Different field coverage AND different scan scope = different numbers. | Yes, but confusingly. User sees "48 broken links" from `link-check` and "38 broken links" from `maintain`. Both are "correct" for their scope/field coverage. The proposal says "make maintain task 7 call the same internal diagnostic" (proposal line 101) but doesn't mandate scope alignment. | **High** — erodes trust in tooling |
| `rename` applied to an ID that appears as a substring of other IDs (separated by non-word chars) | User renames `v3_2` to `v4_0`. Body text contains "see v3_2.1 release notes" (using dots, a real pattern in this library). `\bv3_2\b` matches because `.` creates a word boundary after `v3_2`. The `1` after the dot is a separate token. Result: text becomes "see v4_0.1 release notes". | **No.** The dry-run would show this file as "1 body ref changed" but the user would have to manually inspect every match to catch it. With 50 files changing, this is impractical. | **Critical** — silent data corruption |
| `rename` on a file with malformed frontmatter | Two parsing paths disagree: `core.frontmatter.parse_frontmatter()` returns `None` silently on malformed YAML (frontmatter.py:69-76). `io.yaml.parse_frontmatter_content()` raises `ValueError` (yaml.py:102-104). If rename uses the core parser and encounters malformed frontmatter, it silently skips the file. If it uses the IO parser, it aborts. The proposal doesn't specify which parser. Content Report says "Malformed Frontmatter: 0" — but that's current state. A user could create a malformed file between now and running rename. | Depends on parser choice. Silent skip = no notice. ValueError = noticed but unhelpful ("parse error on file X" with no guidance). | **Medium** — spec gap, not data loss |
| `rename --apply` succeeds but `link-check` still shows broken references | `rename` updates frontmatter fields (`depends_on`, `impacts`, `describes`) and body references. But `link-check` may use a different scan scope, finding files that rename didn't scan. More fundamentally: `link-check` validates structured frontmatter references. It does NOT validate body-text references (no body-link parser in `link-check`). So rename touches body refs, but link-check can't verify they were updated correctly. | **Yes**, but misleading. `link-check` shows "clean" because frontmatter refs are updated, while body refs may be partially corrupted. False sense of security. | **High** — validation gap |
| Body-link parser misidentifies a code fence boundary | Ontos_Manual.md has 24 `---` markers. Nested code fences require a state machine, not simple toggle. The proposal says "parse document into zones" but doesn't specify the algorithm. Python's standard library has no markdown AST parser. Rolling a custom zone parser for nested fences is error-prone. | Only if the renamed ID happens to appear in a code example. In this library: the Manual contains YAML examples with `depends_on: [parent_id]` — if `parent_id` is a real ID being renamed, the code example gets corrupted. | **High** — corrupts documentation examples |
| User runs `rename` twice (idempotency) | User runs `rename old_id new_id --apply`. Succeeds. Runs same command again. Pre-validation step 1: "Verify `old_id` exists exactly once" — `old_id` no longer exists. Command fails with "`old_id` not found." This is correct behavior but the proposal doesn't specify it. | Yes, clear error. | **Low** — correct by accident |
| `rename` on an ID that appears in the `concepts` field | Real example: `concepts: [v3.2.4, library-maintenance, graph-integrity]` (proposal's own frontmatter). `concepts` is excluded from rename scope. If a document ID matches a concept value, the concept won't be updated. Since `validate_concepts()` exists in suggestions.py:127-149 but is **never called** by ValidationOrchestrator (validation.py:72-86), `link-check` won't catch the stale concept either. | **No.** Neither `rename` nor `link-check` touches or validates `concepts`. | **Medium** — but concepts are tags, not references. Acceptable IF documented. Currently undocumented. |

---

## Edge Case Inventory

| Edge Case | Real Evidence | Breaks What? |
|-----------|--------------|--------------|
| IDs containing dots (`v3.0.4`) | `v3.0.4_Code_Review_Claude` in `.ontos-internal/archive/` | Regex metachar: unescaped `.` matches any char. Word boundaries split at dots creating false prefix matches. |
| IDs that are prefixes of other IDs | `v3_2_1` is prefix of 10+ IDs (`v3_2_1_activation_resilience_proposal`, `v3_2_1_code_review_codex`, etc.) | Word-boundary `\b` handles `_` correctly (word char), but body text using dots or hyphens as separators creates false matches. |
| Documents with nested code fences | Ontos_Manual.md: 24 `---` markers, YAML code blocks inside markdown code fences | Zone parser must handle nested fences. Simple toggle state machine fails on nested fence patterns. |
| 230 files without frontmatter | All 11 release files (`docs/releases/v3.*.md`), plus 219 others per Content Report | `rename` can't update `id`/`depends_on` fields that don't exist. Body text in these files may contain the renamed ID (release notes reference version IDs). Rename would either skip these silently or attempt body-only rewrite. |
| Template file with YAML comments | `docs/_template.md` has inline comments: `id: _template  # Underscore prefix marks this as internal` | Excluded by skip_patterns in `.ontos.toml`. But: if a user copies the template and keeps comments, rename will strip them on touch. |
| Circular renames (A to B then B to A) | No prevention mechanism specified | Second rename is valid (B exists, A doesn't). Result: all references flip twice, returning to original. Wasteful but not destructive. Low concern. |
| `old_id` in document's own body text | Log documents reference their own ID in body text. | Rename correctly updates this — desirable behavior. Not actually an edge case. |
| Files outside scan scope referencing renamed ID | `AGENTS.md` lists document IDs. `Ontos_Context_Map.md` renders document IDs. `CLAUDE.md` may reference doc paths. | These are auto-generated files. Proposal doesn't specify post-rename regeneration steps (`ontos map`, `ontos agents`). User must know to regenerate. |
| `depends_on` containing same ID twice | No deduplication in `build_graph()` (graph.py:57-66 iterates the list as-is) | Rename would update both occurrences (correct). But the duplication itself is a data quality issue that neither command addresses. |
| Mixed conventions for same logical ID | 14 broken refs use `v3.0.3_Implementation_Spec` (dots+CamelCase) vs `v3_0_3_implementation_spec` (underscores+lowercase) | `rename` operates on exact ID match. It won't find the alternate-convention references. These remain broken. `link-check` would report them, but the fix requires manual intervention, not rename. |

---

## Security & Integrity Surface

| Vector | Applicable? | Risk Level | Notes |
|--------|------------|------------|-------|
| Path traversal in ID names | No | Negligible | IDs are dict keys and list values, never used as file paths in rename. File paths come from `scan_documents()` which uses `rglob` within specified directories. |
| Shell injection via ID arguments | No | Negligible | CLI uses argparse; IDs are Python strings, never passed to `subprocess` or `os.system`. |
| Symlink following during scan | **Yes** | **Medium** | `scan_documents()` uses `Path.rglob("*.md")` which follows symlinks by default (files.py:60-90). A symlink in `docs/` pointing outside the repo would cause rename to modify files outside the project. Mitigated by clean-git check (symlinked files outside repo wouldn't show in git status), but the write would still happen. |
| Race condition between dry-run and apply | **Yes** | **Low** | Library could change between dry-run and `--apply` invocations. No lock held between runs. Mitigated by clean-git requirement: any intervening changes would dirty the working tree, and rename would refuse to run. Adequate mitigation. |

---

## Blind Spot Identification

### 1. `link-check` and `rename` have no shared reference model

This is the deepest architectural blind spot. The proposal designs two commands that operate on "references" but define them differently:

- **`link-check`** finds references via `build_graph()` (depends_on only, per graph.py:57-66) + `validate_impacts()` (impacts, per validation.py:155-169) + `validate_describes()` (describes, per validation.py:171-178). All frontmatter-only. No body text.
- **`rename`** rewrites references in frontmatter fields AND body text (via the new zone-aware parser).

These are **two different reference ontologies**. After a rename:
- `link-check` confirms: "all frontmatter references updated" (true)
- `link-check` cannot confirm: "all body references updated" (not in its scope)
- `link-check` cannot detect: "body references were incorrectly rewritten" (not in its scope)

The proposal says `link-check` should serve as a "pre/post validation gate" for rename. It can't. It validates a subset of what rename modifies.

### 2. Post-rename artifact regeneration

`rename` modifies source files. But derived artifacts contain rendered references:
- `Ontos_Context_Map.md` lists document IDs in tables and dependency trees
- `AGENTS.md` references document IDs
- Any cached `--json` output from previous `link-check` runs

The proposal doesn't specify that users must regenerate these artifacts after rename. A user who runs `rename --apply` and then reads the context map sees stale IDs.

### 3. Interaction with `ontos map` validation section

`ontos map` already generates a validation section with broken links and warnings. After rename, `ontos map` would regenerate this section using `build_graph()` — the same function `link-check` uses. But `ontos map` and `link-check` may use different scopes (map uses `docs_dir + scan_paths`, link-check defaults to `library`). The validation numbers will differ.

### 4. `describes` field semantics under rename

The `describes` field points to a single document ID. If that document is renamed, `describes` needs updating. But `describes` validation uses WARNING severity (validation.py:171-178), not ERROR. So a stale `describes` reference after a failed/partial rename would appear as a warning, not an error. Users who filter on errors only would miss it.

### 5. The `--scope` flag creates two truths

With `--scope docs` and `--scope library` producing different results, users must understand which scope is appropriate. But the proposal recommends `library` as default for both commands. If `ontos map` continues to use `docs + scan_paths` scope, there are now three scope definitions in the system:
- `map`/`maintain`: `docs_dir + scan_paths`
- `link-check`/`rename` with `--scope docs`: `docs_dir + scan_paths`
- `link-check`/`rename` with `--scope library`: `docs/ + .ontos-internal/ + scan_paths`

No command explicitly documents which scope it uses, so users can't predict which files are covered.

---

## Risk Assessment Override

### `ontos link-check`

**Proposal rating:** Low risk.
**My rating:** Low risk, **but with a trust hazard.**

The command itself is read-only and safe. The risk is in divergent results. If `link-check --scope library` reports 48 broken links but `ontos map` reports 38 errors (because map doesn't scan `.ontos-internal/`), users will question which tool is authoritative. The proposal's recommendation to "make maintain task 7 call the same internal diagnostic function" (proposal line 101) partially addresses this, but scope alignment between `link-check`, `map`, and `maintain` is not mandated.

**Missing mitigation:** The spec must mandate that `link-check --scope docs` produces results identical to `ontos map`'s validation section. If they ever disagree, users lose trust in both tools.

### `ontos rename`

**Proposal rating:** High risk with adequate mitigations.
**My rating:** High risk with **partially adequate** mitigations.

The mitigations (dry-run default, clean-git, in-memory planning, collision detection) address the **frontmatter rewrite** risk well. They do NOT adequately address the **body-link rewrite** risk, which is the novel and highest-risk component.

**Missing mitigations:**

1. **Exact matching semantics for bare IDs.** "Word-boundary-safe" is not a spec. The implementation needs: regex escaping of metacharacters in IDs, definition of what characters constitute ID boundaries (since IDs contain `_`, `-`, `.`), and explicit handling of IDs that are substrings of other IDs when separated by non-word characters.

2. **Dry-run output must show exact match context.** Current proposal: "per-file change summary (frontmatter_fields_changed, body_refs_changed)." This is insufficient. The dry-run must show the exact line and surrounding context for each body-text match, so users can verify no false positives before `--apply`.

3. **Post-rename validation.** The spec should require `rename --apply` to run `link-check` automatically after commit and report any remaining broken references. This catches references outside scan scope or in conventions rename didn't handle.

---

## Issues Found

### Critical (Blocks Spec Development)

**C1. Body-link bare-ID matching semantics are unspecified and will produce false positives on real library data.**

The proposal says "strict token matches (word-boundary-safe, no substring rewrites)" but doesn't define matching rules for IDs containing regex metacharacters (dots) or non-word separator characters (hyphens). Real library evidence:

- ID `v3.0.4_Code_Review_Claude` contains dots. Unescaped dot in regex matches any character.
- A rename of any ID that is a prefix of another ID separated by a dot or hyphen (e.g., renaming `v3_2` when body text contains `v3_2.1`) will produce false-positive matches because `\b` treats `.` as a word boundary.
- 14 broken references use mixed dot/underscore conventions for the same logical ID, proving that these patterns exist in practice.

**Unblock requirement:** The spec must define exact tokenization rules for bare-ID matching, including: (a) regex escaping of metacharacters in IDs, (b) whether `_`, `-`, `.` are treated as word-internal or word-boundary characters for matching purposes, and (c) explicit handling of the "ID is a prefix separated by non-word char" case with test vectors drawn from real library IDs.

**C2. `link-check` and `rename` operate on fundamentally different reference models, making post-rename validation incomplete.**

`link-check` validates frontmatter references only (depends_on, impacts, describes). `rename` modifies frontmatter references AND body-text references. After rename, `link-check` cannot verify that body-text references were correctly updated, nor detect body-text references that were incorrectly rewritten (false positives). The proposal positions `link-check` as a validation gate for rename, but it can only validate half of what rename touches.

**Unblock requirement:** Either (a) `link-check` must include body-reference detection (making it aware of the same reference model rename uses), or (b) `rename` must include its own post-apply validation pass that verifies body-text changes, or (c) the spec must explicitly disclaim body-text validation and document the gap for users.

**C3. Dry-run output granularity is insufficient for body-text change review.**

The proposal specifies dry-run output as "per-file change summary (frontmatter_fields_changed, body_refs_changed)" — aggregate counts per file. For frontmatter changes, this is adequate (the change is deterministic: old_id to new_id in a list). For body-text changes, counts are dangerous. A user seeing "3 body refs changed" in a 500-line manual cannot verify whether those 3 matches are correct without seeing exact line numbers and surrounding context. The clean-git mitigation (review via `git diff`) only works AFTER `--apply`, when the damage is done.

**Unblock requirement:** Dry-run output for body-text matches must include: line number, matched text with surrounding context (at minimum 1 line before/after), and the zone classification (normal text vs code fence boundary decision). This is non-negotiable for a high-risk write command.

### Major (Should Fix Before Spec)

**M1. Two frontmatter parsing paths produce different results on edge cases, and rename doesn't specify which parser to use.**

`core.frontmatter.parse_frontmatter()` returns `None` on malformed YAML (silent failure, frontmatter.py:69-76). `io.yaml.parse_frontmatter_content()` raises `ValueError` (loud failure, yaml.py:102-104). The fallback parser also handles colons differently: `partition(':')` splits on the first colon, truncating values containing colons (frontmatter.py:106). A file originally written by one parser path could corrupt when round-tripped through the other.

**Fix:** Spec must mandate which parsing path `rename` uses and define behavior on parse failure (skip file with warning? abort entire rename?).

**M2. Frontmatter serialization produces noisy diffs that defeat code review.**

`serialize_frontmatter()` rewrites the entire frontmatter block with enforced field order (schema.py:315-319), normalized list formatting (schema.py:358-366), and stripped comments. A rename touching `depends_on` in 50 files produces 50 files of formatting noise plus the actual semantic change. Reviewing these diffs to verify correctness is impractical.

**Fix:** Consider a targeted field-update strategy that modifies only the specific `depends_on`/`impacts`/`describes` line without round-tripping through the full serializer. Alternatively, accept the noise but document it prominently and count it as a risk factor.

**M3. Files outside scan scope that reference the renamed ID are silently ignored.**

`AGENTS.md`, `Ontos_Context_Map.md`, and potentially `CLAUDE.md` contain document IDs. These are auto-generated files outside the default scan scope. After rename, they contain stale references. The proposal doesn't specify post-rename regeneration steps.

**Fix:** `rename --apply` output should include a warning: "Run `ontos map` and `ontos agents` to regenerate derived artifacts." Or better: run regeneration automatically.

**M4. `--scope library` creates scope divergence with existing commands.**

After v3.2.4, the system has three scope definitions: map/maintain (`docs_dir + scan_paths`), link-check/rename with `--scope docs` (same), and link-check/rename with `--scope library` (`docs/ + .ontos-internal/ + scan_paths`). `link-check --scope library` will report broken links in `.ontos-internal/` that `ontos map` doesn't show. Users will see conflicting numbers from different commands with no explanation.

**Fix:** Either (a) align `map`'s scan scope with `--scope library` (breaking change), or (b) `link-check` must clearly label which scope produced its results, or (c) make `link-check --scope docs` the default to match existing command behavior, with `--scope library` as an explicit opt-in.

### Minor (Consider)

**m1. 40% orphan rate means exit code 1 is always triggered.**

The proposal recommends orphans trigger exit code 1. With 237 orphans (40% of library), `link-check` will never return 0. CI gates that check exit code will always fail. Consider separate exit codes: 1 for broken references (actionable), 2 for orphans-only (informational).

**m2. `validate_concepts()` exists but is never called.**

`suggestions.py:127-149` has a `validate_concepts()` function. `ValidationOrchestrator.validate_all()` (validation.py:72-86) doesn't invoke it. This is an orphaned validation function. If `link-check` expands to validate concepts in the future, this function exists but may have bitrotted.

**m3. Symlink following in `scan_documents()`.**

`Path.rglob("*.md")` follows symlinks. A symlink in `docs/` pointing outside the repo would cause rename to modify external files. Clean-git check partially mitigates (external files aren't tracked), but the write still occurs. Consider adding `follow_symlinks=False` or documenting the behavior.

---

## Questions That Challenge the Architect's Decisions

1. **The body-link parser is the highest-risk new component, but the proposal describes it in 4 bullet points (proposal lines 139-143). Given that this parser must handle 5 linking patterns (Design Report), nested code fences (Ontos_Manual.md has 24 `---` markers), and IDs with regex metacharacters (real library data), why is the spec for this component less detailed than the spec for collision detection, which is a solved problem?**

2. **The proposal says `link-check` should serve as a pre/post validation gate for rename. But `link-check` only validates frontmatter references, while rename also modifies body-text references. How will a user verify that body-text renames were correct? Are you relying on the user to manually review `git diff` output across potentially 50+ files, including formatting noise from the serializer?**

3. **The feasibility report recommended deferring `rename` until "reference indexing/rewrite engine + dry-run/report + collision policy are designed." The design report estimated 200-300 lines of new code. But the body-link parser alone — handling zone detection, nested fences, inline code spans, regex escaping, word-boundary semantics, and markdown link target resolution — is a 200+ line component by itself. Is the total implementation effort underestimated, and does that change the risk calculus?**

---

## Verdict

**Request Changes**

### Unblock requirements:

1. **Define exact bare-ID matching semantics** with test vectors drawn from real library IDs (including IDs with dots, IDs that are prefixes of other IDs, and the mixed dot/underscore convention patterns found in 14 broken references). The spec must answer: given ID `v3_2` and body text `v3_2.1`, does the body-link parser match? Why or why not?

2. **Resolve the `link-check` / `rename` reference model gap.** Either expand `link-check` to detect body references, add post-apply verification to `rename`, or explicitly document the gap with user-facing warnings.

3. **Specify dry-run output for body-text matches at line-level granularity** (not file-level counts). This is the user's only opportunity to catch false positives before `--apply`.

These three items are the minimum changes needed before the spec phase can begin. The proposal's treatment of frontmatter rename is sound. The treatment of body-text rename is underspecified to the point where implementation would require design decisions that should be made at the proposal level, not the code level.
