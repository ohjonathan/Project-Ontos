---
id: v3_2_4_prea_alignment_review
type: review
status: active
depends_on: [v3_2_4_proposal_library_maintenance, v3_2_4_discovery_design_report, v3_2_4_discovery_feasibility_report]
concepts: [alignment-review, v3.2.4, architecture-compliance, backward-compatibility]
---

# v3.2.4 Pre-Approval Alignment Review

> **Reviewer:** Antigravity, powered by Gemini 2.5 Pro
> **Review Date:** 2026-02-11
> **Proposal Under Review:** [v3.2.4_Proposal_Library_Maintenance.md](file:///Users/jonathanoh/Dev/Ontos-dev/.ontos-internal/strategy/proposals/v3.2.4/v3.2.4_Proposal_Library_Maintenance.md)
> **Baseline Documents:** Feasibility Report, Design Report, Content Report

---

## Review Verdict: ✅ APPROVE WITH OBSERVATIONS

The proposal is **architecturally sound** and demonstrates strong alignment with existing codebase patterns, discovery evidence, and prior decisions. No blocking deviations were found. The observations below document areas where the proposal introduces **new patterns** that need explicit tracking, and where minor specification gaps should be addressed during implementation.

---

## 1. Architecture Compliance

### 1.1 CLI Registration Pattern — ✅ Aligned

The proposal specifies two new commands (`link-check`, `rename`) as standalone CLI entries. This follows the established pattern:

```
create_parser() → _register_* → _cmd_* handler → *Options dataclass → *_command()
```

**Evidence:** All 21 existing commands follow this exact pattern (`cli.py:31-89`, `cli.py:523-950`). The proposal's command surface design is consistent.

**No deviation.**

### 1.2 Command Taxonomy Placement — ✅ Aligned

| Command | Proposed Group | Assessment |
|---------|---------------|------------|
| `link-check` | Diagnose | Correct. Joins `doctor` and `query` as read-only inspectors. |
| `rename` | Maintain | Correct. Joins `maintain`, `consolidate`, `promote` as library upkeep tools. |

The Design Report raised a concern about `link-check` fragmenting the mental model with `doctor` and `maintain` task 7. The proposal addresses this explicitly (§2, "Relationship to `maintain` task 7 and `doctor`") by defining clear role separation and recommending that `maintain` task 7 call the same internal diagnostic function. **This is the correct mitigation.**

### 1.3 JSON Output Convention — ✅ Aligned

The proposal specifies `--json` for both commands. The codebase uses `emit_json()` / `JsonOutputHandler` from `ontos.ui.json_output` with a `{"status": ..., "data": ...}` envelope pattern. The proposal's JSON output shapes (`summary`, `broken_links`, `orphans` for link-check; change plan for rename) are compatible with this envelope.

**Observation O1:** The proposal defines a specific JSON shape for `link-check` (§2) but does not specify the JSON shape for `rename` dry-run output beyond "full change plan." The implementation should follow the `JsonOutputHandler.result()` pattern with a `data` wrapper.

### 1.4 SessionContext / Two-Phase Commit — ✅ Aligned

The proposal correctly identifies `SessionContext` for `rename`'s write operations and explicitly acknowledges the Phase 2 partial-commit limitation (§3, "Known limitation"). 

**Verified against source:** `SessionContext.commit()` (`context.py:132-202`) confirms that if Phase 2 fails at file N, files 1 through N-1 are already committed. The proposal's mitigation (clean-git requirement + fail-fast pre-validation) is the same strategy recommended by the Design Report (§2.4) and is architecturally sound.

### 1.5 Dry-Run / `--apply` Precedent — ✅ Aligned

The proposal specifies dry-run-by-default with `--apply` for `rename`, directly following the `scaffold` precedent.

**Verified:** `ScaffoldOptions` (`scaffold.py:24-31`) defaults `apply=False, dry_run=True`. The proposal mirrors this exactly.

---

## 2. Constraint Verification

### 2.1 Two Parsing Paths — ✅ Addressed

The proposal acknowledges the dual-parser constraint (§6: "Two parsing paths exist; command behavior must be consistent across both"). The existing `_load_docs_for_graph` in `maintain.py:245-259` already uses `parse_frontmatter_content` from the IO layer with `read_file_lenient` from obsidian. Both new commands should follow this same pattern.

**No deviation.** The proposal correctly flags this as a constraint without proposing to change parser internals.

### 2.2 Duplicate ID Silent Overwrite — ✅ Addressed

The proposal explicitly calls out that current loaders silently overwrite duplicate IDs (§6: "Duplicate IDs currently can be overwritten silently in some loaders") and requires both `rename` and `link-check` to "detect and fail explicitly."

**Verified:** `maintain.py:255` (`docs[doc.id] = doc`) confirms silent overwrite. The proposal's requirement for explicit detection is a **net improvement** over current behavior, not a violation.

### 2.3 No External HTTP Dependencies — ✅ Aligned

The proposal explicitly excludes external URL checking (§1: "Out-of-scope"). This preserves the current zero-HTTP-dependency posture confirmed in `pyproject.toml`.

### 2.4 Frontmatter Comment Destruction — ✅ Addressed

The proposal acknowledges this constraint (§4: "Frontmatter comment destruction risk") and accepts it as a known limitation with mitigations:
- Only rewrite files with real reference changes
- Clean-git requirement for safe recovery
- Explicit warning in command output

**Verified:** `serialize_frontmatter()` in `schema.py:295-333` uses a hardcoded `field_order` and strips comments. This behavior is pre-existing and affects all write commands (`scaffold`, `promote`, `stub`, `migrate`). The proposal does not worsen this.

---

## 3. Backward Compatibility

### 3.1 Explicit Commitments — ✅ All Upheld

| Commitment (§6) | Status |
|-----------------|--------|
| No automatic source conversion to Obsidian wikilinks | ✅ Respected |
| No standalone mass standardization rewrite | ✅ Respected |
| No schema expansion for `summary` field | ✅ Respected |
| No file/directory move semantics in `rename` | ✅ Respected |
| `link-check` remains read-only | ✅ Respected |

These commitments are **directly aligned** with all three discovery reports' recommendations.

### 3.2 No Breaking Changes to Existing Commands — ✅ Verified

The proposal does not modify any existing command's interface, output format, or exit code behavior. Both `link-check` and `rename` are additive.

---

## 4. Consistency with Prior Decisions

### 4.1 v3.1 Obsidian Deferral — ✅ Respected

v3.1 explicitly deferred source-side Obsidian retrofit. The proposal maintains this deferral: wikilink conversion and source migration are explicitly out of scope (§1).

### 4.2 Discovery Report Recommendations — ✅ Followed

| Discovery Recommendation | Proposal Response |
|--------------------------|-------------------|
| Ship `link-check` as P0 (all three reports) | ✅ Included |
| Ship `rename` as genuine new capability (Design + Content) | ✅ Included |
| Defer `retrofit --obsidian` (all three reports) | ✅ Explicitly deferred |
| Defer `retrofit --lint-fix` / summary fill (Design + Content) | ✅ Explicitly deferred |
| Require clean-git for destructive ops (Design §1.3) | ✅ Adopted |
| Default dry-run for write ops (Design §1.3) | ✅ Adopted |
| Unify scan scope (Feasibility §3.4) | ✅ Adopted via `--scope` flag |

### 4.3 Backlog Alignment — ✅ No Conflicts

The proposal does not pre-empt planned backlog items (`doctor --repair`, file moves in v3.3). The `link-check` / `maintain` task 7 relationship is explicitly managed to avoid fragmentation.

---

## 5. Observations (Non-Blocking)

### O1. `--scope` is a New Pattern

No existing CLI command has a `--scope` flag. The proposal introduces `--scope docs|library` for both commands. This is **architecturally reasonable** given the inconsistent scan behaviors documented in the feasibility report, but it is a new UX pattern that establishes precedent.

> [!NOTE]
> Consider whether future commands (`query`, etc.) should retroactively adopt `--scope` for consistency, or whether this remains specific to maintenance commands. This is a **design decision to track**, not a blocker.

### O2. `rename` JSON Output Shape Underspecified

The proposal specifies detailed JSON output for `link-check` (§2) but only says rename should emit "a full change plan" with `--json` (§3). During implementation, define the explicit JSON shape (e.g., `{files: [{path, changes: [{field, old, new}]}], summary: {total_files, ...}}`).

### O3. Exit Code Semantics for `rename`

The proposal defines exit codes for `link-check` (§2: 0 = clean, 1 = issues found) but does not specify exit codes for `rename`. Suggested semantics:
- `0`: rename applied or dry-run valid
- `1`: pre-validation failure or execution error

### O4. `describes` Validation Gap in Suggestions

The proposal specifies that `link-check` should include `describes` broken references with confidence-scored fix suggestions (§2). However, `validate_describes()` (`validation.py:171-178`) does not currently call the suggestion engine — it only emits bare warnings without candidates. The `link-check` implementation will need to add suggestion generation for `describes` references, which is a small extension of the existing `suggest_candidates_for_broken_ref` pattern.

### O5. Open Question Recommendations Are Sound

All four open questions (§5) have reasonable recommendations:
- **Q1 (orphans trigger exit 1):** Consistent with CI gate semantics
- **Q2 (include all three fields):** Supported by content report evidence  
- **Q3 (rewrite only semantic ID refs):** Correctly conservative
- **Q4 (shared library scanner):** Addresses a real systemic risk

---

## 6. Summary Matrix

| Review Dimension | Verdict | Notes |
|-----------------|---------|-------|
| Architecture Compliance | ✅ Pass | All patterns matched |
| Constraint Verification | ✅ Pass | All constraints respected |
| Backward Compatibility | ✅ Pass | No breaking changes |
| Prior Decision Consistency | ✅ Pass | Discovery recommendations followed |
| Specification Completeness | ⚠️ Minor gaps | O2 (rename JSON shape), O3 (rename exit codes) |
| New Pattern Introduction | ⚠️ Track | O1 (`--scope` flag precedent) |

---

**Recommendation:** Approve the proposal. Address observations O2 and O3 during implementation specification, and track O1 as a design precedent decision for future commands.
