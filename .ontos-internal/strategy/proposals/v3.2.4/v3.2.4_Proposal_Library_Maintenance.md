---
id: v3_2_4_proposal_library_maintenance
type: strategy
status: draft
depends_on: [v3_2_2_interop_discussion, v3_2_4_discovery_design_report]
concepts: [v3.2.4, library-maintenance, graph-integrity, link-check, rename]
---

# v3.2.4 Proposal: Library Maintenance Commands

## 1. Overview

v3.2.4 delivers two focused maintenance commands:

1. `ontos link-check` (read-only graph diagnostics)
2. `ontos rename <old_id> <new_id>` (atomic ID rename with global reference updates)

This scope is driven by discovery evidence, not greenfield feature ideation:

- The library currently has high integrity drift: **48 broken `depends_on` links (16%)**, **13 broken `impacts` links (11%)**, and **237 orphans (40%)** (Content report).
- `link-check` already exists in near-complete form inside `maintain` task 7 and can be promoted to first-class CLI with low risk (Feasibility + Design reports).
- `rename` is the only truly missing operational capability and directly addresses the observed "renamed doc, stale references" failure pattern (all three reports).

Out-of-scope items stay deferred for v3.2.4: Obsidian source migration, standalone standardization rewrites, lint-fix summary/concept automation, file moves, external URL checking, and `doctor --repair`.

Approach:

- Reuse existing graph, validation, suggestion, and transaction infrastructure wherever possible.
- Add only two new command surfaces and one new markdown-aware body reference parser.
- Keep destructive behavior opt-in (`--apply`), with clean-git and pre-validation gates.

## 2. `ontos link-check` Design

### Command interface

```bash
ontos link-check [--json] [--scope docs|library]
```

- `--json`: machine-readable output.
- `--scope`: controls scan domain.
  - `docs`: current `maintain`-like scope (`docs_dir + scan_paths`).
  - `library` (recommended default): `docs/ + .ontos-internal/ + scan_paths`.

### What is reused

- Document scanning/loading pipeline: `scan_documents`-based walkers (Feasibility report).
- Graph integrity checks:
  - `build_graph()` for broken `depends_on`
  - `detect_orphans()`
  - existing cycle/depth support remains available (Feasibility + Design reports).
- Cross-reference validation for `impacts` and `describes` from validation layer (Feasibility report).
- Suggestion engine with confidence scores from `suggestions.py` (Design report).
- Existing maintain task logic as extraction target (`check_links` in task 7) (Feasibility + Design reports).

### New code required

- New `link-check` command module + CLI registration.
- Shared diagnostic collector that unifies:
  - broken `depends_on`
  - broken `impacts`
  - broken `describes`
  - orphan IDs
  - confidence-scored fix suggestions
- Output renderers:
  - full human-readable report (no hard cap)
  - JSON serializer
- Exit-code mapping.

### Output format

Human-readable output sections:

1. Summary counts
2. Broken references by field (`depends_on`, `impacts`, `describes`)
3. Suggested replacements with confidence
4. Orphan list

JSON output shape:

- `summary` (counts)
- `broken_links` (array of `{source_id, field, missing_id, suggestions[]}`)
- `orphans` (array of IDs)
- `scope` and `scan_dirs`

### Exit code semantics

- `0`: no broken references and no orphans.
- `1`: at least one broken reference or orphan found.

This matches the requirement for meaningful machine semantics and makes CI integration straightforward.

### Relationship to `maintain` task 7 and `doctor`

To avoid mental-model fragmentation:

- `doctor`: quick environment and health snapshot.
- `maintain`: orchestrated maintenance workflow bundle.
- `link-check`: deep, focused graph diagnostic with complete output.

Implementation recommendation: make `maintain` task 7 call the same internal diagnostic function used by `link-check`, then render a concise summary in maintain mode. This keeps one source of truth.

## 3. `ontos rename` Design

### Command interface

```bash
ontos rename <old_id> <new_id> [--apply] [--json] [--scope docs|library]
```

- Dry-run by default.
- `--apply` executes writes (aligned with `scaffold` precedent from discovery reports).
- `--json` emits structured change plan/result.
- `--scope` uses same scope model as `link-check`; recommend `library` default for consistency.

### Rename scope (what gets updated)

Structured frontmatter fields:

- `id` (target document)
- `depends_on`
- `impacts`
- `describes`

Body references:

- Markdown links: `[text](target)` and reference-style equivalents where target resolves to the renamed ID.
- Bare ID references (token-level match of `old_id` outside code spans/fences).

Explicitly excluded:

- File and directory moves (deferred to v3.3).
- External URLs.

### Body-link parser design (highest-risk component)

v3.2.4 introduces a markdown-aware rewrite pass with conservative matching:

1. Parse document into zones: normal text, fenced code blocks, inline code spans.
2. Apply replacements only in normal-text zones.
3. For markdown link targets, rewrite only when target is an internal reference that resolves to `old_id`.
4. For bare IDs, replace only strict token matches (word-boundary-safe, no substring rewrites).

This design directly addresses known corruption scenarios in discovery:

- code fences containing YAML examples,
- inline code snippets,
- multi-`---` manuals/templates,
- documents with frontmatter comments.

### Atomicity model and failure handling

Pre-validation (no writes):

1. Verify `old_id` exists exactly once.
2. Reject if `new_id` already exists (collision).
3. Detect duplicate IDs in scanned corpus and abort (avoid silent overwrite behavior called out in feasibility).
4. Require clean git working tree.
5. Build full rewrite plan in memory (all target files, all replacements).

Execution (`--apply`):

- Use `SessionContext` buffered writes and commit flow.
- Commit only after pre-validation and rewrite planning fully succeed.

Known limitation from discovery: `SessionContext` does not guarantee rollback after partial Phase 2 rename failures. Mitigation in v3.2.4 is strict fail-fast pre-validation + clean git requirement so full revert is always available via git.

### Collision detection and error handling

Hard failures (non-apply and apply):

- `old_id` not found
- `old_id` ambiguous (duplicate IDs)
- `new_id` already exists
- parse/resolve error on any to-be-modified file
- dirty git tree

On failure, command prints actionable diagnostics and exits non-zero without partial planned changes being reported as applied.

### Dry-run behavior and output

Default dry-run prints:

- whether rename is valid
- list of files that would change
- per-file change summary (`frontmatter_fields_changed`, `body_refs_changed`)
- aggregate counts

With `--json`, emit a full change plan (machine-consumable file list + counts + blockers).

### Scan scope decision

Use explicit library scope support because current command scans are inconsistent (`map`, `maintain`, `query`, `snapshot` differ, per feasibility report).

Recommendation for v3.2.4 defaults:

- `link-check`: default `library`
- `rename`: default `library`

Rationale: content report findings (broken links/orphans) are measured across `.ontos-internal/` and `docs/`; defaulting to narrower scope under-reports and under-fixes real issues.

## 4. Risk Assessment

### `ontos link-check`

Primary risks:

- Scope mismatch (user expects whole-library, command scans subset).
- Confusing severity treatment across `depends_on` vs `impacts/describes`.

Blast radius:

- Low (read-only).

Mitigations:

- explicit `--scope`
- explicit per-field reporting
- stable exit codes
- shared diagnostic core reused by maintain task 7

### `ontos rename`

Primary risks:

- False positive/negative body replacements (parser quality).
- Partial commit if filesystem failure occurs during Phase 2 of `SessionContext`.
- ID collision/duplication causing incorrect target resolution.

Blast radius:

- High (cross-library writes).

Mitigations:

- dry-run default + `--apply`
- clean-git precondition
- full in-memory planning before write
- strict collision/duplicate detection
- post-apply report of every modified file

### Frontmatter comment destruction risk

Discovery confirms existing serialization strips YAML comments and normalizes order. This is not new in v3.2.4, but rename can trigger it on touched files.

v3.2.4 position:

- Accept as known constraint for this release, with explicit warning in command output/docs.
- Minimize exposure by rewriting only files with real reference changes.
- Preserve safe recovery via clean-git requirement and reviewable diffs.

Deferred improvement (not in this proposal): comment-preserving frontmatter editing strategy.

## 5. Open Questions

### Q1. Should orphan-only findings trigger exit code `1`?

Recommendation: **Yes**.

Why: orphan prevalence is severe (40% in content report), and CI users need one integrity gate signal for both broken references and graph disconnection.

### Q2. Should `link-check` include `impacts` and `describes` by default or only `depends_on`?

Recommendation: **Include all three by default, with field-specific reporting**.

Why: broken `impacts` are already non-trivial (13 broken edges) and are part of documented cross-reference fields in discovery.

### Q3. Should rename rewrite markdown path targets when file paths do not change?

Recommendation: **Rewrite only targets semantically resolving to `old_id`; do not perform path migration behavior**.

Why: file moves are explicitly deferred, and over-aggressive path rewriting is a corruption risk.

### Q4. Should v3.2.4 introduce one shared "library scanner" utility?

Recommendation: **Yes, minimally**.

Why: feasibility identified inconsistent scan behavior as a systemic risk; both new commands should share one scan contract to avoid divergent results.

## 6. Dependencies & Constraints

### Existing infrastructure this proposal builds on

- CLI registration + options dataclass command pattern.
- Graph and validation layers (`build_graph`, orphan detection, cross-reference validators).
- Suggestion engine with confidence scores.
- `SessionContext` two-phase write workflow.
- Dry-run/`--apply` UX precedent from `scaffold`.

### Architectural constraints

- Two parsing paths exist (core fallback + IO YAML); command behavior must be consistent across both.
- Duplicate IDs currently can be overwritten silently in some loaders; rename/link-check must detect and fail explicitly.
- `SessionContext` is transactional but not a full rollback system after partial Phase 2 failures.
- No external HTTP dependency model; URL checks remain out of scope.

### Backward compatibility commitments (must not change)

- No automatic source conversion to Obsidian wikilinks.
- No standalone mass standardization rewrite in this release.
- No schema expansion for non-existent `summary` field.
- No file/directory move semantics in `rename`.
- `link-check` remains read-only.

---

**Proposal outcome for review:** Approve v3.2.4 scope as two-command release (`link-check`, `rename`) with conservative write safety model and explicit deferral of retrofit variants.
