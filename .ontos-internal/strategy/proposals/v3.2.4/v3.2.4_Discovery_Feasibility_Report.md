# v3.2.4 Discovery: Feasibility & Architecture Report

## 1. Existing Infrastructure Map

### 1.1 CLI command structure (entry points, parsing, registration)

| Finding | Evidence |
|---|---|
| CLI entrypoint is `python -m ontos` -> `ontos.cli:main`. | `ontos/__main__.py` imports `main` and exits with it (`ontos/__main__.py:10-13`). |
| Subcommands are registered centrally in `create_parser()` via `_register_*` functions. | `create_parser()` builds subparsers and registers commands (`ontos/cli.py:31-89`), with registrations such as `_register_map`, `_register_maintain`, `_register_query` (`ontos/cli.py:64-80`). |
| Command handlers follow a stable pattern: build `*Options` dataclass, call `*_command`. | `_cmd_map` -> `MapOptions` -> `map_command` (`ontos/cli.py:549-565`), `_cmd_maintain` -> `MaintainOptions` -> `maintain_command` (`ontos/cli.py:614-627`), `_cmd_query` -> `QueryOptions` -> `query_command` (`ontos/cli.py:934-950`). |
| Dispatch is generic: parsed `args.func(args)` with common exception handling. | `main()` parses args and routes to `args.func` (`ontos/cli.py:1013-1057`). |
| Proposed commands are not currently first-class commands (`retrofit`, `rename`, `link-check`). | Current registered command set in parser/CLI tests does not include those names (`ontos/cli.py:64-80`, `tests/test_cli.py:67-70`, `tests/test_cli.py:146-148`). |

### 1.2 Frontmatter parsing/writing and field-order behavior

| Finding | Evidence |
|---|---|
| There are two parsing paths: `core.frontmatter.parse_frontmatter()` and IO YAML parser (`parse_frontmatter_content()`). | `parse_frontmatter()` in core (`ontos/core/frontmatter.py:23-76`); IO parser contract in `parse_frontmatter_content()` (`ontos/io/yaml.py:77-107`). |
| Fallback parser is intentionally shallow (line-by-line, inline lists only) and silently skips non-`key: value` lines. | `_fallback_yaml_parse()` skips lines without `:` (`ontos/core/frontmatter.py:98-104`), supports inline list only (`ontos/core/frontmatter.py:118-122`). |
| YAML parsing uses `yaml.safe_load` in IO layer. | `parse_yaml()` uses `yaml.safe_load` (`ontos/io/yaml.py:10`, `ontos/io/yaml.py:14-30`). |
| Validation checks required fields but not frontmatter key order. | `validate_frontmatter()` required-field checks only (`ontos/core/schema.py:255-292`). |
| Serialization enforces an explicit field order. | `serialize_frontmatter()` defines `field_order` and emits ordered keys first (`ontos/core/schema.py:295-333`, especially `ontos/core/schema.py:315-319`). |
| Existing write commands already rely on this serializer. | `scaffold` (`ontos/commands/scaffold.py:9`, `ontos/commands/scaffold.py:111-114`), `promote` (`ontos/commands/promote.py:8`, `ontos/commands/promote.py:136-139`), `stub` (`ontos/commands/stub.py:8`, `ontos/commands/stub.py:72-92`), `migrate` (`ontos/commands/migrate.py:7-11`, `ontos/commands/migrate.py:130-133`). |

### 1.3 Cross-reference resolution (`depends_on`, links), graph model vs ad-hoc

| Finding | Evidence |
|---|---|
| There is a core graph model (`DependencyGraph`) used for dependency integrity. | Model and edges/reverse edges in `DependencyGraph` (`ontos/core/graph.py:28-42`). |
| Core `build_graph()` resolves only `depends_on` references and emits broken-link errors for missing IDs. | `build_graph()` loops `doc.depends_on` and checks against `existing_ids` (`ontos/core/graph.py:57-66`), emits `BROKEN_LINK` errors (`ontos/core/graph.py:74-83`). |
| Validation orchestration uses that graph for broken links, cycles, orphans, depth. | `ValidationOrchestrator.validate_graph()` (`ontos/core/validation.py:88-133`). |
| Additional cross-reference checks exist for `impacts` and `describes`, but not markdown body links. | `validate_impacts()` (`ontos/core/validation.py:155-169`), `validate_describes()` (`ontos/core/validation.py:171-178`). |
| `query` has its own ad-hoc graph builder instead of reusing `ontos.core.graph`. | `query.build_graph()` uses local dict/defaultdict graph (`ontos/commands/query.py:58-69`). |
| Existing maintain “link check” only checks broken `depends_on` via `build_graph()`. | `_task_check_links()` calls `build_graph(docs)` and reports `broken_links` count (`ontos/commands/maintain.py:549-578`). |

### 1.4 What v3.1.0 Obsidian compatibility delivered vs assumptions

| Finding | Evidence |
|---|---|
| v3.1 spec explicitly deferred retrofit/body-link conversion to v3.2.x. | Out-of-scope includes “Retrofit 314 existing documents” and “Wikilinks in document body” (`.ontos-internal/strategy/v3.1/V3.1.0-Obsidian-Compatibility-Spec.md:45-53`). |
| Implemented runtime behavior is mostly map output formatting (`--obsidian` affects document link formatting). | CLI flag exists (`ontos/cli.py:121-123`); map document table uses `_format_doc_link(..., obsidian_mode)` (`ontos/commands/map.py:355-382`), formatter emits `[[...]]` (`ontos/commands/map.py:561-580`). |
| Dependency tree output is not wikilink-formatted. | `_generate_dependency_tree()` prints plain IDs (`ontos/commands/map.py:415-441`). |
| `tags`/`aliases` support exists as normalized load-time fields, not bulk retrofit writes. | `normalize_tags/normalize_aliases` (`ontos/core/frontmatter.py:242-302`), used during load (`ontos/io/files.py:139-165`). |
| Obsidian tests validate link formatting + lenient read, not bulk transformation. | `tests/commands/test_map_obsidian.py:3-55`. |
| `map --obsidian` help text mentions tags, but map generation code has no `tags`/`aliases` output path. | Help string says “wikilinks, tags” (`ontos/cli.py:121-123`), no tags/aliases handling in map table/tree generation (`ontos/commands/map.py:355-382`, `ontos/commands/map.py:415-441`, `ontos/commands/map.py:561-580`). |

### 1.5 Document enumeration (“walk the library”) utilities

| Finding | Evidence |
|---|---|
| Shared walker exists: `scan_documents(dirs, skip_patterns)`. | `ontos/io/files.py:60-90`. |
| `map` scans `docs_dir + scan_paths` from config (not root by default). | `scan_dirs = [docs_dir] + scan_paths` (`ontos/commands/map.py:709-714`). |
| `maintain` uses the same docs+scan_paths model. | `_scan_dirs()` and `_scan_docs()` (`ontos/commands/maintain.py:232-243`). |
| `query` scans from root by default (broader and different behavior). | `scan_documents([root], ...)` (`ontos/commands/query.py:31-37`), default `search_dir = root` (`ontos/commands/query.py:185-188`). |
| `snapshot`/migration tooling explicitly scans both `docs/` and `.ontos-internal/`. | `create_snapshot()` scan dirs (`ontos/core/snapshot.py:115-127`). |
| Default config has empty `scan_paths`, so command coverage depends heavily on command choice/config. | `scan_paths` default empty (`ontos/core/config.py:51-57`), project `.ontos.toml` omits `scan_paths` (`.ontos.toml:10-12`). |

## 2. Feasibility Assessment per Feature

### 2.1 `ontos retrofit` (by mode)

| Mode | Reuse candidates | New code needed (scope) | Hardest part | Dependency risks | Blast radius |
|---|---|---|---|---|---|
| `--standardize` | `scan_documents` walker (`ontos/io/files.py:60-90`), parser+serializer (`ontos/io/yaml.py:77-107`, `ontos/core/schema.py:295-333`), transactional writes (`ontos/core/context.py:95-203`), existing rewrite precedent in migrate/scaffold/promote (`ontos/commands/migrate.py:123-142`, `ontos/commands/scaffold.py:111-114`, `ontos/commands/promote.py:136-139`). | Mostly orchestration CLI + rewrite loop + dry-run/report. **Medium** (~150-300 LOC). | Avoiding parse drift across parser paths (`parse_frontmatter` vs `parse_frontmatter_content`) and preserving body safely (`ontos/core/frontmatter.py:23-76`, `ontos/io/yaml.py:77-107`). | Low-to-medium if implemented as command-layer utility; touching parser core increases risk. | Medium: mass frontmatter rewrite; generally recoverable via git, but broad diff churn. |
| `--lint-fix` | Existing lint thresholds/rules are discoverable (`ontos/commands/map.py:493-520`), and rewrite pipeline exists (`ontos/core/schema.py:295-333`, `ontos/core/context.py:95-203`). | Need pruning policy, deterministic concept selection, summary generation policy, and opt-outs. **Medium-Large** (~250-500 LOC). | “Fill missing summary” is underspecified because `summary` is not a schema/ontology field and existing summary extraction is inconsistent/log-centric (`ontos/core/schema.py:38-58`, `ontos/core/ontology.py:104-176`, `ontos/commands/consolidate.py:73-88`, `ontos/core/history.py:105-120`). | Medium-high: adding new implicit metadata rules can conflict with curation workflows. | High: writes many docs; semantic corruption risk if auto-prune/summary heuristics are wrong. |
| `--obsidian` | Existing pieces: tag/alias normalization (`ontos/core/frontmatter.py:242-302`, `ontos/io/files.py:162-165`), wikilink format helper (`ontos/commands/map.py:561-580`), lenient reader (`ontos/io/obsidian.py:10-36`). | Needs full content-link rewrite engine, reversible migration metadata, collision handling, and bulk write orchestration. **Large** (500+ LOC). | Body link conversion has no existing parser/rewrite infrastructure; current graph/link logic is frontmatter-centric (`ontos/core/graph.py:57-66`, `ontos/core/validation.py:88-133`). | High: likely touches parsing/writing and command orchestration across many modules. | Very high: body/link corruption across library if rewrite rules are imperfect. |

### 2.2 `ontos rename <old_id> <new_id>`

| Question | Assessment |
|---|---|
| Reuse candidates | Graph + missing-ref logic (`ontos/core/graph.py:44-83`), library walkers (`ontos/io/files.py:60-90`, `ontos/commands/map.py:709-714`, `ontos/core/snapshot.py:115-127`), transactional writes/moves (`ontos/core/context.py:119-203`), report generation precedent (`ontos/commands/migration_report.py:27-127`, `ontos/commands/migration_report.py:160-199`). |
| New code needed (scope) | Cross-reference indexer/rewrite engine for `depends_on`, `impacts`, `describes`, and any body-link formats; collision and idempotency checks; dry-run report; optional move logic. **Large** (500+ LOC). |
| Hardest part | Safe global rewrite without false positives plus ID-collision prevention. Current loaders overwrite duplicate IDs silently (`docs[doc.id] = doc`) in map/maintain/query pipelines (`ontos/commands/map.py:736-738`, `ontos/commands/maintain.py:250-256`, `ontos/commands/query.py:43-45`). |
| Dependency risks | High if parser/graph contracts are expanded to include body links; medium if kept command-local with clear adapters. |
| Blast radius | Very high: incorrect rename can break graph integrity and historical references across many files; partial failures are hard to unwind automatically. |

### 2.3 `ontos link-check`

| Question | Assessment |
|---|---|
| Reuse candidates | Existing `check_links` task (`ontos/commands/maintain.py:549-578`), graph broken-link detection (`ontos/core/graph.py:44-83`), orphan detection helper (`ontos/core/graph.py:129-145`), validation orchestrator (`ontos/core/validation.py:72-133`). |
| New code needed (scope) | New CLI command wrapper + output modes + broader checks (orphans, possibly impacts/describes). **Small-Medium** (~120-250 LOC) for internal refs only. |
| Hardest part | Defining scope of “link” because existing implementation checks `depends_on` only (`ontos/core/graph.py:57-66`, `ontos/commands/maintain.py:562-567`). |
| Dependency risks | Low if read-only and built on existing graph/validation paths; medium if expanded to body-link parsing or external URL checks. |
| Blast radius | Low (diagnostic/read-only). |

## 3. The Scoping Question

### 3.1 Which command has most existing infrastructure (lowest effort)?

`ontos link-check` has the strongest base: a working task already exists (`_task_check_links`) and uses the core graph validator (`ontos/commands/maintain.py:549-578`, `ontos/core/graph.py:44-83`). Turning this into a standalone CLI command is mostly interface work, not new core behavior (`ontos/cli.py:31-89`, `ontos/cli.py:96-190`).

### 3.2 Highest risk-to-value ratio

Highest risk-to-value: `ontos retrofit --obsidian`.

Reasoning:
- v3.1 explicitly deferred retrofit/body wikilinks (`.ontos-internal/strategy/v3.1/V3.1.0-Obsidian-Compatibility-Spec.md:45-53`).
- Current implemented obsidian support is output-formatting oriented, not content transformation (`ontos/commands/map.py:355-382`, `ontos/commands/map.py:561-580`).
- Existing link integrity infrastructure does not parse body links (`ontos/core/graph.py:57-66`, `ontos/core/validation.py:88-133`).

### 3.3 If shipping exactly ONE command in v3.2.4

Ship `ontos link-check` first.

Why:
- Reuses existing code directly.
- Read-only (low blast radius).
- Creates immediate value for graph hygiene before any write-heavy automation.
- Can later serve as guardrail for rename/retrofit rollouts.

Evidence: existing check-links task and graph validators (`ontos/commands/maintain.py:549-578`, `ontos/core/graph.py:44-83`, `ontos/core/validation.py:88-133`).

### 3.4 Prerequisites among commands

| Dependency | Assessment |
|---|---|
| `link-check` prerequisite for others? | Not technically required, but operationally valuable as a pre/post validation gate for rename/retrofit. Existing read-only checks already exist (`ontos/commands/maintain.py:549-578`). |
| `rename` prerequisite for `retrofit`? | No hard dependency. They share a missing prerequisite: a robust global reference index/rewrite engine and consistent scan scope (`ontos/commands/map.py:709-714`, `ontos/commands/query.py:31-37`, `ontos/core/snapshot.py:115-127`). |
| Shared prerequisite | Unifying “what is the library” scan behavior and reference coverage is more important than command ordering (`ontos/core/config.py:51-57`, `.ontos.toml:10-12`, `ontos/commands/map.py:709-714`, `ontos/commands/query.py:185-188`). |

## 4. Architecture Concerns

### 4.1 Do these commands require core graph/data-layer changes?

| Command | Core change needed? | Evidence-based rationale |
|---|---|---|
| `link-check` | Probably no (for v1 scope). | Existing core graph already detects broken `depends_on` and orphans (`ontos/core/graph.py:44-83`, `ontos/core/graph.py:129-145`). |
| `rename` | Likely yes if true “all references” includes body links. | Current core graph models `depends_on` edges only (`ontos/core/graph.py:57-66`), and command ecosystems use mixed parsers/scope (`ontos/core/frontmatter.py:23-76`, `ontos/io/yaml.py:77-107`, `ontos/commands/map.py:709-714`, `ontos/commands/query.py:31-37`). |
| `retrofit` | `--standardize`: no core changes; `--lint-fix` and `--obsidian`: likely policy/data-model extensions. | No formal `summary` field in schema/ontology (`ontos/core/schema.py:38-58`, `ontos/core/ontology.py:104-176`); obsidian body conversion has no existing core representation. |

### 4.2 Existing patterns/constraints that should guide implementation

| Pattern/constraint | Evidence |
|---|---|
| Keep IO/parsing dependencies out of `core` where possible. | YAML wrapper explicitly isolates PyYAML in IO layer (`ontos/io/yaml.py:1-8`). |
| Commands are thin wrappers around options dataclasses and command modules. | CLI handler pattern (`ontos/cli.py:549-627`, `ontos/cli.py:934-950`). |
| Batch write operations should prefer `SessionContext` buffering/commit. | `SessionContext` write/move buffer and commit (`ontos/core/context.py:95-203`), used by migrate/scaffold/promote/stub (`ontos/commands/migrate.py:109-142`, `ontos/commands/scaffold.py:152-181`, `ontos/commands/promote.py:202-217`, `ontos/commands/stub.py:141-144`). |
| Dry-run/report UX already exists and should be reused for risky commands. | `maintain --dry-run` (`ontos/commands/maintain.py:35-39`, `ontos/commands/maintain.py:270-272`, `ontos/commands/maintain.py:555-557`), `migrate --dry-run` (`ontos/commands/migrate.py:21-24`, `ontos/commands/migrate.py:118-121`), report generation command (`ontos/commands/migration_report.py:160-199`). |

### 4.3 Potential boundary violations

| Risk | Why it violates current boundaries |
|---|---|
| Putting body-link parsing heuristics into core graph immediately | Core graph currently models typed dependency edges from structured frontmatter, not freeform markdown parsing (`ontos/core/graph.py:57-66`). |
| Adding network URL health checks into `doctor`/`link-check` without clear isolation | Current dependency set has no HTTP client dependency (`pyproject.toml:29-32`), and doctor currently performs local diagnostics only (`ontos/commands/doctor.py:51-565`). |
| Treating “atomic rename” as solved by existing transaction helper | `SessionContext` supports move/write buffering, but failure handling does not provide full rollback for already-applied renames/writes (`ontos/core/context.py:159-203`). |

## 5. What the Proposal Gets Wrong (or Doesn’t Know)

1. The proposal assumes retrofit-level Obsidian transformation is close at hand; code reality is narrower.
Evidence: v3.1 explicitly deferred retrofit/body wikilinks (`.ontos-internal/strategy/v3.1/V3.1.0-Obsidian-Compatibility-Spec.md:45-53`), while implementation mainly covers map link formatting and load-time tag/alias normalization (`ontos/commands/map.py:355-382`, `ontos/commands/map.py:561-580`, `ontos/io/files.py:162-165`).

2. “`map --obsidian` includes tags” is overstated in current runtime behavior.
Evidence: CLI help says “wikilinks, tags” (`ontos/cli.py:121-123`), but map rendering code only changes link formatting in the table and does not emit tag columns/sections (`ontos/commands/map.py:355-382`, `ontos/commands/map.py:561-580`).

3. “Atomic rename across entire library” is underspecified against inconsistent scan scope and parser paths.
Evidence: map/maintain use `docs_dir + scan_paths` (`ontos/commands/map.py:709-714`, `ontos/commands/maintain.py:232-243`), query scans root (`ontos/commands/query.py:31-37`), snapshot scans docs + `.ontos-internal` (`ontos/core/snapshot.py:115-127`), default `scan_paths` is empty (`ontos/core/config.py:51-57`).

4. ID-collision behavior is not addressed, but current pipelines silently overwrite same-ID docs in memory.
Evidence: map (`ontos/commands/map.py:736-738`), maintain graph load (`ontos/commands/maintain.py:250-256`), query scan (`ontos/commands/query.py:43-45`).

5. The proposal treats “summary fill” as straightforward, but `summary` is not part of canonical schema/ontology.
Evidence: schema optional fields exclude `summary` (`ontos/core/schema.py:38-58`), ontology field definitions do not include `summary` (`ontos/core/ontology.py:104-176`). Existing summary extraction behavior is ad-hoc and inconsistent (`ontos/commands/consolidate.py:73-88`, `ontos/core/history.py:105-120`, `ontos/commands/map.py:185-190`).

6. “link-check” is partially already implemented under `maintain`.
Evidence: existing `check_links` task reports broken dependency links (`ontos/commands/maintain.py:549-578`), with tests validating that behavior (`tests/commands/test_maintain.py:203-217`).

7. External URL health checks are not an incremental extension of current link checking; they introduce new concerns.
Evidence: current link checking is dependency-ID based (`ontos/core/graph.py:57-66`, `ontos/commands/maintain.py:562-567`), and project deps do not include HTTP clients (`pyproject.toml:29-32`).

8. The proposal underestimates legacy-content safety risks during bulk rewrite.
Evidence: parser behavior is mixed (strict IO YAML vs fallback parser) (`ontos/io/yaml.py:77-107`, `ontos/core/frontmatter.py:79-151`), and not all commands use lenient Obsidian read path (`ontos/io/obsidian.py:10-36`, `ontos/commands/migrate.py:114-117`, `ontos/commands/promote.py:121-137`).

## Recommendation Snapshot

- **Ship in v3.2.4:** `ontos link-check` (standalone command, read-only), because `check_links` already exists and is read-only over graph data (`ontos/commands/maintain.py:549-578`, `ontos/core/graph.py:44-83`).
- **Defer:** `retrofit --obsidian` and full `rename` until reference indexing/rewrite engine + dry-run/report + collision policy are designed (`ontos/core/graph.py:57-66`, `ontos/commands/migration_report.py:160-199`, `ontos/commands/map.py:736-738`).
- **Safe next increment:** add `--orphans` and optional `--include impacts,describes` to `link-check` by reusing `ValidationOrchestrator`/`detect_orphans` (`ontos/core/graph.py:129-145`, `ontos/core/validation.py:155-178`).
