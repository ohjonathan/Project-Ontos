---
id: v3_2_4_discovery_design_report
type: strategy
status: draft
depends_on: [v3_2_2_interop_discussion]
concepts: [design-analysis, retrofit, rename, link-check, risk-assessment, v3.2.4]
---

# v3.2.4 Discovery: Design & Risk Analysis Report

> **Design Analyst Report** | Generated 2026-02-10
> Grounded in codebase inspection of Ontos v3.2.3 (commit `631e15c`)

---

## Executive Summary

The v3.2.4 proposal (`interop_maintenance_discussion.md`) identifies a real problem — documents drift, links break, the graph accumulates entropy — but several of its proposed solutions are mis-scoped, redundant with existing infrastructure, or solve problems that don't actually exist in the current library. This report provides concrete evidence for each claim.

**Key findings:**

1. **`ontos link-check` is ~90% already built.** The `ontos maintain` command (task 7: `check_links`) already calls `build_graph()` and reports broken `depends_on` references. A standalone `link-check` is a thin wrapper, not a new feature.
2. **`retrofit --lint-fix` proposes to fill `summary` fields — but no document in the library uses `summary`.** Zero occurrences across 580 documents. This mode is solving a non-problem.
3. **`retrofit --obsidian` duplicates `ontos map --obsidian`**, which already generates wikilinks and tags. The proposal conflates *output format* (how the context map renders) with *source format* (rewriting the actual documents).
4. **`ontos rename` is the only genuinely new capability** with no existing equivalent, and it has real infrastructure support via `SessionContext`.
5. **The 38 errors from `ontos map` are the real pain point** — broken `depends_on` references are the actual maintenance burden, not formatting inconsistencies.

---

## 1. User-Facing Design Analysis

### 1.1 Command Taxonomy Fit

The CLI currently has 21 primary commands organized into loose functional groups:

| Group | Commands | Pattern |
|-------|----------|---------|
| **Setup** | `init`, `scaffold`, `stub` | Create/bootstrap |
| **Generate** | `map`, `agents`, `export data`, `export claude` | Produce artifacts |
| **Maintain** | `maintain`, `consolidate`, `promote`, `verify` | Library upkeep |
| **Diagnose** | `doctor`, `query` | Inspect state |
| **Migrate** | `schema-migrate`, `migrate`, `migration-report` | Schema evolution |
| **Session** | `log`, `env` | Runtime context |

**Assessment of proposed commands:**

- **`ontos link-check`** — Fits the **Diagnose** group, but overlaps with `doctor` (health checks) and `maintain` (task 7: `check_links` at `maintain.py:549-578`). Adding a third place to check links fragments the user's mental model.
- **`ontos rename`** — Genuinely new. Fits **Maintain** group. No existing equivalent.
- **`ontos retrofit`** — An overloaded command trying to do three unrelated things (Obsidian interop, formatting, linting). This is a different paradigm from the existing CLI, where each command does one thing.

**Recommendation:** `retrofit` should not be a single command with mode flags. The three modes have different risk profiles, different use cases, and different target users. If any are worth building, they should be separate.

### 1.2 The `ontos doctor` Question

**`ontos doctor` exists** (`ontos/commands/doctor.py`, 590 lines). It runs 9 health checks:

1. Configuration (.ontos.toml)
2. Git hooks
3. Python version
4. Docs directory
5. Context map existence
6. Validation (first 50 files)
7. CLI availability
8. AGENTS.md staleness
9. Environment manifests

**`doctor` is diagnostic, not curative.** It reports problems but doesn't fix them. The proposal's question "should these be part of `ontos doctor`?" conflates two different concerns:

- **Detection** (doctor's job): "You have 38 broken links" → already done
- **Repair** (new capability): "Fix those 38 broken links automatically" → not implemented

The backlog already tracks `F-M4: doctor --repair` as a planned feature. The right answer is: **link detection stays in `doctor`/`maintain`; link *repair* is a new capability that belongs in `maintain` as a new task, not a separate command.**

### 1.3 Dry-Run & Reversibility Precedent

The codebase has a **strong dry-run precedent** in 4 commands:

| Command | Flag | Default | Notes |
|---------|------|---------|-------|
| `maintain` | `--dry-run/-n` | Off | Reports what tasks would run |
| `scaffold` | `--dry-run` | **On** (must `--apply`) | Preview-first: safe default |
| `schema-migrate` | `--dry-run/-n` | Off | Preview schema changes |
| `consolidate` | `--dry-run/-n` | Off | Preview archive operations |

**`scaffold` is the best precedent for `retrofit`-like operations**: it defaults to dry-run and requires `--apply` to actually modify files. Any command that modifies 300+ documents should follow this pattern.

**Backup pattern:** The codebase uses `.bak` files (`agents.py:314-318`) for individual file backups. For bulk operations, `SessionContext` (`core/context.py:38-199`) provides two-phase commit with rollback:

```
Phase 1: Write all changes to .tmp files
Phase 2: Atomic rename .tmp → final (POSIX atomic)
Failure: Clean up .tmp files, raise error
```

**What's missing:** `SessionContext` handles atomicity (all-or-nothing) but not *undo* (reverting after a successful commit). For a command that touches 300 files, the user needs the ability to revert. Options:

1. Git-based undo (check dirty state, tell user to `git checkout .`)
2. Generate a `.bak` directory before operations
3. Require clean git state before running (safest)

**Recommendation:** Require clean git working tree. Users can `git diff` to review and `git checkout .` to revert. This costs nothing to implement and leverages existing tooling.

### 1.4 Progressive Disclosure

The existing CLI uses two patterns for complexity:

- **Flags on a single command** (e.g., `map --obsidian --compact --filter`)  — when the flags modify *the same operation*
- **Separate commands** (e.g., `doctor` vs `maintain` vs `verify`) — when the operations are fundamentally different

`retrofit --obsidian`, `--standardize`, and `--lint-fix` are fundamentally different operations with different risk profiles. Combining them into one command with flags creates a confusing blast radius question: what does `ontos retrofit` with no flags do? All three? Nothing?

---

## 2. Data Integrity & Risk Analysis

### 2.1 What Documents Actually Look Like

Examined 8 documents across all categories. Key observations:

**Minimal frontmatter (majority of documents):**
```yaml
---
id: ontos_manual
type: kernel
status: active
depends_on: []
---
```

**Extended frontmatter (log documents):**
```yaml
---
id: log_20260210_v3-2-3-final-merge-release-wrap
type: log
status: active
event_type: release
source: codex
branch: main
created: 2026-02-10
---
```

**Critical variation:**
- Release docs (`docs/releases/v3.2.3.md`) have **no frontmatter at all**
- Template (`docs/_template.md`) has **YAML comments** explaining fields
- Generated docs (`docs/reference/ontology_spec.md`) have "DO NOT EDIT" markers
- Field counts range from 3 fields (minimal) to 10+ fields (logs)

### 2.2 Frontmatter Fragility

**Serialization pipeline** (`core/schema.py:295-387`):
- `serialize_frontmatter()` uses a hardcoded `field_order` list
- Outputs fields in deterministic order: `id`, `type`, `status`, `ontos_schema`, `curation_level`, `depends_on`, `concepts`, ...
- Remaining fields (not in list) appended in dict iteration order

**What gets destroyed on round-trip:**

| Feature | Preserved? | Evidence |
|---------|-----------|---------|
| Field values | Yes | Values survive parse → serialize |
| Field order | **Reordered** | Forced to `field_order` list (`schema.py:315-319`) |
| YAML comments | **Stripped** | PyYAML `safe_load()` discards comments; fallback parser skips `#` lines (`frontmatter.py:100`) |
| Blank lines in frontmatter | **Stripped** | Neither PyYAML nor stdlib serializer preserves them |
| Inline vs block list format | **Normalized** | Short lists become `[a, b]`; complex lists become multi-line (`schema.py:358-366`) |
| Quote style | **Normalized** | Only quoted when containing `:` or `{` (`schema.py:370-371`) |

**Implication for `retrofit --standardize`:** This mode would *already happen as a side effect* of any operation that round-trips frontmatter through `serialize_frontmatter()`. The `promote`, `verify`, and `scaffold` commands already enforce field order when they write. A standalone `--standardize` mode is redundant — it's just a round-trip through the existing serializer.

**Corruption risk:** The template file (`docs/_template.md`) contains YAML comments like `# Underscore prefix marks this as internal`. These would be silently destroyed. Any document where a user has added explanatory comments in frontmatter loses them permanently.

### 2.3 Link Format Diversity

Five distinct linking patterns exist in the library:

| # | Pattern | Example | Where | Count |
|---|---------|---------|-------|-------|
| 1 | **Bare ID in frontmatter** | `depends_on: [auth_flow]` | All docs | Primary mechanism |
| 2 | **Bare ID in impacts** | `impacts: [v2_strategy]` | Log docs | Secondary |
| 3 | **Markdown links** | `[Manual](Ontos_Manual.md)` | Reference docs, agent instructions | Moderate |
| 4 | **Wikilinks** | `[[ontology_spec]]` | Generated by `map --obsidian` only | Output-only |
| 5 | **Aliases** | Auto-generated from ID | Validation suggestions | Internal |

**Critical finding for `retrofit --obsidian`:** The proposal wants to convert markdown links in document *source* to wikilinks. But wikilinks currently exist only in *generated output* (the context map via `--obsidian` flag). Converting source documents would:

1. Break standard markdown rendering (GitHub, VS Code preview, any non-Obsidian tool)
2. Be irreversible without git — there's no "unconvert" mode
3. Create a divergence between Obsidian users and non-Obsidian users

The existing `ontos map --obsidian` flag is the correct architecture: generate Obsidian-compatible *output* without mutating *source*. The proposal inverts this.

### 2.4 Atomicity Analysis

**`ontos rename` across 50 files — what happens on failure at file 31?**

`SessionContext` (`core/context.py:132-202`) provides two-phase commit:

```python
def commit(self) -> List[Path]:
    # Phase 1: Write to temp files (.tmp suffix)
    for write in self.pending_writes:
        tmp_path = write.path.with_suffix(write.path.suffix + '.tmp')
        tmp_path.write_text(write.content)
        temp_files.append((tmp_path, write.path))

    # Phase 2: Atomic rename
    for tmp, final in temp_files:
        tmp.rename(final)  # POSIX atomic
```

**If Phase 1 fails** (e.g., permission error on file 31): All `.tmp` files are cleaned up. No source files modified. Safe.

**If Phase 2 fails** (e.g., disk full on rename 31): Files 1-30 have been renamed (committed). Files 31-50 still have old content. **Partial commit — inconsistent state.** This is the real risk.

**Mitigation:** The code has cleanup logic that removes temp files on failure, but once an atomic rename succeeds, it's committed. For `ontos rename`, this means: if the rename succeeds for 30 documents' frontmatter but fails on document 31, you have 30 files with the new ID and 20 files with the old ID in their `depends_on`. The graph is now broken in a *different* way than before.

**Recommendation:** `ontos rename` should:
1. Require clean git state (so `git checkout .` reverts everything)
2. Load all files into memory first, validate the entire rename is possible
3. Only then commit — fail fast before any writes, not during

### 2.5 The Corruption Question — Concrete Examples

**Scenario 1: Naive find-and-replace for `ontos rename old_id new_id`**

Document `docs/reference/Ontos_Manual.md` contains 24 `---` markers and YAML code examples:

```yaml
depends_on: [parent_id]
```

A naive regex replacing `parent_id` inside code blocks would corrupt documentation examples. The rename must only operate on:
- Parsed frontmatter `depends_on` lists (not raw text)
- Parsed frontmatter `impacts` lists
- Possibly markdown link targets (but NOT inside code fences)

**Scenario 2: Round-tripping the template file**

`docs/_template.md` frontmatter:
```yaml
id: _template         # Underscore prefix marks this as internal
type: atom            # REQUIRED. Options: kernel, strategy, product, atom
status: draft         # Optional. Options: draft, active, deprecated
owner: null           # Optional. Role responsible for this doc.
depends_on: []        # List of dependency IDs.
```

After `serialize_frontmatter()`:
```yaml
id: _template
type: atom
status: draft
depends_on: []
owner: null
```

All comments are destroyed. The field `owner` moves to after `depends_on` (field_order list puts `depends_on` before unlisted fields). **This is destructive to documentation value.**

**Scenario 3: Obsidian wikilink conversion inside code blocks**

`Ontos_Manual.md` contains embedded YAML examples. A wikilink converter that doesn't skip fenced code blocks would convert:
```markdown
`depends_on: [auth_flow]`  →  `depends_on: [[[auth_flow]]]`
```

This is syntactically broken in both markdown and YAML.

---

## 3. Graph Model Assessment

### 3.1 The Graph in Code

**Formal data structures exist** (`core/graph.py:18-32`):

```python
@dataclass
class DependencyGraph:
    nodes: Dict[str, GraphNode]           # id → node
    edges: Dict[str, List[str]]           # id → depends_on
    reverse_edges: Dict[str, List[str]]   # id → depended_by
```

**The graph is ephemeral** — reconstructed from frontmatter on every `ontos map` invocation. There is no persistent graph store. This is fine at 580 documents (sub-second build time) but means every operation that needs graph context must re-scan the entire library.

### 3.2 `depends_on` Validation

**Already comprehensive** (`graph.py:44-83`):

1. `build_graph()` checks every `depends_on` reference against `existing_ids`
2. Missing references generate `BROKEN_LINK` errors with severity "error"
3. Fuzzy suggestion engine (`suggestions.py:172-224`) proposes fixes using:
   - Substring matching (confidence: 0.85)
   - Alias matching (confidence: 0.85)
   - Levenshtein distance (variable confidence, threshold: 0.5)
4. Top 3 candidates returned, sorted by confidence

**What's NOT validated:**
- `impacts` references (validated separately in `validation.py:155-169` but only as warnings)
- Markdown link targets (not parsed from body content at all)
- External URLs (not checked)

### 3.3 Infrastructure Available for `link-check`

| Capability | Status | Location |
|-----------|--------|----------|
| Build full dependency graph | Done | `graph.py:build_graph()` |
| Detect broken `depends_on` | Done | `graph.py:64-81` |
| Detect cycles | Done | `graph.py:detect_cycles()` |
| Detect orphans | Done | `graph.py:detect_orphans()` |
| Calculate depth | Done | `graph.py:calculate_depths()` |
| Suggest fixes for broken links | Done | `suggestions.py:172-224` |
| Collect all validation errors | Done | `validation.py:ValidationOrchestrator` |
| Report errors with context | Done | `map.py:_generate_validation_section()` |
| Run as maintain task | Done | `maintain.py:549-578` (`check_links` task) |
| Standalone CLI command | **Not done** | Would need registration in `cli.py` |

**Assessment:** A standalone `ontos link-check` command is approximately 40 lines of new code: register the subparser in `cli.py`, create a handler that calls `build_graph()` + `detect_cycles()` + `detect_orphans()`, and format output. The hard work is already done.

### 3.4 Graph as Data Model vs File-System Artifact

The graph exists in two forms:

1. **Source of truth:** Frontmatter `depends_on` fields in individual `.md` files (file-system artifact)
2. **Derived view:** `DependencyGraph` object built in memory (data model, ephemeral)

There is no third form (no database, no index file, no cache of the graph). The context map (`Ontos_Context_Map.md`) is a *rendered view*, not a queryable store.

**Implication for `ontos rename`:** The rename must modify the *source of truth* (frontmatter in files), not a derived data structure. This means:
1. Scan all documents (already done by `scan_documents()`)
2. Parse all frontmatter (already done by `load_document_from_content()`)
3. Find all references to `old_id` in `depends_on` and `impacts` arrays
4. Rewrite those arrays with `new_id`
5. Update the renamed document's own `id` field
6. Commit atomically via `SessionContext`

Steps 1-4 require no new infrastructure. Step 5-6 follow the `promote`/`verify` pattern.

---

## 4. Scope Recommendation

### 4.1 What's the Actual Problem?

The proposal conflates three distinct problems:

| Problem | Evidence | Severity |
|---------|----------|----------|
| **Broken links** | 38 errors from `ontos map` — all `BROKEN_LINK` type | **High** — blocks strict mode, erodes trust in graph |
| **Document drift** | 300 warnings (orphans, staleness, missing fields) | **Medium** — informational, not blocking |
| **Format inconsistency** | Frontmatter field order varies, some docs lack frontmatter | **Low** — cosmetic; existing tools handle variation gracefully |

The core pain point is **graph integrity** (broken links), not interoperability or formatting. The 38 errors are the problem users actually encounter. The 300 warnings are noise that the system already tolerates.

### 4.2 Minimum Viable v3.2.4

**Ship these two things:**

#### 1. `ontos link-check` (standalone diagnostic)

Extract the existing `check_links` logic from `maintain.py` into a dedicated command with better output:

- Full broken-link report (not capped at 5 like the maintain task)
- Include fix suggestions (already generated by `suggest_candidates_for_broken_ref`)
- Include orphan report
- Support `--json` for machine consumption
- Exit code: 0 = clean, 1 = broken links found

**Effort:** ~100 lines (command registration + handler + output formatting). All graph infrastructure exists.

**Why standalone command, not just `maintain`:** Users want to check links *without* running all 8 maintenance tasks. The maintain task caps output at 5 broken links. A diagnostic tool should show everything.

#### 2. `ontos rename <old_id> <new_id>` (atomic rename)

New capability with no existing equivalent. Implementation:

- Require clean git working tree (abort if dirty)
- Default to dry-run (`--apply` to execute, following `scaffold` precedent)
- Update: target document's `id` field, all `depends_on` arrays, all `impacts` arrays
- Use `SessionContext` for atomic commit
- Report all files that would be / were modified

**Effort:** ~200-300 lines. Requires new command module, uses existing `SessionContext`, `build_graph()`, `serialize_frontmatter()`.

**Scope limit:** v3.2.4 should handle ID rename only (frontmatter fields). File/directory moves are a separate, harder problem — defer to v3.3.

### 4.3 What Should Be Deferred

| Feature | Reason to Defer |
|---------|----------------|
| `retrofit --obsidian` | `ontos map --obsidian` already handles output-side interop. Source-side wikilink conversion breaks non-Obsidian tools and is irreversible. If users want Obsidian source compatibility, this needs a separate design discussion about the tradeoff. |
| `retrofit --standardize` | Frontmatter order is already enforced by `serialize_frontmatter()` whenever any command writes. A standalone "reformat everything" command has no user-facing benefit and risks destroying YAML comments. |
| `retrofit --lint-fix` (summary fill) | **`summary` is not used anywhere.** Zero occurrences across 580 documents in `docs/`, 2 occurrences in a single archived v2 doc. There is no code that reads a `summary` field. This is a feature for a field that doesn't exist. |
| `retrofit --lint-fix` (concept pruning) | "Excessive concepts" is subjective. No heuristic is given. Auto-pruning semantic metadata requires understanding content — this is an LLM task, not a CLI task. |
| External URL health checking | Out of scope for a documentation graph tool. Existing tools (linkchecker, markdown-link-check) do this better. |
| `doctor --repair` | Good idea but needs its own design pass. Repair actions have different risk profiles per check type. |
| Directory moves with rename | File moves change `filepath` references in the graph, config paths, and potentially import patterns. Much harder than ID rename. Defer. |

### 4.4 What's Missing from the Proposal

**1. `ontos fix-links` (or `rename` with `--auto` mode)**

The 38 broken links already have fix suggestions with confidence scores. A command that auto-applies high-confidence fixes (e.g., `ontos fix-links --confidence 0.85 --apply`) would directly address the #1 pain point. This is more valuable than any `retrofit` mode.

**2. Frontmatter-safe editing**

Every command that modifies frontmatter destroys YAML comments. Before adding more write commands (`retrofit`, `rename`), the serializer should be made comment-preserving — or the project should formally document that YAML comments in frontmatter are not supported. Currently it's an undocumented gotcha.

**3. Pre-operation validation for `rename`**

The proposal doesn't discuss: what if `new_id` already exists? What if `old_id` is referenced in markdown body text (not just frontmatter)? What about the context map itself (which contains rendered references)? These edge cases need explicit handling.

---

## 5. Design Alternatives

| Proposed | Problem | Alternative | Why Better |
|----------|---------|-------------|------------|
| `ontos retrofit` (3 modes in 1 command) | Overloaded: different risk profiles, different users, different purposes | Split into separate concerns or absorb into existing commands | Each operation gets its own dry-run, its own documentation, its own risk assessment |
| `retrofit --obsidian` (convert source to wikilinks) | Breaks non-Obsidian tools; `map --obsidian` already exists for output | Keep source as standard markdown; enhance `map --obsidian` if needed | Non-destructive; works for all users, not just Obsidian users |
| `retrofit --standardize` (reorder frontmatter) | Already happens as side effect of any write command; destroys comments | Document the `field_order` convention; don't force-rewrite all files | Avoids unnecessary churn and comment loss |
| `retrofit --lint-fix` (fill `summary`) | `summary` field doesn't exist in any document; no code reads it | Remove from proposal; if summaries are wanted, design the field first, then the filler | Don't build automation for a schema that doesn't exist yet |
| `link-check` as new command | 90% overlap with `maintain check_links` task | Standalone command that reuses `build_graph()` but with full output (not capped at 5) | Minimal new code; leverages existing infrastructure completely |
| `rename` with implicit apply | Modifies 50+ files with no preview | Default to dry-run; require `--apply` (like `scaffold`) | Follows existing precedent; prevents accidents |
| `rename` handling file moves | Directory moves are coupled with ID rename | ID-only rename in v3.2.4; file moves deferred to v3.3 | Reduces scope; ID rename alone is useful and safe |

---

## Appendix: Key Source Files Referenced

| File | Purpose | Lines Referenced |
|------|---------|-----------------|
| `ontos/cli.py` | Command registration, 21 commands | 34-88, 153-158 |
| `ontos/commands/maintain.py` | Task registry, `check_links` task | 549-578 |
| `ontos/commands/doctor.py` | 9 health checks | 540-550 |
| `ontos/core/graph.py` | `DependencyGraph`, `build_graph()`, cycle/orphan detection | 18-83, 86-184 |
| `ontos/core/schema.py` | `serialize_frontmatter()`, field order, round-trip behavior | 295-387 |
| `ontos/core/context.py` | `SessionContext`, two-phase commit | 38-199 |
| `ontos/core/frontmatter.py` | Parsing, `normalize_depends_on()` | 23-171 |
| `ontos/core/validation.py` | `ValidationOrchestrator` | 27-179 |
| `ontos/core/suggestions.py` | Broken link suggestion engine | 172-224 |
| `ontos/io/obsidian.py` | BOM handling, vault detection | 10-53 |
| `ontos/commands/scaffold.py` | Dry-run-by-default precedent | 144-187 |
| `.ontos-internal/strategy/proposals/v3.2.4/interop_maintenance_discussion.md` | Original proposal | Full file |
