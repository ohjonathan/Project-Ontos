---
id: v2_7_documentation_ontology
type: strategy
status: complete
depends_on: []
concepts: [ontology, documentation, relationships, bidirectional]
---

# v2.7 Documentation Ontology: A Philosophical Framework

**Date:** 2025-12-18
**Authors:** Johnny + Claude Code (collaborative dialogue)
**Status:** Draft - Philosophy Proposal (precedes implementation proposal)

---

## Executive Summary

### The Problem

Ontos tracks dependencies downward (strategy → product → atom) but has no mechanism for tracking when user-facing documentation (README, Manual, Guides) becomes stale after atoms change. This is an ontological gap, not a discipline problem.

### The Core Insight

User-facing docs are **second-order atoms**: they describe implementations rather than implementing strategy directly. Their truth derives from implementation truth, creating a different relationship than `depends_on`.

### The Proposed Solution

Introduce a new relationship type: `documents`

```yaml
# In Ontos_Manual.md frontmatter
---
id: ontos_manual
type: atom
depends_on: []
documents:                  # WHAT this doc describes
  - ontos_end_session
  - ontos_maintain
---
```

When atoms change, Archive Ontos warns if documentation may be stale.

### Key Design Decisions (from discussion)

| Decision | Rationale |
|----------|-----------|
| Docs declare `documents`, not atoms declaring `documented_by` | Natural ownership - doc authors know what they cover |
| Version bumps as primary trigger | Significance filter; minor changes don't need doc review |
| Git push/Archive Ontos as fallback | For projects without versioning |
| No hierarchy among user-facing docs | Each doc is independent; confirmed by Johnny |
| Single-source declaration with computed inverse | Bidirectional visibility without dual maintenance |

### Status

**Philosophy proposal** - awaiting review before implementation proposal is created.

### Open Questions

1. Frontmatter vs manifest as source of truth
2. Section-level tracking worth the complexity?
3. How docs mark themselves as "reviewed and current"

---

## Preamble: Why This Document Exists

This is not a typical implementation proposal. Before we can implement v2.7, we need to resolve fundamental questions about the ontology itself. Johnny explicitly requested:

> "I think even before a proposal doc for implementation, we may need to make a proposal doc for philosophy / strategy update."

This document captures the philosophical discussion that led to the v2.7 concept, preserving the reasoning journey so future contributors (human or AI) understand not just WHAT we decided, but WHY and HOW we got there.

---

## Part I: The Original Problem

### 1.1 Johnny's Initial Observation

The v2.7 idea emerged from a simple but profound observation:

> "When people are updating the existing workflows / features, is there anyway Ontos automatically alert which documents to be updated? We have context maps. We have ontology. We have impact tracking. I think there should be a way to make it dynamically."

Johnny identified an asymmetry in the current system:

> "Right now, if we update the main doc (e.g., strategy.md, mission.md), we can update the existing features; however, the other ways around (e.g., when key features are updated, readme / manuals / other user facing docs may be staled still)."

### 1.2 The Key Insight

Johnny then made a crucial conceptual leap:

> "Of course, when atoms are updated, I am not saying kernel should be updated; that's wrong. However, I think user facing docs (e.g., Readme) can be treated as an atom?"

This question - "can user-facing docs be treated as atoms?" - opened the philosophical inquiry. The answer is nuanced: yes, they ARE atoms, but they're a special kind of atom that doesn't fit cleanly into the existing dependency model.

### 1.3 Request for Deep Thinking

Johnny explicitly requested thorough exploration:

> "Ultrathink and deeply think about this problem. Ask clarification questions if you have any."

What followed was a collaborative philosophical dialogue that surfaced fundamental questions about the nature of documentation in an ontological system.

---

## Part II: Clarifying Questions & Answers

Before proposing solutions, we needed to understand the problem space. Here are the questions asked and Johnny's answers:

### Q1: Where Should the Link Live?

**Question:** Should the relationship between docs and atoms be declared in:
- A) The atoms themselves (`documented_by: [readme, manual]`)
- B) The documentation (`documents: [atom1, atom2]`)
- C) A separate manifest file
- D) Computed from context/impact chains

**Johnny's Answer:**
> "I think for this purpose, only user facing docs, right? Combination of B and D... dependency (or, at least indication of relationships) need to be bi-directional."

**Insight:** Johnny emphasized that the relationship needs bidirectional indication - not just "doc knows about atom" but some way for the system to see both directions. This is philosophically important: the relationship EXISTS regardless of which end declares it.

### Q2: What Triggers Staleness Detection?

**Question:** When should the system check if docs are stale:
- A) Any code change
- B) Version bumps only
- C) Manual triggers
- D) Specific file patterns

**Johnny's Answer:**
> "Version bumps; any changes major enough for a version bump should impact the docs."

**Insight:** Version bumps serve as a natural "significance filter." Not every code change matters for documentation, but version-level changes almost always do.

### Q3: What Role Do Logs Play?

**Question:** Session logs capture what changed. Should they be:
- A) The primary trigger for staleness
- B) Supplementary context
- C) Not involved

**Johnny's Answer:**
> "Logs is a history of code changes... trigger should be version bump level changes, logs as supplemental. But consider every Git push / Archive Ontos as a trigger for user-mode who don't have version bumps."

**Insight:** This reveals a dual-mode consideration:
- **Projects with versioning:** Version bump = trigger, logs = context
- **Projects without versioning:** Git push / Archive Ontos = trigger

### Q4: Is There Hierarchy Among User-Facing Docs?

**Question:** Does README depend on Manual? Does Manual depend on Agent Instructions?

**Johnny's Answer:**
> "I don't think so, because they can exist on their own... they all have their own independence."

**Insight:** User-facing docs are PEERS, not hierarchical. Each stands alone and documents whichever atoms it covers. This is different from the strategy→product→atom hierarchy.

---

## Part III: Philosophical Deep Dive

### 3.1 The Ontological Puzzle

Johnny's responses surfaced a fundamental issue with the current ontology:

**Current model:** One-directional implementation hierarchy
```
kernel → strategy → product → atom
         (higher truth)     (lower truth)

Lower docs "depend_on" higher docs = "I implement your truth"
```

**The anomaly:** User-facing documentation doesn't fit this pattern:
- README doesn't "implement" `ontos_end_session.py`
- Instead, README "describes" `ontos_end_session.py`
- The Manual's accuracy DEPENDS on the code being unchanged
- But the code's functionality doesn't depend on the Manual

This is a fundamentally different relationship than `depends_on`.

### 3.2 Johnny's Philosophical Framing

When the discussion got deep, Johnny affirmed its importance:

> "This is getting deep. I don't think you are overcomplicating these; I think this is important."

Johnny recognized that we weren't just adding a feature - we were potentially extending the ontological model itself. This warranted careful philosophical treatment before code.

### 3.3 Second-Order Atoms

From this discussion emerged the concept of "second-order atoms":

**First-order atoms** implement strategy directly:
```
strategy: "Users can archive sessions"
    ↓ depends_on
atom: ontos_end_session.py (implements archiving)
```

**Second-order atoms** describe first-order atoms:
```
atom: ontos_end_session.py (the implementation)
    ↓ documents (new relationship)
atom: Ontos_Manual.md (describes how archiving works)
```

The key insight: Second-order atoms derive their truth from IMPLEMENTATION truth, not directly from strategy. Their accuracy depends on the atoms they document being unchanged.

### 3.4 The Bidirectionality Question

Johnny's insistence on bidirectionality deserves philosophical attention:

> "Dependency (or, at least indication of relationships) need to be bi-directional."

This is philosophically correct. The relationship EXISTS regardless of which end declares it. If Manual documents `ontos_end_session`, then:
- From Manual's perspective: "I document this atom"
- From atom's perspective: "This doc describes me"

Both are true simultaneously. The question is WHERE to STORE the declaration, not WHETHER the inverse exists.

**Resolution:** Single-source declaration with computed inverse:
- Docs declare `documents: [atoms]` (natural ownership - doc authors know what they cover)
- Context map computes `documented_by` for atoms (bidirectional visibility)
- No risk of inconsistency from dual declaration

---

## Part IV: The Proposed Model

Based on our discussion, here's the proposed extension to the ontology:

### 4.1 New Relationship Type: `documents`

```yaml
# In Ontos_Manual.md frontmatter
---
id: ontos_manual
type: atom
status: active
depends_on: []
documents:                  # WHAT this doc describes (content)
  - ontos_end_session
  - ontos_maintain
  - ontos_init
---
```

### 4.2 Relationship Semantics

| Aspect | `depends_on` | `documents` |
|--------|-------------|-------------|
| Meaning | "I implement this truth" | "I describe this implementation" |
| Direction | Lower → Higher rank | Peer → Peer (typically atoms) |
| Staleness | Breaking (can't function) | Non-breaking (just inaccurate) |
| Purpose | Implementation hierarchy | Content accuracy tracking |

### 4.3 Section-Level Tracking (Under Discussion)

Johnny mentioned needing "section-level indication." The proposed syntax:

```yaml
documents:
  - id: ontos_end_session
    sections: ["2. Archive Ontos", "3.1 Graduation Workflow"]
  - id: ontos_maintain
    sections: ["4. Maintenance"]
```

**Status:** Under consideration. Adds precision but also maintenance burden. May start with document-level and add section-level later.

### 4.4 Staleness Detection Flow

Based on Johnny's answers about triggers:

```
1. Developer modifies ontos_end_session.py
2. Developer runs Archive Ontos (or git push)
3. System checks: "What docs list ontos_end_session in `documents`?"
4. System compares: doc_last_modified vs atom_last_modified
5. If atom is newer → Warning:

   ⚠️  Documentation may be stale:
      - Ontos_Manual.md documents ontos_end_session (changed)
        Last doc update: 2025-12-15
        Last atom update: 2025-12-18

   Review and update if needed.
```

For projects with versioning, version bumps are the primary trigger. For projects without, every Archive Ontos checks.

---

## Part V: Open Questions

These emerged from our discussion and need resolution before implementation:

### 5.1 Manifest vs Frontmatter

Johnny suggested a combination of markers in docs AND manifest. We need to decide:
- Is frontmatter in docs sufficient?
- Do we need a separate manifest file?
- What's the single source of truth?

**Current leaning:** Frontmatter as source, context map as computed manifest.

### 5.2 Versioning for Non-Ontos Projects

For user-mode projects that don't have Ontos's versioning, how do we detect "significant" changes?

**Johnny's answer:** "Consider every Git push / Archive Ontos as a trigger."

This works but may be noisy. Need to think about filtering.

### 5.3 Staleness Resolution

When a doc is reviewed and confirmed current (even if atom changed, the doc's content is still accurate), how does it mark itself as "reviewed"?

Options:
- Manual timestamp field (`doc_verified_at: 2025-12-18`)
- Touch the file (updates git timestamp)
- Explicit command (`ontos_verify_doc`)

### 5.4 Cross-Atom Documentation

What if a README section describes behavior that spans multiple atoms? Do we list all of them?

```yaml
documents:
  - ontos_end_session  # Graduation feature touches both
  - ontos_maintain
```

**Current thinking:** Yes, list all. Better to over-specify.

### 5.5 No Cascading (Confirmed)

Johnny confirmed no hierarchy among user-facing docs. Therefore:
- If Manual documents atom A
- And README documents atom B
- Changes to A don't affect README (even if Manual mentions README)

This simplifies the model significantly.

---

## Part VI: Why This Matters

### 6.1 The Deeper Value

This isn't just about "reminding people to update docs." It's about:

1. **Ontological completeness:** The relationship between docs and code EXISTS. Ontos should model it.

2. **Institutional memory:** When docs go stale, context is lost. Future contributors (human or AI) get wrong information.

3. **Trust:** If Ontos can alert on stale docs, users trust the documentation more.

4. **The Ontos mission:** "Enable LLMs to recover context with minimal token expense." Stale docs waste tokens on wrong information.

### 6.2 Johnny's Vision

Johnny saw this as important enough to require a philosophy proposal before implementation:

> "I think even before a proposal doc for implementation, we may need to make a proposal doc for philosophy / strategy update."

This reflects a mature approach: get the ontology right first, then build on solid foundations.

---

## Part VII: Next Steps

### If Philosophy Approved

1. **Create implementation proposal** (`v2.7_implementation.md`)
   - Exact frontmatter schema changes
   - `ontos_end_session.py` modifications
   - Context map generator updates

2. **Update Agent Instructions** with `documents` relationship documentation

3. **Migrate existing docs** to use `documents` field (optional, opt-in)

### If Philosophy Needs Revision

Continue this discussion. The key questions to resolve:
- Is `documents` the right name for this relationship?
- Is section-level tracking worth the complexity?
- How exactly should computed bidirectionality work?

---

## Appendix: Discussion Timeline

| Phase | Topic | Outcome |
|-------|-------|---------|
| Initial | Johnny raises the problem | "User-facing docs become stale when atoms change" |
| Q1 | Where does the link live? | Combination of frontmatter + computed manifest, bidirectional |
| Q2 | What triggers detection? | Version bumps (primary), Archive Ontos (fallback) |
| Q3 | Role of logs? | Supplementary context, not trigger |
| Q4 | Doc hierarchy? | No - user-facing docs are independent peers |
| Synthesis | Second-order atoms | Docs that describe implementations, not strategy |
| Philosophy | Bidirectionality | Single-source declaration, computed inverse |
| Proposal | `documents` relationship | New field type for atom-to-atom documentation links |

---

**Status:** Awaiting philosophical review. Implementation proposal will follow approval.

---

*This document was created collaboratively. Johnny provided the vision and constraints; Claude Code synthesized the philosophical framework and proposed solutions. The discussion was iterative, with each question revealing deeper aspects of the problem.*
