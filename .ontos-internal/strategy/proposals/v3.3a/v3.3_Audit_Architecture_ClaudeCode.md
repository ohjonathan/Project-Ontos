---
id: v3_3_audit_architecture_claude_code
type: review
status: active
depends_on: [v3_2_4_proposal_library_maintenance]
concepts: [architecture-audit, layer-violations, contract-inconsistency, dead-code, tech-debt]
---

# v3.3 Codebase Audit: Architectural Consistency & Internal Contract Violations

> **Auditor:** Claude Code
> **Scope:** All Python source in `ontos/` and `tests/`
> **Date:** 2026-02-10
> **Finding Count:** 20 (1 P1, 12 P2, 7 P3)

Findings are cross-module architectural issues. Individual function bugs, style issues, and known backlog items (X-H2, X-M1–M12) are excluded.

---

## Layer Violations

### AUDIT-CC-01 — Core→IO Layer Violation in snapshot.py

| Field | Content |
|-------|---------|
| **ID** | `AUDIT-CC-01` |
| **Files** | `ontos/core/snapshot.py:106-109`, `ontos/io/config.py`, `ontos/io/files.py`, `ontos/io/yaml.py` |
| **Category** | Layer Violation |
| **Severity** | P2 |
| **Description** | `snapshot.py` is in `ontos/core/` but imports directly from `ontos/io` inside `create_snapshot()` (lines 107-109): `from ontos.io.config import load_project_config`, `from ontos.io.files import scan_documents, load_document_from_content`, `from ontos.io.yaml import parse_frontmatter_content`. Core modules should contain pure domain logic with no IO dependencies. Every other core module respects this boundary. |
| **Risk** | Core layer becomes untestable without filesystem. Future refactoring (e.g., in-memory snapshots for testing) requires touching core. Sets precedent for other core modules to import IO. |
| **Effort** | Medium |

### AUDIT-CC-02 — Cross-Command Import Chain (agents → instruction_protocol → claude_template → export)

| Field | Content |
|-------|---------|
| **ID** | `AUDIT-CC-02` |
| **Files** | `ontos/commands/agents.py:15-20`, `ontos/commands/claude_template.py:5-10`, `ontos/commands/export.py:12`, `ontos/commands/export_claude.py:11-14` |
| **Category** | Layer Violation |
| **Severity** | P2 |
| **Description** | Four cross-command import dependencies beyond the known X-M7 `maintain.py` case: `agents.py` and `claude_template.py` both import from `instruction_protocol.py`; `export.py` and `export_claude.py` both import from `claude_template.py`. This creates a dependency chain: `export → claude_template → instruction_protocol ← agents`. Commands should be independently deployable. |
| **Risk** | Changing `instruction_protocol.py` breaks agents, claude_template, and transitively export. Can't refactor template generation without touching 4 files. Circular dependency risk if instruction_protocol ever needs command context. |
| **Effort** | Medium |

---

## Contract Inconsistencies

### AUDIT-CC-03 — Two Frontmatter Parsers with Incompatible Error Contracts

| Field | Content |
|-------|---------|
| **ID** | `AUDIT-CC-03` |
| **Files** | `ontos/core/frontmatter.py:23-76`, `ontos/io/yaml.py:77-107`, plus 10 callers in `ontos/commands/` |
| **Category** | Contract Inconsistency |
| **Severity** | P1 |
| **Description** | `parse_frontmatter()` returns `None` on error (silent failure, lines 69-76). `parse_frontmatter_content()` raises `ValueError` on error (loud failure, lines 102-104). 10 command callers use `parse_frontmatter()` and must null-check; 3 callers use `parse_frontmatter_content()` and must try/catch. Callers handle the difference inconsistently: `maintain.py:478` uses `or {}` fallback, `query.py:41` doesn't check for None at all (but guards with `if fm` on line 42), `promote.py:170` wraps in try/except. A third parser variant `parse_frontmatter_yaml()` (yaml.py:45-74) exists and is exported but never called. The two active parsers also differ on edge cases: the fallback parser in `parse_frontmatter()` splits on first colon (truncating values with colons), while `parse_frontmatter_content()` uses PyYAML `safe_load`. |
| **Risk** | Adding new commands requires knowing which parser to use and which error pattern to follow. No documentation explains the choice. v3.2.4 `rename` must pick one — wrong choice means silent skips or unexpected aborts on malformed files. |
| **Effort** | Large |

### AUDIT-CC-04 — Three Command Return Type Contracts

| Field | Content |
|-------|---------|
| **ID** | `AUDIT-CC-04` |
| **Files** | `ontos/commands/map.py:668`, `ontos/commands/maintain.py:653`, `ontos/commands/log.py:238`, `ontos/commands/hook.py:32`, `ontos/commands/doctor.py:527`, plus 10 other command files |
| **Category** | Contract Inconsistency |
| **Severity** | P2 |
| **Description** | Command functions use three different return type contracts: (A) `int` — map, maintain, log, hook; (B) `Tuple[int, str]` — stub, migrate, init, verify, scaffold, agents, export, promote, query, consolidate; (C) `Tuple[int, DoctorResult]` — doctor. The CLI wrapper functions in `cli.py` handle this by special-casing each command, but new commands have no guidance on which contract to follow. |
| **Risk** | Wrong return type for a new command causes runtime crash at CLI dispatch. The inconsistency makes the codebase harder to reason about — you have to read the CLI wrapper to know what each command returns. |
| **Effort** | Medium |

### AUDIT-CC-06 — Ubiquitous Defensive Enum Pattern (21 occurrences)

| Field | Content |
|-------|---------|
| **ID** | `AUDIT-CC-06` |
| **Files** | `ontos/commands/map.py:171,186,375,376,450,498,541,542,633,634`, `ontos/commands/export_data.py:71,72,122,123`, `ontos/core/validation.py:140`, `ontos/core/migration.py:81,90`, `ontos/core/snapshot.py:44,55,69,75`, `ontos/core/graph.py:60` |
| **Category** | Contract Inconsistency |
| **Severity** | P2 |
| **Description** | 21 occurrences of `doc.type.value if hasattr(doc.type, 'value') else str(doc.type)` across 6 files. This defensively handles cases where `doc.type` might be a string instead of a `DocumentType` enum. But `load_document_from_content()` (files.py:151-160) always creates a proper enum, falling back to `DocumentType.ATOM` on invalid values. The defensive check is obsolete — `doc.type` is always an enum by construction. Line 171 of map.py is the most paranoid: `d.type.value == "log" or str(d.type) == "log"` — checking both `.value` AND `str()`. |
| **Risk** | Obscures the actual type contract. Developers copying this pattern in new code perpetuate the confusion. If the enum contract is ever intentionally broken, 21 locations silently adapt instead of failing fast. |
| **Effort** | Small |

### AUDIT-CC-07 — Nine Different Scan Scopes Across Commands

| Field | Content |
|-------|---------|
| **ID** | `AUDIT-CC-07` |
| **Files** | `ontos/commands/map.py:709-714`, `ontos/commands/maintain.py:232-243`, `ontos/commands/query.py:31-37`, `ontos/commands/verify.py:35`, `ontos/commands/scaffold.py:54-60`, `ontos/commands/promote.py:162`, `ontos/commands/agents.py:154`, `ontos/commands/migrate.py:68`, `ontos/core/snapshot.py:115-127` |
| **Category** | Contract Inconsistency |
| **Severity** | P2 |
| **Description** | `scan_documents()` is called from 9 locations with 5 different scope patterns: (1) `docs_dir + scan_paths` (map, maintain), (2) entire project root (query, verify), (3) docs + `.ontos-internal/strategy` only (agents), (4) docs + `.ontos-internal` (promote, snapshot), (5) user-provided dirs (migrate, scaffold). No shared constant or configuration defines "the library." Each command independently decides what to scan. |
| **Risk** | Commands produce inconsistent results on the same library. `query` finds documents that `map` doesn't (because it scans root). `agents` misses documents in `.ontos-internal/reference/`. Adding new commands requires guessing which scope to use. The v3.2.4 proposal's `--scope library` flag would add a 6th scope definition. |
| **Effort** | Medium |

### AUDIT-CC-19 — Asymmetric Validation Severity for depends_on vs impacts/describes

| Field | Content |
|-------|---------|
| **ID** | `AUDIT-CC-19` |
| **Files** | `ontos/core/graph.py:74-81`, `ontos/core/validation.py:155-169,171-178` |
| **Category** | Contract Inconsistency |
| **Severity** | P2 |
| **Description** | Broken `depends_on` references produce severity `"error"` (graph.py:78). Broken `impacts` references produce severity `"warning"` (validation.py:162). Broken `describes` references produce severity `"warning"` (validation.py:48). All three are cross-document reference fields pointing to document IDs. The severity asymmetry is undocumented — no comment or design note explains why `impacts` and `describes` are less important than `depends_on`. `ValidationResult.add_error()` routes errors to `.errors` list and warnings to `.warnings` list, so broken impacts/describes are structurally separated from broken depends_on in all downstream consumers. |
| **Risk** | Commands that check `result.errors` for broken references miss broken `impacts` and `describes`. The v3.2.4 `link-check` command inherits this asymmetry — "link-check finds no errors" could be true while 13 broken `impacts` references exist as hidden warnings. |
| **Effort** | Small |

---

## Duplication

### AUDIT-CC-05 — Duplicate build_graph() with Different Signatures

| Field | Content |
|-------|---------|
| **ID** | `AUDIT-CC-05` |
| **Files** | `ontos/core/graph.py:44-83`, `ontos/commands/query.py:58-69` |
| **Category** | Duplication |
| **Severity** | P2 |
| **Description** | Two `build_graph()` functions with the same name but incompatible signatures. Core version: `build_graph(docs: Dict[str, DocumentData]) -> Tuple[DependencyGraph, List[ValidationError]]`. Query version: `build_graph(files_data: Dict[str, dict]) -> Tuple[Dict[str, List[str]], Dict[str, List[str]]]`. Different input types (DocumentData vs raw dict), different output types (DependencyGraph vs plain dicts). Only `query.py` uses its local version. |
| **Risk** | Import confusion — a developer could import the wrong `build_graph`. The query version doesn't benefit from core graph improvements (validation, error collection, orphan detection). Divergent behavior over time. |
| **Effort** | Small |

### AUDIT-CC-09 — Five Document Loading Patterns

| Field | Content |
|-------|---------|
| **ID** | `AUDIT-CC-09` |
| **Files** | `ontos/commands/query.py:38-55`, `ontos/commands/map.py:731`, `ontos/commands/maintain.py:248-256`, `ontos/commands/verify.py:93-107`, `ontos/commands/promote.py:120-136` |
| **Category** | Duplication |
| **Severity** | P2 |
| **Description** | Five distinct patterns for loading documents from files: (1) `parse_frontmatter()` returning raw dict (query, scaffold, migrate, consolidate — 6 commands), (2) `parse_frontmatter()` + manual `normalize_depends_on()` call (query.py:48), (3) `load_document_from_content()` returning `DocumentData` objects (map, maintain — 2 commands), (4) manual `content.split('---', 2)` + body extraction (verify, promote — 2 commands), (5) `parse_frontmatter()` with `or {}` fallback (maintain.py:478). Pattern 1 callers get raw dicts without type normalization. Pattern 3 callers get typed `DocumentData` objects. This means query.py works with different data types than map.py for the same documents. |
| **Risk** | New commands must choose a loading pattern with no guidance. Code that works with one pattern can't interoperate with another. The v3.2.4 rename command would need to choose a pattern, and its choice affects which documents it can process. |
| **Effort** | Large |

### AUDIT-CC-10 — Duplicate load_common_concepts() Definitions

| Field | Content |
|-------|---------|
| **ID** | `AUDIT-CC-10` |
| **Files** | `ontos/core/frontmatter.py:199-239`, `ontos/core/suggestions.py:45-77` |
| **Category** | Duplication |
| **Severity** | P3 |
| **Description** | Two functions named `load_common_concepts()` with different signatures. The frontmatter.py version reads from filesystem (`docs_dir` parameter), returns `set`. The suggestions.py version parses from context map content string, returns `Set[str]`. Only the suggestions.py version is actually called (from `log.py:127`). The frontmatter.py version is dead code. |
| **Risk** | Developer imports the wrong one. Name collision makes it unclear which is canonical. |
| **Effort** | Small |

### AUDIT-CC-11 — Duplicate normalize_depends_on Logic

| Field | Content |
|-------|---------|
| **ID** | `AUDIT-CC-11` |
| **Files** | `ontos/core/frontmatter.py:154-171`, `ontos/io/files.py:166-178` |
| **Category** | Duplication |
| **Severity** | P2 |
| **Description** | `normalize_depends_on()` in frontmatter.py handles None, string, and list inputs. `load_document_from_content()` in files.py (lines 166-178) duplicates the same logic inline: `if depends_on is None: depends_on = []`, `elif isinstance(depends_on, str): depends_on = [depends_on]`. Commands using pattern 1 loading (query.py:48) call the function. Commands using pattern 3 loading (map, maintain) use the inline logic. Both should converge on the function. |
| **Risk** | Logic diverges — a fix to the function doesn't fix the inline code. The inline version doesn't handle all edge cases the function does (e.g., non-string list elements). |
| **Effort** | Small |

---

## Error Handling

### AUDIT-CC-08 — SessionContext.commit() Exceptions Unhandled by 5 Callers

| Field | Content |
|-------|---------|
| **ID** | `AUDIT-CC-08` |
| **Files** | `ontos/core/context.py:132-202`, `ontos/commands/scaffold.py:180`, `ontos/commands/promote.py:216,267`, `ontos/commands/verify.py:152,198,238`, `ontos/commands/stub.py:143`, `ontos/commands/consolidate.py:241` |
| **Category** | Error Handling |
| **Severity** | P2 |
| **Description** | `SessionContext.commit()` can raise `RuntimeError` (lock acquisition failure, line 150) or `IOError` (write failure, re-raised at line 195). Five commands call `commit()` without try/except: scaffold (line 180), promote (lines 216, 267), verify (lines 152, 198, 238), stub (line 143), consolidate (line 241). These exceptions propagate to `cli.py:1052` which catches all `Exception` and returns exit code 5 with a generic "Internal error" message. Users see no actionable diagnostics. |
| **Risk** | Lock contention or disk errors during commit produce unhelpful "Internal error: ..." messages. The user doesn't know if their files were partially modified, fully modified, or untouched. |
| **Effort** | Small |

---

## Dead Code

### AUDIT-CC-12 — Dead Code: extract_doc_ids_from_text()

| Field | Content |
|-------|---------|
| **ID** | `AUDIT-CC-12` |
| **Files** | `ontos/core/suggestions.py:152-169` |
| **Category** | Dead Code |
| **Severity** | P3 |
| **Description** | `extract_doc_ids_from_text()` is defined, exported in `__init__.py`, but never called from any module or test. It extracts document IDs from freeform text using set intersection with known IDs. Possibly planned for body-link detection (relevant to v3.2.4 rename) but currently orphaned. |
| **Risk** | Confusing for maintainers. May bitrot if kept. Could be mistakenly relied upon for v3.2.4 without verification. |
| **Effort** | Small |

### AUDIT-CC-13 — Dead Code: parse_frontmatter_yaml()

| Field | Content |
|-------|---------|
| **ID** | `AUDIT-CC-13` |
| **Files** | `ontos/io/yaml.py:45-74`, `ontos/io/__init__.py:8,45` |
| **Category** | Dead Code |
| **Severity** | P3 |
| **Description** | Third frontmatter parser variant: `parse_frontmatter_yaml(content: str) -> Optional[Dict]`. Exported in `__init__.py` but never imported or called anywhere in the codebase. Returns `Optional[Dict]` (yet another error contract, distinct from both `parse_frontmatter()` and `parse_frontmatter_content()`). Appears to be a legacy intermediate between the other two parsers. |
| **Risk** | Confuses the already-muddled parsing story (AUDIT-CC-03). A developer might use it by mistake. |
| **Effort** | Small |

### AUDIT-CC-14 — Dead Code: DocumentCache Class

| Field | Content |
|-------|---------|
| **ID** | `AUDIT-CC-14` |
| **Files** | `ontos/core/cache.py` (entire module) |
| **Category** | Dead Code |
| **Severity** | P3 |
| **Description** | Complete `DocumentCache` class with hit rate tracking, stats, and TTL support. Never instantiated or imported anywhere in the codebase. Prepared infrastructure for an optimization that was never integrated. |
| **Risk** | Maintenance burden. May give false impression that document caching is available. |
| **Effort** | Small |

### AUDIT-CC-15 — Unused Configuration Options

| Field | Content |
|-------|---------|
| **ID** | `AUDIT-CC-15` |
| **Files** | `ontos/core/config.py:70-71,80` |
| **Category** | Dead Code |
| **Severity** | P3 |
| **Description** | Three config options defined in dataclasses but never enforced: `WorkflowConfig.enforce_archive_before_push` (line 70), `WorkflowConfig.require_source_in_logs` (line 71), `HooksConfig.strict` (line 80, referenced only in a comment in hook.py as a "future feature"). These options are parsed from `.ontos.toml` if present, consuming config budget without providing behavior. |
| **Risk** | Users may set these options expecting enforcement. Silent no-ops erode trust in configuration. |
| **Effort** | Small |

### AUDIT-CC-16 — validate_concepts() Never Called by ValidationOrchestrator

| Field | Content |
|-------|---------|
| **ID** | `AUDIT-CC-16` |
| **Files** | `ontos/core/suggestions.py:127-149`, `ontos/core/validation.py:72-86` |
| **Category** | Dead Code |
| **Severity** | P2 |
| **Description** | `validate_concepts()` exists in suggestions.py with a complete implementation (checks concepts against a known register). But `ValidationOrchestrator.validate_all()` (validation.py:72-86) calls `validate_graph()`, `validate_log_schema()`, `validate_impacts()`, and `validate_describes()` — but NOT `validate_concepts()`. The concepts field is never validated anywhere in the automated pipeline. |
| **Risk** | Concepts with typos or stale references go undetected. Users assume validation is comprehensive when it silently skips concepts. Relevant to v3.2.4: if `link-check` claims to validate "all references," it inherits this gap. |
| **Effort** | Small |

### AUDIT-CC-17 — OutputHandler Bypassed in 3 Commands

| Field | Content |
|-------|---------|
| **ID** | `AUDIT-CC-17` |
| **Files** | `ontos/commands/doctor.py:516-524`, `ontos/commands/init.py:49-59`, `ontos/commands/log.py:1-225`, `ontos/ui/output.py:12-109` |
| **Category** | Contract Inconsistency |
| **Severity** | P3 |
| **Description** | `OutputHandler` provides consistent emoji-prefixed output (`error()`, `warning()`, `success()`, `info()`) and respects a `quiet` flag. 7 commands use it properly. But `doctor.py` uses direct `print()` for config output (line 516-524), `init.py` uses direct `print()` for help text (lines 49-59), and `log.py` doesn't use `OutputHandler` at all (entire 225-line file). Additionally, `files.py:159` prints warnings to `sys.stderr` directly instead of using OutputHandler. |
| **Risk** | `--quiet` flag doesn't suppress output from these commands. Output formatting is inconsistent (some messages get emoji, others don't). Piping output is unreliable. |
| **Effort** | Medium |

### AUDIT-CC-18 — dry_run Field Declared But Never Checked

| Field | Content |
|-------|---------|
| **ID** | `AUDIT-CC-18` |
| **Files** | `ontos/commands/map.py:39`, `ontos/commands/log.py:47` |
| **Category** | Dead Code |
| **Severity** | P2 |
| **Description** | `GenerateMapOptions.dry_run` (map.py:39) and `EndSessionOptions.dry_run` (log.py:47) are declared as `bool = False` in their options dataclasses. Neither file ever checks `options.dry_run` or `self.dry_run`. The fields are not wired to CLI argparse flags, so users can't pass `--dry-run` for these commands. But the dataclass fields suggest the feature was planned and forgotten. If a future developer wires the CLI flag, the option would be silently ignored since no code checks it. |
| **Risk** | Misleading API — the options dataclass implies dry-run support exists. If the CLI flag gets wired without implementing the check, users get false confidence that dry-run is active. |
| **Effort** | Small |

### AUDIT-CC-20 — Exported verify_document() Never Imported

| Field | Content |
|-------|---------|
| **ID** | `AUDIT-CC-20` |
| **Files** | `ontos/commands/__init__.py:145`, `ontos/commands/verify.py` |
| **Category** | Dead Code |
| **Severity** | P3 |
| **Description** | `verify_document()` is exported from `ontos/commands/__init__.py` (line 145) but never imported by any module in the codebase. Only `verify_command()` is used. |
| **Risk** | Minor — clutters the public API surface. |
| **Effort** | Small |

---

## Summary

| Category | P1 | P2 | P3 | Total |
|----------|----|----|----|----|
| Layer Violation | 0 | 2 | 0 | 2 |
| Contract Inconsistency | 1 | 5 | 1 | 7 |
| Duplication | 0 | 3 | 1 | 4 |
| Error Handling | 0 | 1 | 0 | 1 |
| Dead Code | 0 | 2 | 4 | 6 |
| **Total** | **1** | **13** | **6** | **20** |

### Top 5 Priority Fixes

1. **CC-03** (P1): Unify frontmatter parser contracts — single error model, one canonical parser
2. **CC-07** (P2): Define shared scan scope constants — prerequisite for v3.2.4 `--scope` flag
3. **CC-09** (P2): Consolidate document loading patterns — prerequisite for v3.2.4 `rename`
4. **CC-06** (P2): Remove obsolete defensive enum checks — 21 locations, simple cleanup
5. **CC-05** (P2): Deduplicate `build_graph()` — query.py should use core version

### v3.2.4 Relevance

Findings CC-03, CC-07, CC-09, CC-16, and CC-19 directly affect the v3.2.4 `link-check` and `rename` commands. These should be resolved before or during v3.2.4 implementation to avoid inheriting architectural debt into new commands.
