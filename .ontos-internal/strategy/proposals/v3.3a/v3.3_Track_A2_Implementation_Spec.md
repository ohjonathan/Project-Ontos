---
id: v3_3_track_a2_implementation_spec
type: strategy
status: draft
depends_on:
  - v3_3_release_plan
  - v3_3_merged_audit_findings
concepts:
  - v3.3a
  - track-a2
  - command-safety
  - state-integrity
  - hardening
---

# v3.3 Track A2 Implementation Spec

## 1. Overview

Track A2 delivers 13 non-feature hardening fixes focused on command safety, path correctness, parser robustness, and state integrity.

Target modules:

- `ontos/commands/consolidate.py` (#12, #13, #26, #45)
- `ontos/commands/doctor.py` (#14)
- `ontos/core/paths.py` (#15)
- `ontos/core/proposals.py` (#27)
- `ontos/core/history.py` (#28)
- `ontos/commands/migrate.py` (#29, #48)
- `ontos/commands/instruction_protocol.py` (#51)
- `ontos/commands/maintain.py` (#60, #61)

Risk level is low-to-medium overall, with highest risk in:

- Path root anchoring (`#14`, `#15`) due broad runtime impact.
- Consolidation transaction ordering/error semantics (`#12`, `#13`).

Relationship to other tracks:

- Depends on Track A1 only.
- No Track B feature overlap (`scan_scope`, `body_refs`, `link_diagnostics`, `link_check`, `rename`).
- No new features, no new commands.

Estimated change size: ~500-700 LOC including tests.

## 2. Scope

### In Scope

- [ ] `#12 (C-10)` consolidate ordering/atomicity
- [ ] `#13 (C-11)` consolidate exit code on per-log failures
- [ ] `#14 (C-13)` doctor project-root anchoring
- [ ] `#15 (C-14)` path-helper project-root anchoring
- [ ] `#26 (C-12)` consolidate scalar `impacts` normalization
- [ ] `#27 (C-15)` proposal-ledger separator filtering
- [ ] `#28 (C-16)` bare filename `generate_decision_history()` fallback
- [ ] `#29 (C-17)` migrate apply/dry-run semantics enforcement
- [ ] `#45 (X-H2)` consolidate `--count 0` validation
- [ ] `#48 (X-M3)` migrate unsupported schema reporting
- [ ] `#51 (X-M10)` nested USER CUSTOM marker handling
- [ ] `#60 (X-M8)` `_parse_bool` empty/unknown warning semantics
- [ ] `#61 (X-M9)` `TaskResult.status` constrained typing

### Out of Scope

- Any Track B behavior changes.
- New CLI commands.
- New flags (including `--force` in schema-migrate).
- Architectural redesign beyond targeted bug fixes.

## 3. Technical Design

## Group 1: `ontos/commands/consolidate.py` (#12, #13, #26, #45)

### 3.1 `#45` `--count 0` validation

Change:

- Validate options at command entry:
  - If `options.by_age is False` and `options.count < 1`, return `(1, "count must be >= 1")`.
- Keep age mode behavior unchanged.

Compatibility:

- `--count 0` changes from ambiguous no-op to explicit error.

### 3.2 `#26` scalar `impacts` join bug

Change:

- Normalize `impacts` before formatting history rows.
- Use A1 normalization utility:
  - `normalize_reference_list(fm.get("impacts", []), field_name="impacts")`
- Join normalized list only.

Result:

- `impacts: foo` renders as `foo` (not `f, o, o`).

### 3.3 `#12` consolidation ordering/state integrity

Current failure mode:

- File move may succeed before ledger write is committed.
- If ledger write fails afterward, state is inconsistent.

Fix strategy:

- Instantiate one `SessionContext` once per command run and reuse it.
- Execute commit boundaries per log entry (not one global commit across all logs).
- For each selected log:
  1. Buffer decision-history update first (`append_to_decision_history(..., ctx=tx_ctx)`).
  2. Buffer archive move (`tx_ctx.buffer_move(src, dst)`).
  3. Commit once for that log (`tx_ctx.commit()`).
  4. Record success/failure and continue.

Why this is acceptable:

- Removes guaranteed move-first inconsistency path.
- Keeps each log operation in a bounded atomic unit with explicit error reporting.
- Any residual partial-commit behavior is surfaced and treated as failure (see `#13`), never silent success.

### 3.4 `#13` non-zero exit on per-log failures

Change:

- Track per-log outcomes:
  - `succeeded: List[str]`
  - `failed: List[Tuple[str, str]]` (slug, reason)
- Continue processing remaining logs after one failure.
- Final exit code:
  - `0` if no failures
  - `1` if any failure
- Final summary includes succeeded and failed lists.

Failure policy:

- If transaction commit raises for any log, mark that log failed and continue.
- Final output includes explicit reconciliation guidance naming failed slug/path.

## Group 2: Path Resolution (`ontos/core/paths.py`, `ontos/commands/doctor.py`) (#14, #15)

### 3.5 Shared runtime root resolution strategy

Single root precedence for both modules:

1. nearest `.ontos.toml`
2. else nearest `.ontos` or `.ontos-internal`
3. else nearest `.git`
4. else explicit failure (outside project)

### 3.6 `#15` path helpers anchored to runtime root

Change in `ontos/core/paths.py`:

- Replace package-anchored resolution (`PROJECT_ROOT` as effective runtime anchor) with runtime project root resolution.
- Add optional `repo_root` parameter to path getters while preserving call compatibility:
  - `get_logs_dir(repo_root: Optional[Path | str] = None)`
  - `get_archive_dir(...)`
  - `get_decision_history_path(...)`
  - `get_proposals_dir(...)`
  - `get_archive_logs_dir(...)`
  - `get_archive_proposals_dir(...)`
  - `get_concepts_path(...)`
  - `find_last_session_date(..., repo_root=...)` where applicable
- If `repo_root` is not supplied, helper resolves runtime root using the shared precedence above.
- Runtime root resolution must be cached (for example `functools.lru_cache` on resolver helper) to avoid repeated directory-walk cost.
- In call paths that repeatedly query path helpers (loops/tasks), resolve root once and pass `repo_root` explicitly.
- Keep existing legacy fallback warnings via `_warn_deprecated` unchanged.

Compatibility:

- Existing callers remain valid.
- Behavior becomes correct from subdirectories and from external invocation contexts.

### 3.7 `#14` doctor uses project root, not `Path.cwd()`

Change in `ontos/commands/doctor.py`:

- Resolve repo root once at command start.
- Pass resolved root through checks rather than recalculating from `Path.cwd()`.
- Update checks to use resolved root for path operations:
  - configuration
  - git hooks
  - docs directory
  - context map
  - validation
  - environment manifests
- Subdirectory invocation must produce same result as project-root invocation.

Outside-project behavior:

- `doctor` returns non-zero with a clear project-root discovery error, rather than path false negatives.

## Group 3: Parser/History fixes (`ontos/core/proposals.py`, `ontos/core/history.py`) (#27, #28)

### 3.8 `#27` proposal-ledger separator rows

Change in `load_decision_history_entries()`:

- Skip markdown separator rows explicitly using regex:
  - `^\|\s*:?-{3,}\s*(\|\s*:?-{3,}\s*)+\|?$`
- Continue skipping header rows.
- Preserve all existing data-row parsing behavior.

### 3.9 `#28` bare filename output path

Change in `generate_decision_history()`:

- Before `os.makedirs(...)`, normalize dirname fallback:
  - `out_dir = os.path.dirname(output_path) or "."`
  - `os.makedirs(out_dir, exist_ok=True)`

Result:

- `output_path="decision_history.md"` works without error.

## Group 4: Migration fixes (`ontos/commands/migrate.py`) (#29, #48)

### 3.10 `#29` enforce `apply`/`dry_run`/`check` semantics

Problem:

- `MigrateOptions.apply` exists but does not gate writes.

Change:

- Add explicit mode guard at command entry:
  - invalid if `check` and (`dry_run` or `apply`)
  - invalid if `dry_run` and `apply`
  - invalid if not `check` and not `dry_run` and not `apply`
- Write path only when `apply=True`.
- `dry_run=True` is preview-only; never writes.

Compatibility:

- CLI already enforces mutually exclusive flags; this hardens programmatic/API usage.

### 3.11 `#48` unsupported schema versions visibility

Change:

- During migration scan, classify explicit `ontos_schema` as unsupported when either:
  1. schema not in `SCHEMA_DEFINITIONS`, or
  2. compatibility is not fully writable (`READ_ONLY`/`INCOMPATIBLE` for this commandâ€™s write contract)
- Report unsupported schema with file path + schema value.

Behavior:

- `--check`: include unsupported entries and return non-zero.
- `--dry-run`: show warnings only, no writes.
- `--apply`: skip unsupported files, count as errors, return non-zero if any.

Constraint:

- No `--force` added in Track A2.

## Group 5: Template + Config Bool + Maintain typing (#51, #60, #61)

### 3.12 `#51` nested USER CUSTOM markers

Change in `preserve_user_custom_section()`:

- Replace regex span parsing with deterministic marker indexing:
  - opening marker = first `<!-- USER CUSTOM -->`
  - closing marker = last `<!-- /USER CUSTOM -->`
  - preserve content between those outer markers
- Inner marker tokens are retained as plain content.
- If markers malformed/unbalanced, return generated content unchanged (no truncation).

### 3.13 `#60` `_parse_bool` empty/unknown semantics

Change in `ontos/commands/maintain.py`:

- Accepted true values: `1`, `true`, `yes`, `on`.
- Accepted false values: `0`, `false`, `no`, `off`.
- Empty string or unknown token:
  - return default
  - emit `RuntimeWarning` including raw value and accepted set.

Compatibility:

- Existing defaults preserved; ambiguity is now visible.

### 3.14 `#61` `TaskResult.status` constrained type

Change in `ontos/commands/maintain.py`:

- Introduce:

```python
TaskStatus = Literal["success", "failed", "skipped"]
```

- Constrain:
  - `TaskResult.status: TaskStatus`
  - `TaskExecution.status: TaskStatus`
- Keep constants `STATUS_SUCCESS`, `STATUS_FAILED`, `STATUS_SKIPPED` as canonical source.

Runtime safety:

- Add runtime guard before emitting/executing result objects:
  - unknown status is converted to failed execution with internal-status error detail.

Backward compatibility:

- Built-in tasks unaffected.
- Non-canonical statuses from external registry extensions become explicit failures rather than silent contract drift.

## 4. Test Strategy

## Group 1 tests (`tests/commands/test_consolidate_*.py`)

1. `count=0` returns exit `1` and `count must be >= 1`.
2. Scalar impacts (`impacts: foo`) renders `foo`, not character-split.
3. Per-log commit failure yields non-zero final exit and success/failure breakdown.
4. Decision-history append failure prevents archive move for that log.
5. Commit exception path recorded and surfaced as failed log.

## Group 2 tests (`tests/commands/test_doctor_phase4.py`, new `tests/core/test_paths_runtime_root.py`)

1. Doctor from subdirectory matches project-root results.
2. Doctor outside project exits non-zero with root-discovery message.
3. Path helpers resolve relative to runtime root, not install path.
4. Legacy fallback warnings still emitted once where expected.

## Group 3 tests (`tests/core/test_proposals_runtime_paths.py`, `tests/test_immutable_history.py`)

1. Separator rows (`|---|---|`, `|:---|---:|`) are ignored.
2. Bare filename output path writes successfully.

## Group 4 tests (`tests/commands/test_migrate_parity.py`)

1. API mode guard rejects invalid combinations/missing mode.
2. Unsupported schema appears in check output with path + version and non-zero exit.
3. Apply mode skips unsupported schema files and exits non-zero when any unsupported encountered.

## Group 5 tests (`tests/commands/test_instruction_protocol.py`, `tests/commands/test_maintain.py`)

1. Nested USER CUSTOM markers preserve full outer block content.
2. Unbalanced markers do not truncate template output.
3. `_parse_bool` warns on empty and unknown values.
4. Invalid task status from custom task normalizes to failed execution with explicit detail.
5. Built-in tasks still emit only success/failed/skipped.

## Regression gate

1. Run targeted tests for touched files.
2. Run full suite:

```bash
pytest -q tests/
```

## 5. Risk Assessment

1. Highest risk: root anchoring (`#14`, `#15`)
- Risk: broad behavior shift when commands are run from subdirectories or outside repo.
- Mitigation: single root precedence contract + dedicated tests for root/subdir/outside-project scenarios.

2. Medium risk: consolidate ordering and partial failures (`#12`, `#13`)
- Risk: transactional errors can still produce user confusion if under-reported.
- Mitigation: explicit per-log outcome tracking, non-zero exit on any failure, reconciliation guidance.

3. Low risk: parser/history/template fixes (`#27`, `#28`, `#51`)
- Isolated, deterministic parsing behaviors with direct unit tests.

4. Low risk: bool/type strictness (`#60`, `#61`)
- Behavior intentionally tightened with compatibility-preserving defaults and explicit warnings/failures.

## 6. Dependencies & Constraints

1. No Track B file overlap.
2. Use A1 normalization utility where applicable (`normalize_reference_list` for `#26`).
3. No new commands and no new flags in Track A2.
4. Backward compatibility target:
- Commands should keep successful outcomes unchanged.
- Failures become safer and more explicit.

## 7. Implementation Notes

1. Keep fixes minimal and scoped to identified defects.
2. Do not redesign consolidate architecture beyond transaction/error ordering fixes.
3. Preserve CLI UX except where error handling must be clarified.
4. Defer larger enhancements (such as schema migration `--force`) to later track.

## 8. Assumptions and Defaults

1. Spec location is `.ontos-internal/strategy/proposals/v3.3a/v3.3_Track_A2_Implementation_Spec.md`.
2. Runtime root discovery failure is explicit command failure, not silent cwd fallback.
3. Unsupported migrate schemas are warnings/errors depending on mode; never silently ignored.
4. Maintain custom extensions with invalid status strings are treated as failed task executions.
