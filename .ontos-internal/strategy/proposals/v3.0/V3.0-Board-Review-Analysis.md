# Ontos v3.0 Board Review Analysis

**Generated:** 2026-01-09
**Responses Consolidated:** 5 LLMs
**Status:** Analysis Complete — See Decisions Document

> **For Final Decisions:** See [`V3.0-Strategy-Decisions-Final.md`](V3.0-Strategy-Decisions-Final.md)
>
> This document contains the full deliberation, LLM recommendations, and reasoning.
> For quick lookup of decisions, roadmap, and priorities, use the Strategy Decisions document.

---

## 1. Analysis Verification Summary

| LLM | Verification Status | Corrections Needed | Omitted Points |
|-----|---------------------|-------------------|----------------|
| **A** (ChatGPT) | ⚠️ Minor Corrections | MCP timing (not v3.1/v3.2); S3 framing (optional backend, not MCP-specific) | Workspace safety model; Prompts as distributables; Git-based change detection |
| **B** (Chief Architect) | ✅ Accurate | None | "MCP is plumbing, Ontos is value"; Librarian's Wager challenge; Ecosystem immaturity risk |
| **C** (Reviewer) | ⚠️ Minor Corrections | Q2 export framing (complementary, not tool-specific); S3 characterization (operational complexity, not just philosophical) | Friction gradient (L0→L1→L2); Context windows growing to 1M+; MCP exposes existing functionality |
| **D** (Gemini Codebase) | ⚠️ Corrections | MCP position (strongly advocated MCP-first, not "weak"); S3 as MCP Tool architectural distinction | Interactivity Trap (input() calls are hard prerequisite) |
| **E** (Gemini Brief) | ⚠️ Minor Corrections | Hybrid Persistence attribution (E argued for it too); Daemon clarification (protocol essential, daemon is one implementation) | Library vs App architecture separation |

### Corrections Log

**LLM A Correction - MCP Timing:**
> Synthesis said "middle ground - v3.1/v3.2." A clarifies: "I did not recommend specific version numbers. My view was 'design for MCP now, ship when CLI feels rock-solid.'"

**LLM C Correction - Q2 Export Framing:**
> Synthesis characterized as "tool-specific integration." C clarifies: "I framed it as complementary positioning — Ontos owns semantic layer, exported files reference it. Not Claude-specific; Ontos generates derived artifacts like a compiler generates machine code."

**LLM D Correction - MCP Primary:**
> Synthesis listed D as supporting "MCP as optional." D clarifies: "I strongly advocated for 'Ontos v3: The MCP Edition' with Headless Agent as primary user persona. While I accept the decision, my support for MCP-first was strong."

---

## 2. Decision Review Summary

### Agreement Table

| Decision | A | B | C | D | E | Consensus |
|----------|---|---|---|---|---|-----------|
| **pip install ontos (ADOPTED)** | ✅ | ✅ | ✅ | ✅ | ✅ | 5/5 Agree |
| **MCP as optional (ADOPTED)** | ✅ | ✅ | ✅ | ✅ | ✅ | 5/5 Agree |
| **MCP as primary (DECLINED)** | ✅ | ✅ | ✅ | ❌ | ✅ | 4/5 Agree |
| **Legacy install.py (DECLINED)** | ✅ | ✅ | ✅ | ✅ | ✅ | 5/5 Agree |
| **Global CLI + local data (ADOPTED)** | ✅ | ✅ | ✅ | ✅ | ✅ | 5/5 Agree |
| **Functional Core/Imperative Shell (ADOPTED)** | ✅ | ✅ | ✅ | ✅ | ✅ | 5/5 Agree |
| **Daemon as default (DECLINED)** | ✅ | ✅ | ✅ | ❌ | ✅ | 4/5 Agree |
| **MCP server deferred (ADOPTED)** | ✅ | ✅ | ✅ | ✅ | ✅ | 5/5 Agree |
| **Magic defaults (ADOPTED)** | ✅ | ✅ | ✅ | ✅ | ✅ | 5/5 Agree |
| **Doctor command (ADOPTED)** | ✅ | ✅ | ✅ | ✅ | ✅ | 5/5 Agree |
| **Kill python3 ontos.py (ADOPTED)** | ✅ | ✅ | ✅ | ✅ | ✅ | 5/5 Agree |
| **Declarative config TOML (ADOPTED)** | ✅ | ✅ | ✅ | ✅ | ✅ | 5/5 Agree |
| **Progressive disclosure (ADOPTED)** | ✅ | ✅ | ✅ | ✅ | ✅ | 5/5 Agree |
| **S3 archive deferred (ADOPTED)** | ✅ | ✅ | ✅ | ✅ | ✅ | 5/5 Agree |
| **Cross-repo federation deferred (ADOPTED)** | ✅ | ✅ | ✅ | ✅ | ✅ | 5/5 Agree |
| **Staged implementation (ADOPTED)** | ✅ | ✅ | ✅ | ✅ | ✅ | 5/5 Agree |
| **Clean script architecture (ADOPTED)** | ✅ | ✅ | ✅ | ✅ | ✅ | 5/5 Agree |
| **Zero-dependency rule preserved (ADOPTED)** | ✅ | ✅ | ✅ | ❌ | ✅ | 4/5 Agree |

### Dissent Summary

**LLM D dissents on 3 decisions:**

1. **MCP as primary (DECLINED):**
   > "I believe deferring this lowers the immediate value ceiling for AI agents, which are your power users."

2. **Daemon as default (DECLINED):**
   > "A daemon offers sub-millisecond response times and enables 'magic' UX (like instant file watching). CLI-only feels sluggish."

3. **Zero-dependency rule preserved (ADOPTED):**
   > "Writing custom validation logic for complex schemas in 2026 is technical debt, not 'lightweight' engineering. 'Zero Dependencies' is a vanity metric."

**All other LLMs (A, B, C, E) agree with all founder decisions.**

---

### Detailed Dissent Analysis: LLM D vs. Majority

LLM D frames their dissent as advocating for **Operational Robustness** (easy to maintain/use) over **Implementation Simplicity** (easy to build/install). Their argument: the founder is optimizing for **Ontos v2 constraints** (human users, scripts) rather than **Ontos v3 realities** (Agent users, global binary).

Below is a side-by-side comparison for each dissent to help the founder make informed decisions.

---

#### Dissent #1: Zero-Dependency Rule (PRESERVED) — "The Critical Dissent"

**Decision:** Preserve zero-dependency rule for core; MCP layer can add deps via `pip install ontos[mcp]`

| Aspect | LLM D (Dissent) | LLMs A, B, C, E (Agree with Founder) |
|--------|-----------------|--------------------------------------|
| **Core Argument** | "Not Invented Here" syndrome disguised as minimalism. Creates massive hidden technical debt. | Zero-dep core is a feature, not a limitation. MCP layer can have dependencies. |
| **On Validation** | Writing custom validation is hundreds of lines of brittle "if/else" spaghetti. Pydantic validates in one line. | Current schema validation uses stdlib (re, json). It works. (C) Manual validation is "consistent with lightweight." (A) |
| **On MCP Integration** | MCP requires JSON Schema for tool definitions. Without Pydantic, you write Python validation AND manually write separate schema dict → inevitable drift between code and schema. | Pydantic's value (JSON Schema generation) is specifically for MCP. Core Ontos doesn't need it. (B) When MCP ships, add pydantic to that layer. (E) |
| **On Size** | "Saving ~15MB of disk space (negligible) but paying with hundreds of lines of custom code you have to test, debug, and maintain forever." | ~15MB is significant for "lightweight" tool. Optional install keeps core small. (C) |
| **Philosophy** | "Zero-Dep is a vanity metric that hurts maintainability." | Zero-dep core aligns directly with "Lightweight" principle. (A, B, C, E) |

**LLM D's Smoking Gun Argument:**
> "The 'Schema Drift' Trap: You will update Python code (e.g., add a status enum) but forget to update the manual schema definition. The Agent will see the old schema, call the tool, and your code will crash. With Pydantic: `MyModel.model_json_schema()` → Done. The code IS the schema. Zero drift."

**Counter-Arguments from Majority:**
- **LLM A:** "Pydantic is great but not worth breaking core philosophy. MCP layer is exactly where this belongs."
- **LLM B:** "Zero-dep core stays sacred. Protocol-facing JSON schema conveniences belong in optional installs."
- **LLM C:** "Zero-dep core is a feature. Current schema validation works. Don't break it."
- **LLM E:** "Core logic (reading markdown, validating schema) does not strictly need Pydantic. `dict.get()` works fine."

**Key Tension:**
| Philosophy | D's Interpretation | Majority Interpretation |
|------------|-------------------|------------------------|
| "Lightweight" | Lightweight = less code to maintain | Lightweight = fewer dependencies |
| "Simplicity" | Simplicity = use battle-tested libraries | Simplicity = fewer moving parts |

**Decision Framework for Founder:**
1. How much validation logic exists in current codebase? Is it truly "hundreds of lines"?
2. When MCP ships, will schema drift be a real risk in practice?
3. Is `pip install ontos` taking 2 seconds vs 0.5 seconds a meaningful difference?
4. Could you adopt a "core zero-dep, but pydantic for MCP" approach that satisfies both? (This IS the majority recommendation)

---

#### Dissent #2: MCP as Primary (DECLINED)

**Decision:** MCP is optional layer, not primary interface. CLI + readable files remain primary.

| Aspect | LLM D (Dissent) | LLMs A, B, C, E (Agree with Founder) |
|--------|-----------------|--------------------------------------|
| **Core Argument** | CLI-first optimizes for obsolete user persona (Human). Agents are your power users. | MCP as primary would turn "just works" into "configure a server." (A) Adds complexity without proportional value for current use case. (C) |
| **On "Lightweight"** | File-based: Agent reads 5,000-token context map just to say "Hello." MCP: Agent calls function, gets 200-token JSON tree. Files make Agent "dumber" (context saturation). | "Lightweight" refers to installation/maintenance burden, not token efficiency. Current approach works for reasonable project sizes. (B, C) |
| **On Parsing** | CLI outputs text for human eyes. If v3.1 changes table formatting, Agent's parser breaks. MCP is typed, structured, deterministic. | JSON output mode (Q1) provides structured data for Agents without MCP complexity. (A, B, C, E) |
| **On Ecosystem** | "By declining MCP as primary, you are building a better v2 (tool for humans to help AI), not v3 (tool for AI to help itself)." | MCP ecosystem is immature. Best practices still emerging. Early adopters face churn. (B) Python is "second-class" in MCP. (B) |
| **Vision** | Agents are the primary interface. Humans are secondary. | Both humans and agents are users. Progressive disclosure serves both. (B, C) |

**LLM D's Key Argument:**
> "The Token Tax: To understand your project, the Agent must read `Ontos_Context_Map.md`. If that file is 5,000 tokens, you burn 5,000 tokens of the Agent's context window just to say 'Hello.' That is not 'lightweight' for the Agent."

**Counter-Arguments from Majority:**
- **LLM A:** "MCP becomes an additional integration, not the primary distribution mechanism. If you try to make v3 MCP-only, you'll lose users who just want a CLI."
- **LLM B:** "MCP is tactically challenging. Installation UX is bad. Python is second-class in ecosystem."
- **LLM C:** "Daemon is a solution looking for a problem. Operational complexity without proportional value."
- **LLM E:** "Agents aren't mature enough to be the only interface yet; humans still need a CLI."

**Key Tension:**
| Question | D's Answer | Majority Answer |
|----------|-----------|-----------------|
| Who is the primary user? | Agents | Both humans and agents |
| What is "lightweight"? | Token-efficient for agents | Install/maintenance-efficient for users |
| What is v3 about? | Tool-to-Protocol pivot | Distribution & Polish release |

**Decision Framework for Founder:**
1. Who is your actual user for the next 12 months? You (human) or Agents?
2. Does JSON output (Q1, unanimous) solve the "Agent parsing" problem without MCP complexity?
3. Is token efficiency a real problem at current project scale?
4. The majority position is "MCP as layer when ready" — does this address D's concerns sufficiently?

---

#### Dissent #3: Daemon as Default (DECLINED)

**Decision:** No daemon as default. CLI runs and exits. MCP/daemon deferred to later v3.x.

| Aspect | LLM D (Dissent) | LLMs A, B, C, E (Agree with Founder) |
|--------|-----------------|--------------------------------------|
| **Core Argument** | Stateless CLI creates operational friction. Can't achieve "magic" features without daemon. | Daemon adds operational complexity (process management, ports, auth) without proportional value. (A, B, C) |
| **On Watchdog** | "You expressed interest in Passive Observation. You CANNOT do this without a Daemon. If program runs and dies, it cannot watch file events." | Use git-based detection (check `git diff` at `ontos log` time). No daemon needed. (A, D's own Q4 answer, E) |
| **On Performance** | "Cold Start Penalty: Every `ontos query` requires Python startup, import, build graph, query, shutdown = 300ms–1s. Daemon loads once, responds in milliseconds." | CLI latency is acceptable for current use cases. Agents can tolerate 300ms. (implied) |
| **Concession** | **"I concede on this for v3.0.0 because daemons ARE harder to distribute."** | — |

**LLM D's Key Argument:**
> "Without a daemon, Ontos will always be 'Reactive' (a tool you check) rather than 'Proactive' (an assistant that watches)."

**Counter-Arguments from Majority:**
- **LLM A:** "Daemon adds complexity users don't want."
- **LLM B:** "Adds operational complexity without proportional value for most use cases."
- **LLM C:** "Daemon is a solution looking for a problem."
- **LLM E:** "As long as the code is refactored to be importable (headless), the daemon can come later."

**Key Insight: LLM D Concedes**
> "I concede on this for v3.0.0 because daemons are harder to distribute. But be aware that without it, Ontos will always be 'Reactive' rather than 'Proactive.'"

**Key Tension:**
| Feature | With Daemon | Without Daemon |
|---------|-------------|----------------|
| File watching | Real-time | Check at command time (git-based) |
| Response latency | Milliseconds | 300ms-1s |
| Installation complexity | Higher (process management) | Lower (run and exit) |
| "Proactive" behavior | Possible | Limited |

**Decision Framework for Founder:**
1. D concedes this for v3.0.0 — is this a settled question for now?
2. Git-based detection (check diff at command time) may be sufficient for "detect-and-flag" without daemon
3. If future use cases require daemon, architecture should allow adding it — does current approach support this?

---

### Summary: The Philosophical Divide

| Dimension | LLM D's Frame | Majority Frame |
|-----------|--------------|----------------|
| **Optimize for** | Operational Robustness | Implementation Simplicity |
| **Primary user** | Agents | Humans (with Agent support) |
| **"Lightweight" means** | Less code, fewer maintenance burdens | Fewer dependencies, simpler install |
| **v3.0 is about** | Tool-to-Protocol pivot | Distribution & Polish release |
| **Dependencies** | Use battle-tested libraries | Minimize external dependencies |
| **Architecture** | Daemon-first for "magic" UX | CLI-first for simplicity |

**LLM D's Core Thesis:**
> "You have prioritized Implementation Simplicity (easy to build/install). I am advocating for Operational Robustness (easy to maintain/use)."

**Majority Counter-Thesis:**
> "Zero-dep core, CLI-first, no daemon — these aren't constraints, they're features that align with 'simplicity, lightweight, local-first' philosophy. MCP layer can add complexity when needed."

---

### Founder Decision Points (Pre-Response)

| Dissent | D's Severity | Initial Recommendation |
|---------|-------------|----------------|
| **Zero-Dep Rule** | "CRITICAL — most dangerous decision" | Review if current validation code is truly problematic. The compromise (pydantic for MCP layer only) may satisfy both positions. |
| **MCP as Primary** | "High — building better v2, not v3" | JSON output (Q1) may solve Agent parsing concerns without MCP complexity. Revisit when MCP ships. |
| **Daemon Default** | "Conceded for v3.0.0" | Proceed as planned. Ensure architecture allows daemon addition later. |

---

### Founder Responses to Dissents

#### Response to Dissent #1: Zero-Dependency Rule

**Founder's Philosophy Clarification:**
> "I think Model D's interpretations are very interesting. In my mind, 'lightweight' means both less code to maintain AND fewer dependencies — but we cannot avoid dependencies completely. For example, we have a clear dependency on Git. If our dependencies are based on very stable, boring technology, I think that can be included in 'lightweight.' For simplicity, if a library is battle-tested and widely used, we can rely on it at a certain level. Obviously we have to be careful."

**Investigation Conducted:**
The founder explored Pydantic adoption in depth. Key findings:

> **Reference:** `.ontos-internal/strategy/proposals/v3.0/V3.0-Validation-Maintainability-Technical-Analysis.md`

| Metric | Finding |
|--------|---------|
| **Validation Logic Size** | ~3,850 lines across core validation modules |
| **Distinct Validation Functions** | 28 functions |
| **Pydantic Verdict** | "TLDR: this doesn't solve the problem" |

**Founder's Answers to Decision Framework:**

1. **"How much validation logic exists?"**
   > "More than expected. Claude Code analysis shows approximately 3,850 lines across core validation modules with 28 distinct validation functions. This should be seriously considered when writing the v3.0 strategy and technical implementation plan."

2. **"When MCP ships, will schema drift be a real risk?"**
   > "If MCP is only an optional layer for query, I don't see how schema drift will actually happen. Even with full MCP migration, it's deterministic rule-based — we're writing it and guiding LLM. I don't think this is a real case."

3. **"Is pip install taking 2 seconds vs 0.5 seconds meaningful?"**
   > "No, I don't think it's a meaningful difference, especially for initial installations."

4. **"Could you adopt pydantic for MCP layer only?"**
   > "I see we have many lines of validation logic. I realize it's hard to maintain. The analysis should inform our v3 strategy."

**FOUNDER DECISION: Preserve Zero-Dep Rule for Core**
- Pydantic exploration did not solve the core problem
- Schema drift is not a realistic concern for MCP-as-optional-layer
- **Action:** Reference validation analysis in v3 strategy for potential refactoring
- **Status:** Decision CONFIRMED, but validation maintainability flagged for v3.0 planning

---

#### Response to Dissent #2: MCP as Primary

**Founder's Vision Clarification:**
> "I understand where LLM D is coming from. In my mind, v3 of Ontos should focus on separating project-based memory from the package core memory — which inevitably helps both agents and humans."

> "I get this quote about 'CLI-first optimizing for obsolete user persona (human)' — but I don't think we're there yet."

**Version Strategy:**
| Version | Focus | Primary User |
|---------|-------|--------------|
| **v3.0** | Distribution & Polish | Both humans and agents |
| **v3.x** | Prepare for Tool-to-Protocol | Both, with agent improvements |
| **v4.0** | Agent-first, MCP as primary | Agents (humans secondary) |

**Founder's Answers to Decision Framework:**

1. **"Who is your actual user for next 12 months?"**
   > "Humans right now, then agents. But we can do both — we don't have to choose just one. That's not how this works."

2. **"Does JSON output solve Agent parsing without MCP complexity?"**
   > "I'm not sure, but I think we should definitely do JSON output."

3. **"Is token efficiency a real problem at current scale?"**
   > "Token efficiency is not the biggest problem right now, but this is one of those things we should tackle really early on. This should be our core philosophy."

4. **"Does MCP as layer address D's concerns sufficiently?"**
   > "I think it does. v4 can have more agent layers. Right now we can polish and build features that work now AND become a bridge to agent interactions."

**FOUNDER DECISION: MCP as Optional Layer (v3), Primary (v4)**
- v3.0 = Distribution & Polish + prepare for protocol
- v4.0 = Agent-first interface
- JSON output enables agent consumption without MCP complexity
- **Status:** Decision CONFIRMED with clear v3/v4 roadmap

---

#### Response to Dissent #3: Daemon as Default

**Founder's Position:**
> "I think adding Daemon, adding MCP, adding this kind of level of support — that's like building a SaaS product, a SaaS company. It's not really a Python package level anymore. If there are some attractions in v3, maybe we'll dive into that direction. But man, that's a lot of commitment."

**FOUNDER DECISION: Punt Daemon to v4**
- Daemon architecture is SaaS-level commitment, not Python package scope
- LLM D already conceded this for v3.0.0
- Git-based detection (Q4) provides sufficient "detect-and-flag" without daemon
- **Status:** Decision CONFIRMED — Daemon is v4 territory

---

### Final Dissent Resolution Summary

| Dissent | LLM D Position | Founder Decision | Rationale |
|---------|---------------|------------------|-----------|
| **Zero-Dep Rule** | CRITICAL — adopt Pydantic | **PRESERVE** (core zero-dep) | Pydantic doesn't solve problem; schema drift not real risk; MCP layer can have deps |
| **MCP as Primary** | High — building wrong version | **DEFER to v4** | v3 = distribution + polish; v4 = agent-first; both users matter |
| **Daemon Default** | Conceded for v3.0.0 | **DEFER to v4** | SaaS-level commitment; Python package scope doesn't require daemon |

**Key Reference Document:**
> `.ontos-internal/strategy/proposals/v3.0/V3.0-Validation-Maintainability-Technical-Analysis.md`
>
> Contains detailed analysis of existing validation logic (3,850 lines, 28 functions) that should inform v3.0 technical planning.

---

## 3. Open Questions Consolidation

### Q1: JSON Output Mode

**Founder Lean:** Uncertain - wants LLM input on when/why necessary

| Aspect | A | B | C | D | E |
|--------|---|---|---|---|---|
| **Recommendation** | Option A | Option A | Option A | Option A | Option A |
| **Confidence** | High | Medium | High | High | High |
| **Philosophy** | Aligns | Aligns | Aligns | Aligns | Aligns |
| **Complexity** | Low | Low | Low | Low | Low |

**Consensus Level:** 5/5 Unanimous - Option A

**Recommendation Breakdown:**
- Option A (Add JSON now): 5 votes (A, B, C, D, E)

**Key Reasoning Summary:**
- **For Option A:** Enables scripting, CI integration, and future MCP without redesign. Trivial implementation cost (~1-2 days). JSON as optional `--json` flag doesn't compromise "readable" — Markdown remains default for humans.

**Dissent from Founder Lean:** None — founder was uncertain, all LLMs unanimously recommend Option A.

**Implementation Notes:**
- Effort: 1-2 days (consensus)
- Dependencies: None (stdlib json)
- Risk: Schema versioning (A), JSON "drift" from Markdown (A, C)

---

### Q2: Export to CLAUDE.md / AGENTS.md

**Founder Lean:** Skeptical - "Whole purpose is universal across all agentic LLMs"

| Aspect | A | B | C | D | E |
|--------|---|---|---|---|---|
| **Recommendation** | Alternative (template system) | Option B | Option A | Option B | Option B |
| **Confidence** | Medium | High | High | Medium | High |
| **Philosophy** | Tension | Aligns | Aligns | Aligns | Aligns |
| **Complexity** | Medium | Medium | Low | Low | Low |

**Consensus Level:** 3/5 Majority - Option B (Keep agnostic)

**Recommendation Breakdown:**
- Option A (Implement export): 1 vote (C)
- Option B (Stay agnostic): 3 votes (B, D, E)
- Alternative (Template system): 1 vote (A)

**Key Reasoning Summary:**
- **For Option B (majority):** "Never explain twice" means universal format. Building CLAUDE.md creates coupling to specific tools. Maintenance burden as AI tool formats evolve. Ontos should force agents to read the Context Map, creating a standard.
- **For Option A (C):** "Founder's skepticism misunderstands my argument. Export makes Ontos MORE universal — same source, multiple derived outputs. These are instruction files referencing Ontos, not duplication."
- **For Alternative (A):** Template system avoids hardcoding "Claude-first" while capturing adoption upside.

**Dissent from Founder Lean:**
- **LLM C strongly dissents:** "Generating tool-specific files increases universality. Users who use Cursor get .cursorrules. Users who use Claude Code get CLAUDE.md. Same source, multiple outputs. That's universal."

**Implementation Notes:**
- Effort: 1-2 days (if done)
- Risk: Template creep (A), format spec churn (B), drift between source and export (D)

---

### Q3: Lazy Loading / Context Slicing

**Founder Lean:** Wants direction, but not at cost of lightweight simplicity

| Aspect | A | B | C | D | E |
|--------|---|---|---|---|---|
| **Recommendation** | Alternative (progressive compaction) | Option B | Option B | Option A | Option A |
| **Confidence** | Medium | Medium | Medium | High | Medium |
| **Philosophy** | Aligns | Aligns | Aligns | Aligns | Tension |
| **Complexity** | Medium | High | Medium | High | Medium |

**Consensus Level:** Split (2-2-1)

**Recommendation Breakdown:**
- Option A (Implement now): 2 votes (D, E)
- Option B (Defer): 2 votes (B, C)
- Alternative (Progressive compaction): 1 vote (A)

**Key Reasoning Summary:**
- **For Option B (defer):** YAGNI. Current context map is <10k tokens; context windows are 128k-200k. Problem doesn't exist yet. Adds complexity for hypothetical scale.
- **For Option A (now):** Token limits are real as projects grow. Implementing the access pattern now forces code decoupling needed for MCP.
- **For Alternative (A):** Get 80% benefit with compact map + explicit "expand" commands. No `ontos://` URIs needed yet.

**Dissent from Founder Lean:** None significant — founder wanted direction without sacrificing lightweight. Split reflects genuine tension.

**Implementation Notes:**
- Effort: 3-5 days (B, C) to 1 week (D)
- Dependencies: D notes this requires Q11 (script reorg) first
- Risk: Over-engineering (B, C), user confusion on compact view (A)

---

### Q4: Passive Observation (Watchdog)

**Founder Lean:** Option C (detect-and-flag)

| Aspect | A | B | C | D | E |
|--------|---|---|---|---|---|
| **Recommendation** | Alternative (git-based Option C) | Option B | Option B | Option C | Option C |
| **Confidence** | High | High | High | High | High |
| **Philosophy** | Aligns | Aligns | Aligns strongly | Aligns | Aligns |
| **Complexity** | Low | Medium | High | Low | Low |

**Consensus Level:** Split (3-2) but with nuance

**Recommendation Breakdown:**
- Option B (Keep explicit): 2 votes (B, C)
- Option C (Detect-and-flag): 2 votes (D, E)
- Alternative (Git-based Option C): 1 vote (A)

**Key Reasoning Summary:**
- **For Option B:** "Curation over ceremony" means human judgment matters. Auto-detection removes the curation step that creates signal. Watchdog adds dependency and background process.
- **For Option C:** Automating detection removes toil; requiring confirmation keeps human in loop. Use `git diff --name-only` instead of watchdog (no dependency).
- **For Alternative (A):** Git-based detection achieves 90% value with 0 dependencies. No daemon, no watchdog library.

**Dissent from Founder Lean (Option C):**
- **LLM B dissents:** "Even flagging pushes toward automation over curation. The value proposition is that humans curate deliberately."
- **LLM C dissents:** "Detect-and-flag creates expectations. If detection fails (and it will), users blame Ontos or learn to ignore flags."

**Implementation Notes:**
- Key insight: A, D, E all recommend git-based detection, NOT watchdog library
- Effort: 1-2 days for git-based approach
- Risk: False positives (C), semantic accuracy expectations (B, C)

---

### Q5: Version Pinning in .ontos.toml

**Founder Lean:** Uncertain - is this necessary for single-user context?

| Aspect | A | B | C | D | E |
|--------|---|---|---|---|---|
| **Recommendation** | Option A (warn-only) | Option B | Option B (warn-only caveat) | Option A | Option A |
| **Confidence** | High | High | Medium | High | High |
| **Philosophy** | Aligns | Aligns | Aligns | Aligns | Aligns |
| **Complexity** | Low | Low | Low | Low | Low |

**Consensus Level:** Split (3-2)

**Recommendation Breakdown:**
- Option A (Implement pinning): 3 votes (A, D, E) — all suggest "warn-only" initially
- Option B (No enforcement): 2 votes (B, C)

**Key Reasoning Summary:**
- **For Option A:** Version drift becomes bug source with 2+ machines. Warn-only keeps single-user flow clean. Low implementation cost (<1 day). Standard practice (like `engines` in package.json).
- **For Option B:** Single-user context means version drift can't happen today. Add when multi-user becomes reality (~2 hour feature).

**Dissent from Founder Lean:** None — founder was uncertain. Both positions are defensible for current context.

**Implementation Notes:**
- Effort: 0.5-2 hours (consensus)
- Key insight: A and C both suggest "support the config key, warn only" as compromise

---

### Q6: Shim Hooks for Git

**Founder Lean:** Sounds good conceptually

| Aspect | A | B | C | D | E |
|--------|---|---|---|---|---|
| **Recommendation** | Option A | Option A | Option A | Option A | Option A |
| **Confidence** | Medium | Medium | High | High | High |
| **Philosophy** | Aligns | Aligns | Aligns | Aligns | Aligns |
| **Complexity** | Low | Low | Low | Medium | Low |

**Consensus Level:** 5/5 Unanimous - Option A

**Recommendation Breakdown:**
- Option A (Implement shim hooks): 5 votes (A, B, C, D, E)

**Key Reasoning Summary:**
- **For Option A:** With pip distribution, hooks should delegate to global CLI. Reduces "folder pollution." Graceful degradation if ontos not installed. Hook logic auto-updates with tool updates. Implementation trivial (~2-line shell script).

**Dissent from Founder Lean:** None — aligns with founder intuition.

**Implementation Notes:**
- Effort: 0.5-2 days (consensus)
- Dependencies: Global CLI installed (A, B)
- Risk: Windows/Unix compatibility (D), silent failure needs helpful error (B, C)

---

### Q7: Auto-Configure MCP Clients

**Founder Lean:** Deferred to later v3.x; is this helpful or overstepping?

| Aspect | A | B | C | D | E |
|--------|---|---|---|---|---|
| **Recommendation** | Option B (docs now, explicit command later) | Option A (defer with MCP) | Option B | Option A | Option B |
| **Confidence** | High | Medium | Medium | Medium | Medium |
| **Philosophy** | Aligns | Tension | Tension | Aligns | Aligns |
| **Complexity** | Low | Medium | Low | High | Low |

**Consensus Level:** 3/5 Majority - Option B (Documentation only)

**Recommendation Breakdown:**
- Option A (Implement auto-config): 2 votes (B, D)
- Option B (Documentation only): 3 votes (A, C, E)

**Key Reasoning Summary:**
- **For Option B:** Modifying external config files is invasive/"black box." Risk of breaking other tools' configs. Print JSON snippets, let users paste.
- **For Option A:** MCP installation UX is #1 barrier. Users expect installers to configure things. Should be explicit opt-in command when MCP ships.

**Dissent from Founder Lean:** None — question is deferred anyway. Consensus leans toward documentation approach when MCP implemented.

**Implementation Notes:**
- Effort: 0.5 days for docs with snippets
- Risk: Overwriting user customizations (B), config format changes (A)

---

### Q8: Context Slicing Without Sacrificing Lightweight

**Founder Lean:** Is Option A (progressive complexity) achievable?

| Aspect | A | B | C | D | E |
|--------|---|---|---|---|---|
| **Recommendation** | Option A | Option B | Option A | Option A | Option A |
| **Confidence** | Medium | High | Medium | Medium | Medium |
| **Philosophy** | Aligns | Aligns | Aligns | Aligns | Aligns |
| **Complexity** | Medium | N/A | Medium | Medium | Medium |

**Consensus Level:** 4/5 Majority - Option A (Progressive complexity achievable)

**Recommendation Breakdown:**
- Option A (Progressive complexity): 4 votes (A, C, D, E)
- Option B (Accept limitations): 1 vote (B)

**Key Reasoning Summary:**
- **For Option A:** Approach is simple: default full map, auto-enable summary mode if output exceeds threshold. Implementation via `--depth` or `--slice` flags. Small projects never see complexity. No new dependencies needed.
- **For Option B:** "Is Option A achievable? In my assessment, not without significant complexity." Clear scope ("works for <500 docs") is honest.

**Dissent from Founder Lean:** None — founder asked if achievable. 4/5 say yes with specific implementation approaches.

**Implementation Notes:**
- Effort: 3-5 days (consensus)
- Approach (A): Size-based threshold auto-switch to summary mode
- Approach (D, E): `--depth` / `--slice` / `--focus` CLI flags

---

### Q9: MCP Security Model

**Founder Lean:** Wants detailed discussion; minimum viable security without liability

| Aspect | A | B | C | D | E |
|--------|---|---|---|---|---|
| **Recommendation** | Option A (minimum viable A) | Option A | Option A | Option A | Option B |
| **Confidence** | High | High | High | High | Medium |
| **Philosophy** | Aligns | Tension | Aligns | Aligns | Aligns |
| **Complexity** | Medium | Medium | Medium | Medium | Low |

**Consensus Level:** 4/5 Strong Majority - Option A (Defense-in-depth)

**Recommendation Breakdown:**
- Option A (Defense-in-depth): 4 votes (A, B, C, D)
- Option B (Minimal/Localhost): 1 vote (E)

**Key Reasoning Summary:**
- **For Option A:** 4/5 LLMs flagged MCP security — that's signal. Minimum viable: localhost binding, auth token, read-only default, audit logging. Security incidents are existential risk.
- **For Option B (E):** "The MCP server runs locally with user permissions. Sandboxing protects against... the user? Auth tokens for localhost CLI are overkill."

**Dissent from Founder Lean:** None — founder wanted detailed discussion; consensus is clear.

**Implementation Notes:**
- A's "minimum viable A": Explicit workspace root, path allowlist, read-only default, write gating, audit log
- Effort: 1 week when MCP ships (consensus)
- Risk: Over-engineering (E), missing edge case (A)

---

### Q10: Pydantic Requirement

**Founder Lean:** Prefer Option B or C; don't break zero-dep for core

| Aspect | A | B | C | D | E |
|--------|---|---|---|---|---|
| **Recommendation** | Option B | Option B | Option B | Option A | Option B |
| **Confidence** | High | High | High | High | High |
| **Philosophy** | Aligns | Aligns | Aligns | Tension | Aligns |
| **Complexity** | Low | Low | Low | Medium | Medium |

**Consensus Level:** 4/5 Strong Majority - Option B (Pydantic for MCP layer only)

**Recommendation Breakdown:**
- Option A (Core dependency): 1 vote (D)
- Option B (MCP layer only): 4 votes (A, B, C, E)

**Key Reasoning Summary:**
- **For Option B:** Zero-dep core is a feature. Pydantic's value (JSON Schema) is specifically for MCP. `pip install ontos` stays light; `pip install ontos[mcp]` adds pydantic.
- **For Option A (D):** "Writing custom validation for v3.0 schemas is waste of resources. 'Zero-Dep' is a vanity metric. pip install takes 2 seconds either way."

**Dissent from Founder Lean:**
- **LLM D strongly dissents:** "I strongly recommend against the Founder's lean. As technical co-founder, writing custom validation is technical debt."

**Implementation Notes:**
- Effort: Low (packaging configuration)
- Key: Strict discipline not to import pydantic in ontos.core (E)

---

### Q11: Script Reorganization Approach

**Founder Lean:** Gut says needed, wants LLM input on approach

| Aspect | A | B | C | D | E |
|--------|---|---|---|---|---|
| **Recommendation** | Option A | Option A | Option A | Option A | Option A |
| **Confidence** | High | High | High | High | High |
| **Philosophy** | Aligns | Aligns | Aligns | Aligns | Aligns |
| **Complexity** | High | Medium | High | High | High |

**Consensus Level:** 5/5 Unanimous - Option A (Explicit planning)

**Recommendation Breakdown:**
- Option A (Explicit planning): 5 votes (A, B, C, D, E)

**Key Reasoning Summary:**
- **For Option A:** 1,625-line God Script won't fix itself. Pip packaging is the perfect opportunity. Define stable modules: core logic, io/filesystem, rendering, CLI wiring. Organic reorganization (Option B) preserves debt. Option C is worst — packages the mess.

**Suggested Structure (C):**
```
ontos/
├── core/           # Pure functions, no I/O
│   ├── schema.py
│   ├── graph.py
│   ├── staleness.py
├── commands/       # CLI implementations
├── ui/             # Output formatting
└── mcp/            # Optional MCP layer
```

**Dissent from Founder Lean:** None — unanimous agreement with founder intuition.

**Implementation Notes:**
- Effort: 1-2 weeks (consensus)
- Risk: Regression bugs (all); need solid test coverage (B, C)
- Key insight: D notes "This is the foundation. Without it, v3.0 is just a messy wrapper."

---

### Q12: Python vs Node/TS for MCP

**Founder Lean:** Should we even consider changing from Python?

| Aspect | A | B | C | D | E |
|--------|---|---|---|---|---|
| **Recommendation** | Option A | Option A | Option A | Option A | Option A |
| **Confidence** | High | High | High | High | High |
| **Philosophy** | Aligns | Aligns | Aligns | Aligns | Aligns |
| **Complexity** | Low | N/A | N/A | Low | Low |

**Consensus Level:** 5/5 Unanimous - Option A (Stay with Python)

**Recommendation Breakdown:**
- Option A (Stay Python): 5 votes (A, B, C, D, E)

**Key Reasoning Summary:**
- **For Option A:** One codebase, one mental model. MCP Python SDK is official and maintained. 11,500 lines of working Python; rewrite is months for zero new functionality. Split codebase (Option B) doubles maintenance. "Second-class citizen" concern overstated — protocol is language-agnostic.

**Dissent from Founder Lean:** None — founder asked if worth considering. Unanimous "no."

**Implementation Notes:**
- Effort: None (status quo)
- Risk: If Python MCP tooling truly lags, thin adapter possible later (A)

---

### Q13: JSON vs Markdown as Primary Output

**Founder Lean:** Leaning B (Markdown primary); "readable, not retrievable" is core philosophy

| Aspect | A | B | C | D | E |
|--------|---|---|---|---|---|
| **Recommendation** | Option B | Option B | Option B | Option B | Option B |
| **Confidence** | High | High | High | High | High |
| **Philosophy** | Aligns | Aligns | Aligns strongly | Critical alignment | Aligns |
| **Complexity** | Low | N/A | N/A | Low | Low |

**Consensus Level:** 5/5 Unanimous - Option B (Markdown primary)

**Recommendation Breakdown:**
- Option B (Markdown primary, JSON optional): 5 votes (A, B, C, D, E)

**Key Reasoning Summary:**
- **For Option B:** "Readable, not retrievable" is THE core philosophy. Markdown is readable; JSON is retrievable. JSON export (Q1) provides programmatic access. Git diffs of Markdown are readable; JSON diffs are noise. Humans and agents can inspect Markdown directly.

**Dissent from Founder Lean:** None — unanimous agreement with founder intuition.

**Implementation Notes:**
- Effort: None (current approach)
- Risk: If JSON becomes "more complete" than Markdown, philosophy inverts (A)

---

## 4. Cross-Cutting Concerns

### 4a. Interdependencies Map

| Dependency | Flagged By | Nature |
|------------|------------|--------|
| **Q11 is foundation for Q3, Q9** | D | "You cannot implement slicing or security until God Script is modularized" |
| **Q3 and Q8 are same design effort** | A | "Context slicing and lightweight slicing are one problem" |
| **Q6 and Q5 reinforce each other** | A | "Shim hooks safer if version pinning exists" |
| **Q1 enables Q9** | C | "JSON is how MCP communicates; having JSON makes MCP tools trivial" |
| **Q13 assumes Q1** | A | "JSON export only, not dual truth" |
| **Q1 (JSON) and Q10 (Pydantic) linked** | D | "If pydantic adopted, Q1 is trivial (model.model_dump_json())" |
| **Q4 should follow Q11** | C | "If reorganize first, you'll know where file-watching logic belongs" |
| **Q7 depends on MCP being implemented** | B | "Auto-config deferred with MCP anyway" |

### 4b. Priority Recommendations

| Priority | A | B | C | D | E |
|----------|---|---|---|---|---|
| **#1** | Q11 (Script reorg) | Q11 (Script reorg) | Q11 (Script reorg) | Q11 (Script reorg) | Q11 (Script reorg) |
| **#2** | Q4 (Git-based detect) | Q1 (JSON output) | Q1 (JSON output) | Q5 (Version pinning) | Q6 (Shim hooks) |
| **#3** | Q1 (JSON output) | Q6 (Shim hooks) | Q6 (Shim hooks) | Q6 (Shim hooks) | Q1 (JSON output) |

**Top 3 by Frequency:**
1. **Q11 (Script reorganization):** 5/5 — Every LLM ranks as #1
2. **Q6 (Shim hooks):** 4/5 — B, C, D, E mention in top 3
3. **Q1 (JSON output):** 4/5 — A, B, C, E mention in top 3

**Rationale (B):** "These three improve the foundation without adding features. They align with 'v3.0 is Distribution & Polish release.'"

### 4c. Risk Flags

| Risk | Flagged By | Severity |
|------|------------|----------|
| **Messy migration path** — Config + script injection to global CLI needs deterministic upgrade | A | High |
| **Documentation debt** — Users won't see scripts; how do they learn? Need updated README, helpful `--help` | B | Medium |
| **Over-engineering for imaginary users** — 5-LLM process surfaced features for multi-user/enterprise you don't have | C | Medium |
| **Testing void** — Moving to pip package means bugs break everyone; need integration test suite | D | High |
| **Hidden state risk** — v2 let users fix broken scripts; v3 hides logic, users stuck if crashes | E | Medium |

### 4d. Philosophy Violations

| Concern | Flagged By | Principle at Risk | Details |
|---------|------------|-------------------|---------|
| **Pydantic as core dep** | D | "Lightweight" / "Zero-dep" | D argues zero-dep is "vanity metric"; 4 others disagree |
| **Magic defaults vs curation** | B | "Curation over ceremony" | Magic defaults reduce ceremony but also reduce curation; resolution is progressive disclosure |
| **Tool-specific exports** | A | "Universal format" | Template-driven exports can conflict with universality if they become first-class |
| **Context slicing over-abstraction** | A | "Readable" | Compact map must remain readable on its own; expansion must be explicit |
| **Detect-and-flag (Q4)** | B, C | "Curation over ceremony" | Auto-detection subtly undermines human judgment; creates accuracy expectations |

---

## 5. Decision-Ready Summary

### Strong Consensus (5/5 agree on same option)

| Question | Recommended Option | Founder Lean | Action |
|----------|-------------------|--------------|--------|
| **Q1: JSON Output** | Option A (Add now) | Uncertain | ✅ Implement |
| **Q6: Shim Hooks** | Option A (Implement) | Sounds good | ✅ Implement |
| **Q11: Script Reorg** | Option A (Explicit planning) | Gut says yes | ✅ Implement |
| **Q12: Python vs Node** | Option A (Stay Python) | Should consider? | ✅ Stay Python |
| **Q13: JSON vs MD Primary** | Option B (Markdown primary) | Leaning B | ✅ Aligned |

### Strong Consensus (4/5 agree)

| Question | Recommended Option | Dissenter | Founder Lean | Action |
|----------|-------------------|-----------|--------------|--------|
| **Q8: Lightweight Slicing** | Option A (Progressive) | B | Achievable? | ✅ Implement (4/5 say achievable) |
| **Q9: MCP Security** | Option A (Defense-in-depth) | E | Detailed discussion | ✅ Plan for Option A |
| **Q10: Pydantic** | Option B (MCP layer only) | D | Option B/C | ✅ Aligned |

### Majority Agreement (3/5 agree)

| Question | Majority Option | Split | Founder Lean | Notes |
|----------|-----------------|-------|--------------|-------|
| **Q2: Export** | Option B (3) | A:1, Alt:1 | Skeptical (B) | ✅ Aligned with majority |
| **Q5: Version Pinning** | Option A (3) | B:2 | Uncertain | ⚠️ Consider warn-only compromise |
| **Q7: Auto-Config MCP** | Option B (3) | A:2 | Deferred | ✅ Deferred; docs when MCP ships |

### Split Decisions (No clear majority)

| Question | Distribution | Founder Lean | Recommendation |
|----------|--------------|--------------|----------------|
| **Q3: Context Slicing** | A:2, B:2, Alt:1 | Want direction | ⚠️ Defer per B/C; implement when needed |
| **Q4: Watchdog** | B:2, C:2, Alt:1 | Option C | ⚠️ Use git-based approach (A, D, E consensus); avoid watchdog library |

### Founder Lean Challenged

| Question | Founder Lean | LLMs Disagreeing | Core Argument Against |
|----------|--------------|------------------|----------------------|
| **Q2: Export** | Skeptical of tool-specific | C | "Export makes Ontos MORE universal — same source, multiple derived outputs. Not Claude-specific." |
| **Q4: Watchdog** | Option C (detect-and-flag) | B, C | "Detection creates expectations and accuracy requirements that subtly undermine 'curation over ceremony.'" |
| **Q10: Pydantic** | Option B/C (not core) | D | "'Zero-Dep' is vanity metric. Writing custom validation is technical debt, not lightweight engineering." |

---

## 6. Recommended Next Steps

Based on consensus and priorities, suggested implementation order for v3.0:

### Phase 1: Foundation (Must Do First)
1. **Q11: Script Reorganization** — 5/5 unanimous #1 priority. Enables everything else.

### Phase 2: Core v3.0 Features
2. **Q6: Shim Hooks** — 5/5 unanimous. Part of pip distribution story.
3. **Q1: JSON Output** — 5/5 unanimous. Low effort, high value.
4. **Q13: Keep Markdown Primary** — 5/5 unanimous. No action needed.
5. **Q12: Stay Python** — 5/5 unanimous. No action needed.

### Phase 3: Decisions Needed
6. **Q5: Version Pinning** — Consider warn-only compromise (A and C suggest)
7. **Q4: Watchdog** — If implementing, use git-based approach (3/5 suggest), NOT watchdog library
8. **Q2: Export** — Review C's dissent; decide if template approach (A) is middle ground

### Phase 4: Deferred (MCP Timeline)
9. **Q10: Pydantic** — MCP layer only when MCP ships
10. **Q9: MCP Security** — Plan for Option A when MCP ships
11. **Q7: Auto-Config** — Documentation when MCP ships
12. **Q3/Q8: Context Slicing** — Defer until needed; implement when token limits hit

---

## 7. Final Decisions Reference

**For all final decisions, roadmap, and implementation priorities, see:**

[`V3.0-Strategy-Decisions-Final.md`](V3.0-Strategy-Decisions-Final.md)

The Strategy Decisions document contains:
- Executive summary
- Final decisions table (Q1-Q13)
- Prioritized deliverables (Tier 1-5)
- Key dissent resolutions (summary)
- v3.x bridge features
- v4.0 future scope
- Reference documents

---

*Analysis document synthesized by Claude Opus 4.5 from 5 LLM Round 2 responses. 2026-01-10.*

