---
id: v3_3_track_b_adversarial_review
type: review
status: active
depends_on:
  - v3_3_track_b_implementation_spec
  - v3_3_track_a1_adversarial_review
  - v3_2_4_prea_consolidation
  - v3_2_4_discovery_content_report
concepts:
  - v3.3b
  - track-b
  - adversarial-review
  - body-parser
  - rename
  - link-check
---

# v3.3 Track B Adversarial Review

> **Reviewer:** Claude (Opus 4.6), Adversarial Role
> **Date:** 2026-02-11
> **Target:** `v3.3_Track_B_Implementation_Spec.md`
> **Round:** 1

---

## Verdict: Request Revision

The body-link parser's boundary character set (Section 4.3) produces false negatives for the most common reference pattern in documentation — IDs followed by sentence-ending punctuation. This single gap would cause `link-check` to miss real references and `rename` to leave stale IDs in body text. The spec must be revised to address this before implementation.

Additionally, the spec has a cross-scope reference blind spot that would cause `--scope docs` to report false broken links, and the pre-validation pipeline omits YAML reserved-word checking for `new_id`.

The spec is otherwise strong. The zone segmentation design, frontmatter patching strategy, unified scan migration matrix, and SessionContext integration are well-specified. The problems are localized and fixable.

---

## Spec Vulnerabilities

### Critical (Will Cause Implementation Failures)

#### CRIT-01 — BOUNDARY Set Produces False Negatives for Punctuation-Adjacent IDs

| Field | Detail |
|-------|--------|
| **Section** | 4.3 — Bare-ID Tokenization Rules (B1) |
| **Severity** | Critical — affects majority of real-world body references |

**What the spec says:**

```python
BOUNDARY = set([" ", "\t", "\n", "[", "]", "(", ")", "`", ","])
```

A match is valid only if: `start == 0 or text[start-1] in BOUNDARY` AND `end == len(text) or text[end] in BOUNDARY`.

**What would happen:**

The most natural way to reference an ID in documentation prose is in a sentence:

```
See v3_2_4_proposal.
The change is tracked in v3_2_4_proposal: details below.
| v3_2_4_proposal | active | 2026-02-10 |
Refer to v3_2_4_proposal; also see the design doc.
Is this described by v3_2_4_proposal?
```

In EVERY case above, the character immediately after the ID (`.`, `:`, `|`, `;`, `?`) is **not** in `BOUNDARY`. The parser returns **no match** for all of these.

Tested against real library data: 361 of 376 IDs use underscores as separators and would commonly appear before sentence punctuation. The Ontos Manual (`docs/reference/Ontos_Manual.md`) contains bare ID references in prose — these would be missed.

**The core tension:** The dot character `.` appears inside one actual ID (`v3.0.4_Code_Review_Claude`), so it cannot be added to `BOUNDARY` without creating false positives. But `.` as sentence punctuation after IDs is the most common case.

**Suggested spec addition:**

Replace the whitelist BOUNDARY approach with a two-tier rule:

1. **Hard boundaries** (always valid): whitespace, `[`, `]`, `(`, `)`, `` ` ``, `,`, start/end of text.
2. **Punctuation boundaries** (valid as trailing boundary only): `.`, `:`, `;`, `!`, `?`, `|`, `"`, `'`, `>`.
   - A punctuation boundary at position `end` is valid ONLY IF `end+1 == len(text)` OR `text[end+1]` is itself a hard boundary or whitespace.
   - This prevents `.` inside `v3.0.4_Code_Review_Claude` from being a boundary (because `.` is followed by `0`, which is not a boundary), while allowing `.` at sentence end (followed by space or EOL).

Alternatively, use the inverse formulation: a boundary is any character NOT in the set `[a-zA-Z0-9_-]`, with a special case for `.` requiring lookahead. This is the "ID-continuation character" approach.

**Required test vectors to add:**

| Text | Target | Expected | Rationale |
|------|--------|----------|-----------|
| `see v3_2_4_proposal.` | `v3_2_4_proposal` | Match | Sentence-ending period |
| `v3_2_4_proposal: details` | `v3_2_4_proposal` | Match | Colon separator |
| `\| v3_2_4_proposal \|` | `v3_2_4_proposal` | Match | Table cell |
| `v3_2_4_proposal; also` | `v3_2_4_proposal` | Match | Semicolon |
| `v3_2_4_proposal?` | `v3_2_4_proposal` | Match | Question mark |
| `v3.0.4_Code_Review_Claude.` | `v3.0.4_Code_Review_Claude` | Match | Dotted ID + sentence period |
| `v3.0.4_Code_Review_Claude.pdf` | `v3.0.4_Code_Review_Claude` | No match | Dot followed by letters |

---

#### CRIT-02 — Cross-Scope Reference Blind Spot

| Field | Detail |
|-------|--------|
| **Section** | 4.5 — Exit Code Logic; 3.1 — Default Behavior Contract |
| **Severity** | Critical — `--scope docs` produces false broken links |

**What the spec says:**

`build_graph()` receives the doc dict from the scoped loader. `--scope docs` loads only `docs/` directory documents.

**What would happen:**

Many `docs/` documents have `depends_on` referencing `.ontos-internal/` IDs:

- `v3_2_4_prea_consolidation` depends on `v3_2_4_prea_peer_review`, `v3_2_4_prea_adversarial_review` — all in `.ontos-internal/`
- `v3_3_track_b_implementation_spec` depends on `v3_3_release_plan`, `v3_3_track_a1_implementation_spec` — in `.ontos-internal/`

Under `--scope docs`, these target IDs are not loaded. `build_graph()` reports them as **broken links**. Exit code: **1**.

This means:
- `ontos link-check` (default `--scope docs`) would report dozens of "broken" references that are actually valid cross-scope references.
- Users would need `--scope library` to get an accurate report, defeating the purpose of the docs default.
- CI integration with exit code checks would be unusable at default scope.

**What the spec fails to say:**

No mention of cross-scope reference handling. No distinction between "target doesn't exist anywhere" and "target exists but is outside scan scope."

**Suggested spec addition:**

When `--scope docs` is active, perform a secondary lightweight ID scan of `.ontos-internal/` to build a "known external IDs" set. References to external IDs are classified as `external_reference` (informational, not broken) rather than `broken_reference`. Alternatively, add a `--strict` flag where external refs ARE reported, and make lenient the default.

Add to the JSON schema: `"external_references": [...]` section for cross-scope refs.

Add to exit code logic: external references alone do not trigger exit 1.

---

### Major (Could Cause Incorrect Behavior)

#### MAJ-01 — Pre-Validation Missing YAML Reserved Word Check for new_id

| Field | Detail |
|-------|--------|
| **Section** | 5.2 — Pre-Validation Pipeline |
| **Severity** | Major — silent data corruption on edge case |

**What the spec says:**

Six validation steps. None check whether `new_id` is a YAML reserved word.

**What would happen:**

`ontos rename old_doc true --apply` produces `id: true` in the target file. The raw patching writes this literally. On next YAML parse:

```yaml
id: true           # yaml.safe_load → {'id': True} (boolean, not string)
depends_on: [true]  # yaml.safe_load → {'depends_on': [True]}
```

The document's ID silently changes from string `"true"` to boolean `True`. `load_documents()` would then either:
- Crash during `normalize_type()` (expects string input, gets boolean)
- Produce `doc.id = True` (non-string) which breaks dict keying

YAML reserved words: `true`, `false`, `yes`, `no`, `null`, `on`, `off` (plus their uppercase/mixed-case variants under YAML 1.1).

Real ID analysis confirms no current IDs are reserved words, but nothing prevents a user from attempting this.

**Suggested spec addition:**

Add validation step 2.5 (between steps 2 and 3):

> Validate `new_id` is not a YAML reserved word (case-insensitive check against `true`, `false`, `yes`, `no`, `null`, `on`, `off`). If it is, abort with error: "new_id '{new_id}' is a YAML reserved word and would cause parse failures."

Also validate that `new_id` matches a reasonable ID format regex (alphanumeric, underscores, hyphens, dots). The codebase has `VALID_SLUG_PATTERN` at `types.py:124` for log slugs but no general ID validation — this is Track B's opportunity to establish one.

---

#### MAJ-02 — Raw Frontmatter Patching Does Not Specify .lstrip() Handling

| Field | Detail |
|-------|--------|
| **Section** | 5.3 — Frontmatter Update Strategy |
| **Severity** | Major — parser/patcher mismatch on edge case files |

**What the spec says:**

Step 1: "Split file into three parts only if frontmatter exists at file start."

**What the codebase does:**

`load_documents()` at `files.py:219` applies `.lstrip()` before parsing:

```python
content = raw_bytes.decode('utf-8', errors='replace').lstrip()
```

This means a file with leading whitespace + `---` is detected as having frontmatter during the load phase. But the raw patching in Section 5.3 reads the raw file — if it checks for `---` at position 0 without `.lstrip()`, it won't find frontmatter.

Result: The pre-validation phase says "this file has `old_id` in frontmatter," but the patching phase says "this file has no frontmatter." The ID goes unpatched.

**Suggested spec addition:**

Section 5.3, Step 1 should specify: "Read raw file bytes. Apply BOM stripping and `.lstrip()` consistent with canonical loader (`io/files.py:211-219`). Then split into three parts."

Or better: extract the raw-content preprocessing into a shared utility called by both `load_documents` and the frontmatter patcher.

---

#### MAJ-03 — Orphan Scope Semantics Unspecified

| Field | Detail |
|-------|--------|
| **Section** | 4.5 — Exit Code Logic |
| **Severity** | Major — ambiguous orphan classification |

**What the spec says:**

Exit code 2 for orphans. No specification of orphan scope.

**What would happen:**

`detect_orphans()` at `graph.py:147` finds documents with no incoming dependencies. If `--scope docs` excludes `.ontos-internal/` documents, then:

1. A `docs/` document whose only incoming reference is from `.ontos-internal/` appears as an orphan (the referencing doc is outside scope).
2. This inflates orphan count, potentially triggering exit 2 when the library is actually healthy.

Current library: The context map shows 237 orphans (40% of docs). Many of these may have references from `.ontos-internal/` that would resolve under `--scope library`.

**Suggested spec addition:**

State explicitly: "Orphan detection operates within the loaded document set. A document is orphan if no loaded document references it. When `--scope docs` is active, references from out-of-scope documents are not considered." Then note the practical implication: `--scope library` gives more accurate orphan counts.

This should also be reflected in the human output: "Note: orphan count may differ with --scope library."

---

#### MAJ-04 — Markdown Link Parsing Doesn't Handle Titles or Edge Cases

| Field | Detail |
|-------|--------|
| **Section** | 4.3 — Markdown Link Target Matching |
| **Severity** | Major — false positive match on title text |

**What the spec says:**

"Parse standard markdown links: `[label](target)`."

**What about:**

```markdown
[doc](v3_2_4_proposal "A proposal for maintenance")
```

Standard markdown allows titles in link syntax: `[text](url "title")`. If the parser extracts everything between `(` and `)` as the target, it gets `v3_2_4_proposal "A proposal for maintenance"` — which won't match any ID (safe, but loses the real reference).

If the parser splits on space to extract the URL portion, it works correctly for this case. But the spec doesn't specify the parsing algorithm for the `(...)` content.

**Other unmentioned link formats:**

| Format | Exists in Library? | Spec Coverage |
|--------|-------------------|---------------|
| `[text](target)` | Yes | Covered |
| `[text](target "title")` | Unknown | Not specified |
| `[text](target#anchor)` | Unknown | Partially (spec says "drop fragment after #") |
| `[text][ref]` ... `[ref]: target` | No | Not mentioned |
| `[[target]]` (wikilinks) | No (discussed, not used) | Not mentioned |
| `<autolink>` | No | Not mentioned |

**Suggested spec addition:**

Specify the `(...)` extraction regex explicitly. Something like:

```
target_regex = r'\[([^\]]*)\]\(([^)\s]+)(?:\s+"[^"]*")?\)'
```

And explicitly state: "Reference-style links (`[text][ref]`), wikilinks (`[[target]]`), and autolinks (`<target>`) are out of scope for v3.3 Track B body parsing."

---

#### MAJ-05 — link-check validate_all() vs Selective Validation Ambiguity

| Field | Detail |
|-------|--------|
| **Section** | 4.2 — Reference Detection |
| **Severity** | Major — developer won't know which validation path to use |

**What the spec says:**

- `impacts`/`describes`: uses `ValidationOrchestrator.validate_impacts()` and `validate_describes()` with severity override to `error`.
- "link-check does not claim concepts validation coverage (VUL-06 caveat)."

**The ambiguity:**

Does `link-check` call `validate_all()` (which includes concepts validation) or selectively call `validate_impacts()` + `validate_describes()` only?

If `validate_all()`: concepts warnings appear in output, contradicting the VUL-06 caveat.
If selective calls: the developer must know which `ValidationOrchestrator` methods to invoke and in what order.

`ValidationOrchestrator` at `validation.py` provides both `validate_all()` and individual `validate_impacts()`/`validate_describes()` methods. The spec should name the exact methods to call.

**Suggested spec addition:**

```
link-check calls:
1. ValidationOrchestrator.validate_impacts(doc, severity="error")
2. ValidationOrchestrator.validate_describes(doc, severity="error")

link-check does NOT call validate_all() or validate_concepts().
```

---

#### MAJ-06 — Duplicate ID Across Scope Boundaries

| Field | Detail |
|-------|--------|
| **Section** | 5.2 — Pre-Validation Pipeline, Step 4 |
| **Severity** | Major — rename may miss references in duplicate-shadowed files |

**What the spec says:**

Step 4: "No duplicate IDs in scope (load_result.duplicate_ids must be empty; B5)."

**What the codebase reveals:**

Real duplicate IDs exist: `v3_1_0_implementation_spec` appears in 3 files (all in `.ontos-internal/strategy/v3.1/`). `v3_2_code_review_claude` appears in 2 different proposal directories.

Under `--scope library`, these duplicates would block rename. Under `--scope docs`, they might not be visible (all are in `.ontos-internal/`).

But what if `old_id` is a duplicate? Step 2 says "old_id exists exactly once." Under `--scope docs`, a document with a duplicated ID might appear once (if only one copy is in `docs/`). Rename proceeds, updating that one file. But the duplicate in `.ontos-internal/` is untouched. All references to `old_id` in `.ontos-internal/` now point to a document that still has `old_id`, creating a split-brain.

**Suggested spec addition:**

When `--scope docs` is active and `old_id` exists exactly once within scope, perform a lightweight secondary check: does `old_id` exist in `.ontos-internal/`? If yes, warn: "ID '{old_id}' also exists outside scan scope. Use --scope library for complete rename."

---

### Minor (Hardening)

#### MIN-01 — old_id == new_id Should Produce Friendly Message

| Field | Detail |
|-------|--------|
| **Section** | 5.2 — Pre-Validation Pipeline |
| **Severity** | Minor — confusing error message |

Step 2 passes (old_id exists). Step 3 fails ("new_id already exists") because new_id = old_id. The error message is technically correct but confusing.

**Suggested:** Add explicit check: if `old_id == new_id`, exit with "old_id and new_id are identical; nothing to rename."

---

#### MIN-02 — extract_doc_ids_from_text() Supersession Not Documented

| Field | Detail |
|-------|--------|
| **Section** | 4.3 (body parser) vs existing `suggestions.py:152` |
| **Severity** | Minor — implementer confusion |

`extract_doc_ids_from_text()` at `suggestions.py:152` uses naive substring matching (`doc_id.lower() in text_lower`). The new body parser uses strict boundary matching. These produce different results for the same input. The spec doesn't state whether the new parser supersedes, complements, or replaces the existing function.

**Suggested:** Add note: "`extract_doc_ids_from_text()` in `suggestions.py` is not used by link-check or rename body scanning. It remains available for low-precision heuristic use (e.g., log commit message matching) but is not part of the Track B reference detection contract."

---

#### MIN-03 — SessionContext.commit() Return Value Cross-Check

| Field | Detail |
|-------|--------|
| **Section** | 5.6 — Apply Behavior |
| **Severity** | Minor — missed sanity check |

`SessionContext.commit()` returns `List[Path]` of modified files. The spec says "execute ctx.commit() once" but doesn't specify cross-checking the returned list against the plan.

**Suggested:** After `commit()`, verify `len(modified_paths) == len(planned_files)`. If mismatch, warn user.

---

#### MIN-04 — Indented Code Blocks Not Handled by Zone Segmentation

| Field | Detail |
|-------|--------|
| **Section** | 4.3 — Pass 1: Zone Segmentation |
| **Severity** | Minor — edge case false positive |

Zone segmentation handles fenced code blocks (`` ``` ``, `~~~`) and inline code (backticks) but not indented code blocks (4+ leading spaces per CommonMark). Content in indented code blocks would be classified as `normal_text` and eligible for matching/rewriting.

From codebase analysis: the Manual has indented content, but mostly inside fenced blocks. Standalone indented code blocks are rare. Risk is low.

**Suggested:** Add note: "Indented code blocks (4+ spaces) are not detected as code zones. This is an accepted limitation; IDs in indented code blocks are treated as normal text."

---

#### MIN-05 — Spec References Removed hasattr Guards

| Field | Detail |
|-------|--------|
| **Section** | 9 — Architectural Constraints |
| **Severity** | Minor — stale instruction |

The spec says: "If touching graph.py/suggestions.py, remove or justify residual hasattr(...) checks per VUL-07 decision."

But VUL-07 was resolved in A1 hardening (Round 3, item 4: PASS). The hasattr guards at `graph.py:76` and `suggestions.py:213` are already removed. The implementer will look for them and find nothing.

**Suggested:** Update to: "VUL-07 hasattr guards were removed in A1 hardening. No action needed."

---

#### MIN-06 — history.py Legacy Parser Interaction

| Field | Detail |
|-------|--------|
| **Section** | 9 — Dependencies and Constraints |
| **Severity** | Minor — not blocking but worth noting |

A1 adversarial review Round 3 found OBS-04: `history.py` is the last active caller of legacy `parse_frontmatter()`. If rename modifies files that `history.py` later reads (e.g., log files with `depends_on` pointing to renamed IDs), the legacy parser would produce the same result (the YAML content is the same). No functional issue, but the spec should note this as a known legacy-parser consumer that is NOT migrated.

---

## A1 Finding Incorporation Matrix

| A1 Finding | Should Affect Track B? | Addressed in Spec? | Notes |
|-----------|----------------------|-------------------|-------|
| VUL-01: validate_concepts() unhashable crash | Only if link-check calls validate_all() | **Partially** — spec says "does not claim concepts validation" (4.2) but doesn't specify whether validate_all() is called | See MAJ-05. If link-check avoids validate_all(), VUL-01 is not exercised. Spec must be explicit. |
| VUL-02: normalize_describes() drop/keep inconsistency | Yes — rename reads describes field post-normalization | **Yes** — describes is normalized during load before rename sees it. The asymmetry comment (OBS-02 fix) documents the design. | No issue. |
| VUL-03: has_fatal_errors universal duplicate treatment | Yes — link-check/rename must use duplicate_ids directly | **Yes** — Section 9: "Do not rely on has_fatal_errors for duplicate severity decisions." Section 5.2 Step 4 uses duplicate_ids. | Correctly addressed. |
| VUL-04: .lstrip() frontmatter boundary change | Yes — affects rename raw patching | **Partially** — .lstrip() is documented as intentional, but Section 5.3 raw patching doesn't specify .lstrip() preprocessing. | See MAJ-02. Patcher could miss frontmatter in files with leading whitespace. |
| VUL-06: Vocabulary check no-op | Yes — link-check shouldn't claim concepts validation | **Yes** — Section 4.2: "does not claim concepts validation coverage (VUL-06 caveat)." | Correctly addressed. |
| VUL-05: maintain.py no fatal check | Indirectly — maintain routes through shared diagnostics | **Yes** — Section 4.6 specifies maintain task uses shared `link_diagnostics.py`. | Correctly addressed. |
| VUL-07–12: Hardening items | Only VUL-07 referenced | **Stale** — spec references VUL-07 as unresolved, but A1 Round 3 resolved it. | See MIN-05. |
| OBS-04: history.py legacy caller | Minor interaction | **Not addressed** | See MIN-06. |

---

## Test Vector Assessment

### Body Parser Test Corpus (Section 7)

The spec lists 10 test categories. Assessment:

| # | Category | Adequate? | Gap |
|---|---------|-----------|-----|
| 1 | bare token in plain text | Yes | |
| 2 | token in code fence | Yes | |
| 3 | token in inline code | Yes | |
| 4 | markdown link target internal | Yes | |
| 5 | markdown link target external URL | Yes | |
| 6 | line boundary/start/end | Yes | |
| 7 | prefix collision | Yes | |
| 8 | dot-containing ID | Yes | |
| 9 | escaped regex characters | Yes | |
| 10 | mixed links + bare tokens | Yes | |
| **11** | **ID followed by sentence punctuation (`.`, `:`, `;`, `?`, `!`)** | **MISSING** | **CRIT-01 gap** |
| **12** | **ID in markdown table cell (`\| id \|`)** | **MISSING** | **CRIT-01 gap** |
| **13** | **ID in blockquote (`> see id`)** | **MISSING** | `>` not in BOUNDARY |
| **14** | **Markdown link with title (`[text](id "title")`)** | **MISSING** | **MAJ-04 gap** |
| **15** | **Cross-scope reference (target outside scan scope)** | **MISSING** | **CRIT-02 gap** |
| **16** | **Nested code fence (`` ``` `` inside `` ```` ``)** | **MISSING** | Spec describes behavior but no test case |

### Rename-Specific Test Gaps

| Category | Specified? | Gap |
|---------|-----------|-----|
| YAML reserved word as new_id | No | MAJ-01 |
| old_id == new_id | No | MIN-01 |
| new_id contains regex metacharacters | No | Could create unmatchable ID for future renames |
| File with BOM + leading whitespace | No | MAJ-02 |
| Duplicate old_id across scope boundaries | No | MAJ-06 |

### Exit Code Test Gaps

| Scenario | Specified? |
|---------|-----------|
| 0 broken, 0 dupes, 5 orphans → exit 2 | Yes (truth table) |
| 1 broken AND 3 orphans → exit 1 | Yes (truth table) |
| Broken ref target exists outside scope → ??? | **Not specified** (CRIT-02) |
| Self-referential depends_on → circular severity | **Not specified** |
| Parse warnings only, no structural issues → exit 0 | Yes |

---

## Risk Assessment

### Highest Risk: Body Parser (Feature 2)

The body parser is the only genuinely new infrastructure and carries the most implementation risk. The BOUNDARY set gap (CRIT-01) is the primary concern — it would cause both `link-check` and `rename` to miss common reference patterns, undermining the core value proposition of both features.

**Where bugs will cluster:**
1. Boundary character edge cases (CRIT-01) — the most likely source of user-reported false negatives.
2. Zone segmentation with unusual backtick patterns — nested/unclosed backtick runs are tricky state machines.
3. Markdown link parsing with titles/anchors — the `(...)` content parsing is underspecified (MAJ-04).

### Second Highest Risk: Cross-Scope References (Feature 2 + Feature 1 interaction)

The scan scope unification (Feature 1) changes what documents are visible. The link-check command (Feature 2) validates references against visible documents. The interaction between these two features creates the cross-scope blind spot (CRIT-02) where valid references appear broken simply because the target is in a different scope tier.

### Moderate Risk: Rename Pre-Validation (Feature 3)

The pre-validation pipeline is well-structured but has specific gaps (MAJ-01, MAJ-02, MAJ-06). These are individually low-probability but the consequences of each are severe (data corruption, split-brain state).

### Lowest Risk: Unified Scan Scope (Feature 1)

The scan scope migration is well-specified with an exhaustive command matrix. The migration is mechanical — replace per-command root construction with shared utility calls. Risk is proportional to the number of commands touched (12+), but each change is small and testable in isolation.

---

## Codebase Verification

### Claims Verified Against Codebase

| Spec Claim | Verified? | Evidence |
|-----------|-----------|---------|
| `build_graph()` accepts `Dict[str, DocumentData]` and `severity_map` | **Yes** | `graph.py:52-55` — exact signature matches |
| `DocumentLoadResult.duplicate_ids` exists and tracks collisions | **Yes** | `files.py:38-47` — dict with first-wins policy |
| `SessionContext` supports buffered writes with two-phase commit | **Yes** | `context.py:132-202` — Phase 1 writes temps, Phase 2 renames |
| `ValidationOrchestrator` supports per-field severity overrides | **Yes** | `validation.py:91-94` — override mechanism confirmed |
| `suggest_candidates_for_broken_ref()` returns confidence scores | **Yes** | `suggestions.py:172-224` — returns `(doc_id, confidence, reason)` tuples |
| Canonical parser is `parse_frontmatter_content` in `io/yaml.py` | **Yes** | `yaml.py:44-74` — uses `yaml.safe_load`, returns `(dict, body)` |
| `serialize_frontmatter()` causes field reordering/comment stripping | **Yes** | `schema.py:295-333` — hand-built serializer with fixed field order, no comment preservation |

### Claims That Need Qualification

| Spec Claim | Issue | Evidence |
|-----------|-------|---------|
| "load_frontmatter() for single-file parse contract" (Section 9) | `load_frontmatter()` at `files.py:136-164` does NOT apply `.lstrip()`, while `load_documents()` at `files.py:219` does | MAJ-02: patcher must match canonical loader's preprocessing |
| "SessionContext-based buffered apply flow" | SessionContext Phase 2 is NOT truly atomic across multiple files — partial renames are possible | `context.py:174-184`: if file N+1 rename fails, files 1..N are already committed. Spec acknowledges this (5.6) correctly. |
| "detect_orphans" in graph.py | `detect_orphans()` at `graph.py:147` accepts `allowed_orphan_types` parameter — spec doesn't specify what types link-check should allow | Currently `map` passes config value `allowed_orphan_types = ["atom"]`. Link-check should match. |
| Commands "currently scan" per migration matrix | Verified: `query` and `verify` scan from root (confirmed at `query.py:33-40`, `verify.py:33-35`). `scaffold` has two scan modes (root in `find_untagged_files`, docs in command). `consolidate` uses `Path.glob()` directly, not `scan_documents()`. | Matrix is accurate but `consolidate` exclusion note should mention it uses a different scan API entirely. |

### Infrastructure That Does NOT Exist Yet

| Item | Spec Assumes | Reality |
|------|-------------|---------|
| `ontos/io/scan_scope.py` | New module | Does not exist — must be created |
| `ontos/core/body_refs.py` | New module | Does not exist — must be created |
| `ontos/core/link_diagnostics.py` | New module | Does not exist — must be created |
| `ontos/commands/link_check.py` | New command | Does not exist — must be created |
| `ontos/commands/rename.py` | New command | Does not exist — must be created |
| `ScanningConfig.default_scope` | New config field | Does not exist — `config.py:56` has `scan_paths` but no `default_scope` |
| rename command CLI registration | New entry | No `_register_rename` in `cli.py` |
| link-check command CLI registration | New entry | No `_register_link_check` in `cli.py` |

All of these are expected for new feature specs. No infrastructure is missing that the spec claims already exists.

---

## Summary of Required Revisions

| # | Priority | Item | Section |
|---|---------|------|---------|
| 1 | **P0** | Expand BOUNDARY set or replace with context-aware boundary detection | 4.3 |
| 2 | **P0** | Specify cross-scope reference handling for link-check | 4.2, 4.5 |
| 3 | **P1** | Add YAML reserved word validation for new_id | 5.2 |
| 4 | **P1** | Specify .lstrip() handling in raw frontmatter patcher | 5.3 |
| 5 | **P1** | Specify orphan scope semantics explicitly | 4.5 |
| 6 | **P1** | Specify markdown link title handling | 4.3 |
| 7 | **P1** | Specify validate_all() vs selective validation for link-check | 4.2 |
| 8 | **P2** | Add cross-scope duplicate detection for rename | 5.2 |
| 9 | **P2** | Add missing test vectors (punctuation, tables, titles) | 7 |
| 10 | **P2** | Update stale VUL-07 reference | 9 |

Items 1-2 are revision blockers. Items 3-7 should be addressed before implementation. Items 8-10 can be addressed during implementation.
