---
id: v3_3_track_b_implementation_spec_v2
type: strategy
status: draft
depends_on:
  - v3_3_release_plan
  - v3_3_track_a1_implementation_spec
  - v3_3_track_a1_adversarial_review
  - v3_2_4_prea_consolidation
  - v3_3b_track_b_kickoff
concepts:
  - v3.3b
  - track-b
  - implementation-spec
  - scan-scope
  - link-check
  - rename
---

# v3.3 Track B Implementation Spec (v2)

## 1. Overview

Track B delivers three features in strict dependency order:

1. Unified scan scope infrastructure (`docs` default, `library` opt-in) and migration of all scanning commands to this shared utility.
2. `ontos link-check` as a standalone, read-only referential-integrity diagnostic.
3. `ontos rename <old_id> <new_id>` as an atomic, dry-run-first ID rename engine.

Implementation order:

1. Shared scan utility + CLI `--scope` wiring (foundation).
2. Shared body-reference parser (highest-risk new infra).
3. Link diagnostics core + `link-check` command.
4. Rename planner + targeted frontmatter patching + apply path.
5. Maintain task 7 migration to shared diagnostics.

Risk level:

- Feature 1: Medium (broad command touch surface, low algorithmic risk).
- Feature 2: High (body parser false positives/false negatives).
- Feature 3: High (bulk rewrite safety, frontmatter patch precision, atomicity failure modes).

Estimated change volume (code + tests + docs): ~1.7k-2.4k LOC.

## 2. Scope

### In Scope

- [x] Shared scan scope utility with `docs|library` and command migration.
- [x] `--scope` flag on all document-scanning commands.
- [x] New `ontos link-check` command with human + JSON output.
- [x] Link diagnostics across frontmatter fields (`depends_on`, `impacts`, `describes`) and body references.
- [x] Duplicate-ID reporting via `DocumentLoadResult.duplicate_ids`.
- [x] Orphan detection and exit-code semantics `0/1/2` (S1).
- [x] Suggestion confidence integration via `core/suggestions.py`.
- [x] Shared body parser module used by both link-check and rename (B2).
- [x] New `ontos rename` command with dry-run default and `--apply`.
- [x] Targeted frontmatter updates without `serialize_frontmatter()` round-trip (S3).
- [x] SessionContext-based buffered apply flow.
- [x] Post-apply stale-artifact warning (S5 exact text).
- [x] Maintain task 7 routed through shared link diagnostics.

### Out of Scope

- Obsidian source migration or source-link format rewrite (`--obsidian` source conversion): excluded, unrelated to Track B feature contract.
- File or directory moves/renames on disk: excluded; Track B is ID/reference rewrite only.
- External URL reachability checks (`http(s)` link validation): excluded; diagnostics are internal reference integrity only.
- `doctor --repair`: excluded; belongs to separate backlog item and not Track B deliverables.
- Carry-forward A2 items (`#15`, `#28`): deprecation warnings for legacy archive/decision-history paths and `proposals.py` path resolution are explicitly excluded from Track B.

## 3. Feature 1: Unified Scan Scope

### 3.1 Shared Scan Utility Design

#### Module Location

Create: `ontos/io/scan_scope.py`

#### Types

```python
from dataclasses import dataclass
from enum import Enum
from pathlib import Path
from typing import List, Optional

class ScanScope(str, Enum):
    DOCS = "docs"
    LIBRARY = "library"

@dataclass(frozen=True)
class ScanScopePlan:
    scope: ScanScope
    roots: List[Path]
    skip_patterns: List[str]
```

#### Public Functions

```python
def resolve_scan_scope(
    cli_scope: Optional[str],
    config_default_scope: Optional[str],
) -> ScanScope:
    """Priority: CLI flag > config default > docs."""


def build_scope_roots(
    repo_root: Path,
    config: OntosConfig,
    scope: ScanScope,
) -> List[Path]:
    """docs: docs_dir + config.scanning.scan_paths; library: docs roots + .ontos-internal."""


def collect_scoped_documents(
    repo_root: Path,
    config: OntosConfig,
    scope: ScanScope,
    *,
    base_skip_patterns: Optional[List[str]] = None,
    extra_skip_patterns: Optional[List[str]] = None,
    explicit_dirs: Optional[List[Path]] = None,
) -> List[Path]:
    """
    If explicit_dirs is provided, scope roots are bypassed (explicit wins).
    Uses io/files.py:scan_documents for actual traversal.
    """
```

#### Config + CLI Resolution

Add `default_scope` to `ScanningConfig` in `ontos/core/config.py`:

```python
@dataclass
class ScanningConfig:
    skip_patterns: List[str] = ...
    scan_paths: List[str] = ...
    default_scope: str = "docs"
```

Resolution precedence:

1. `--scope` CLI flag (if supplied).
2. `.ontos.toml` `[scanning].default_scope` (if valid and present).
3. hard default: `docs`.

Allowed values: `docs`, `library`.
Invalid config values: warn once and fallback to `docs`.

#### Default Behavior Contract

Canonical definitions:

- `docs` scope: `repo_root / config.paths.docs_dir` + each configured `config.scanning.scan_paths`.
- `library` scope: `docs` scope + `repo_root / ".ontos-internal"`.

This codifies B4 and removes per-command custom root derivation.

### 3.2 Command Migration Matrix

The matrix below is exhaustive for commands that currently scan markdown documents (directly or via snapshot).

| Command | Current Scan Pattern | New Pattern | `--scope` Flag Added? | Behavioral Change? |
|---------|----------------------|-------------|-----------------------|--------------------|
| `map` | `docs_dir + config.scanning.scan_paths`; skip config + context map path | `collect_scoped_documents(..., scope, base_skip=config.scanning.skip_patterns, extra_skip=[context_map])` | Yes | No for default `docs`; output parity maintained |
| `maintain` (tasks using `_scan_docs`) | same as `map` (`docs_dir + scan_paths`) | same shared utility; `_scan_docs` becomes wrapper around `collect_scoped_documents` | Yes | No for default `docs` |
| `query` | scans `root` (or `--dir`) + `.ontosignore` | when `--dir` omitted: shared scope roots + `.ontosignore`; when `--dir` supplied: explicit dir wins | Yes | Yes: default narrows to `docs` per B4; use `--scope library` for prior broad behavior |
| `verify` | scans `root` + `.ontosignore` | shared scope roots + `.ontosignore` | Yes | Yes: default narrows to `docs` per B4 |
| `scaffold` (default mode) | mixed patterns: root scan in `find_untagged_files`; docs/logs scan in command | default uses shared scope roots; explicit `paths` still bypass scope | Yes | Minor normalization: no root-wide implicit scan unless `--scope library` |
| `promote` | default `docs + .ontos-internal` (or root fallback), `.ontosignore` | shared scope roots + `.ontosignore`; explicit `files` bypass scope | Yes | Yes for default: now `docs`; `--scope library` restores old breadth |
| `schema-migrate` (`ontos schema-migrate`) | default `docs + .ontos-internal`; optional `--dirs` override | shared scope roots by default; explicit `--dirs` override unchanged | Yes | Yes for default breadth, by design (B4) |
| `agents` | `docs_dir`, `logs_dir`, and optional `.ontos-internal/archive/logs` | shared scope roots for doc census + explicit logs sources for last-log stats | Yes | No for AGENTS generation semantics; doc-count source standardized |
| `export data` | indirect via `io/snapshot.py` (`docs + .ontos-internal`) | `create_snapshot(..., scope=...)` -> shared scope roots | Yes | Default becomes `docs`; `--scope library` for full-library export |
| `migration-report` | indirect via `io/snapshot.py` (`docs + .ontos-internal`) | `create_snapshot(..., scope=...)` -> shared scope roots | Yes | Default becomes `docs`; `--scope library` for prior behavior |
| `migrate` (convenience) | indirect via `export data` + `migration-report` | passes scope through to both child calls | Yes | Mirrors export/report behavior |
| `doctor` (checks 4/6) | `docs_dir.rglob("*.md")` directly | uses shared scope utility for markdown discovery in checks 4/6 | Yes | Default unchanged for docs; `--scope library` optional broader health scan |
| `link-check` (new) | N/A | shared scope utility | Yes | New command |
| `rename` (new) | N/A | shared scope utility | Yes | New command |

Notes:

- Explicit path/dir arguments continue to override scope for commands that already support explicit targeting (`query --dir`, `schema-migrate --dirs`, `scaffold paths`, `promote files`).
- Consolidate is not in this matrix: it is log-retention over a resolved logs directory, not graph/library scan scope.

### 3.3 CLI Registration

#### Registration Strategy

`--scope` is command-shared, not global-all-command.

Implement helper in `ontos/cli.py`:

```python
def _add_scope_argument(parser):
    parser.add_argument(
        "--scope",
        choices=["docs", "library"],
        default=None,
        help="Scan scope: docs (default) or library (includes .ontos-internal)",
    )
```

Invoke `_add_scope_argument(...)` in subparser registration for every command in the migration matrix.

#### Option Plumbing

Add `scope: Optional[str] = None` to each affected command options dataclass.
Handlers pass scope through unchanged; resolution happens in command-layer logic via `resolve_scan_scope(...)`.

### 3.4 Backward Compatibility

Compatibility commitments:

- No behavior change for commands already using docs-root semantics (`map`, `maintain`).
- Defaults are intentionally unified to `docs` per B4; commands that previously scanned broader roots preserve old breadth through explicit `--scope library`.
- Existing users who never pass `--scope` and operate within `docs` observe identical behavior.

### 3.5 Scope Migration Notes

User-facing migration guidance (must be included in release notes and command help updates):

- Previous broad query behavior:
  - old: `ontos query --health` (root scan)
  - new equivalent: `ontos query --health --scope library`
- Previous broad verify behavior:
  - old: `ontos verify --all` (root scan)
  - new equivalent: `ontos verify --all --scope library`
- Previous promote defaults (`docs + .ontos-internal`):
  - new: `ontos promote --scope library`
- Previous export/report defaults (`docs + .ontos-internal` through snapshot):
  - new: `ontos export data --scope library`
  - new: `ontos migration-report --scope library`
- Previous schema migrate defaults (`docs + .ontos-internal`):
  - new: `ontos schema-migrate --check --scope library`

Behavioral compatibility statement:

- Default narrowing is intentional per B4 and not treated as regression.
- Restoring previous breadth is always possible with `--scope library`.

## 4. Feature 2: `ontos link-check`

### 4.1 Command Interface

Create: `ontos/commands/link_check.py`

#### CLI

```text
ontos link-check [--scope {docs,library}] [--json] [--quiet]
```

#### Flags

- `--scope`: optional; resolved via shared scope utility.
- `--json`: emit structured machine-readable report.
- `--quiet`: suppress section-by-section informational output in human mode; still prints fatal diagnostics and final status line.

#### Help Text

- Summary: `Validate internal document references (frontmatter + body), duplicates, and orphans.`
- Scope help: `Scan scope: docs (default) or library (includes .ontos-internal).`

### 4.2 Reference Detection

`link-check` detects references from two sources.

#### A. Frontmatter References

Fields:

- `depends_on`
- `impacts`
- `describes`

Infrastructure usage:

- Load: `io/files.py:load_documents(...)` with `parse_frontmatter_content` (S4).
- Duplicates: `DocumentLoadResult.duplicate_ids` (B5).
- Graph/broken depends_on/orphans: `core/graph.py` (`build_graph`, `detect_orphans`).
- `impacts`/`describes`: selective calls to `ValidationOrchestrator.validate_impacts(severity="error")` and `validate_describes(severity="error")`.
- Suggestions: `core/suggestions.py:suggest_candidates_for_broken_ref(...)` for each broken reference.

Important operational constraint:

- `link-check` does **not** call `validate_all()` and does **not** call `validate_concepts()` (VUL-06 caveat).
- `link-check` uses normalized fields from `DocumentData` (`depends_on`, `impacts`, `describes`) produced by `load_documents()`; no local re-normalization is permitted.
- Required severity wiring for link-check:

```python
link_check_severity = {
    "broken_link": "error",
    "depends_on": "error",
    "impacts": "error",
    "describes": "error",
}
```

#### B. Body References

Detected via shared parser module (Section 4.3):

- Markdown link targets (internal-reference subset only).
- Bare ID tokens (exact token semantics used by rename engine, B1/B2).

Broken body references are body candidates whose normalized ID is absent from loaded document IDs.

#### C. Cross-Scope External References (`--scope docs`)

To avoid false broken-link reports when `docs/` references `.ontos-internal/` IDs:

1. When effective scope is `docs`, run a secondary lightweight scan over `.ontos-internal/` (if present).
2. Build:
   - `external_ids`: IDs defined outside active scope.
   - `external_depends_on_index`: flattened set of IDs referenced by external documents' `depends_on`.
3. Classify any unresolved reference in docs scope as:
   - `external_reference` (info) if target is in `external_ids`.
   - `broken_reference` (error) if target is not in `active_ids` and not in `external_ids`.

External references are reported explicitly and do not contribute to broken-reference exit code.

#### D. Parse-Failure Raw-Scan Semantics

For files skipped by canonical parsing (`parse_error`/`io_error`), link-check still runs a bounded raw scan to avoid silent blind spots:

1. Read bytes, strip UTF-8 BOM if present, decode using UTF-8 `errors="replace"`.
2. Run `scan_body_references(..., rename_target=None, known_ids=active_ids | external_ids, include_skipped=True)` against the full decoded text.
3. Emit findings as `parse_failed_candidates` (informational only).

`parse_failed_candidates` are not treated as broken references and do not affect exit code, but are included in human/JSON output for operator follow-up.

### 4.3 Shared Body-Link Parser Design

This is the primary new infrastructure and is shared by `link-check` and `rename` (B2).

#### Module Location

Create: `ontos/core/body_refs.py`

#### Public API

```python
from dataclasses import dataclass
from enum import Enum
from pathlib import Path
from typing import List, Optional

class ZoneType(str, Enum):
    NORMAL_TEXT = "normal_text"
    INLINE_CODE = "inline_code"
    CODE_FENCE = "code_fence"

class MatchType(str, Enum):
    MARKDOWN_LINK_TARGET = "markdown_link_target"
    BARE_ID_TOKEN = "bare_id_token"

@dataclass(frozen=True)
class BodyReferenceMatch:
    path: Path
    line: int                  # 1-based
    col_start: int             # 1-based
    col_end: int               # inclusive
    zone: ZoneType
    match_type: MatchType
    raw_match: str
    normalized_id: str
    line_text: str
    context_before: str
    context_after: str
    rewritable: bool           # False for skipped zones
    skip_reason: Optional[str] = None
    abs_start: int = 0         # offset into body string
    abs_end: int = 0

@dataclass(frozen=True)
class BodyReferenceScan:
    matches: List[BodyReferenceMatch]
    scanned_lines: int
```

Scanner entry points:

```python
def scan_body_references(
    path: Path,
    body: str,
    *,
    context_lines: int = 1,
    rename_target: Optional[str] = None,
    known_ids: Optional[set[str]] = None,
    include_skipped: bool = True,
) -> BodyReferenceScan
```

Mode behavior:

- `rename_target` provided: emit only matches for that exact ID (plus skipped-zone sightings if `include_skipped=True`).
- `known_ids` provided without `rename_target`: emit all candidate references for link-check classification.

#### Parsing Strategy

Two-pass state machine over raw body text.

##### Pass 1: Zone Segmentation

State variables:

- `in_fence: bool`
- `fence_marker: str` (` ``` ` or `~~~`)
- `fence_len: int`

Fence rules:

1. Fence opener when line (after optional leading spaces) starts with a backtick/tilde run of length >=3.
2. While `in_fence`, all lines are `code_fence`.
3. Fence closes only when same marker type appears with run length >= opener length.
4. Nested fences are not interpreted; content remains code until matching close.
5. EOF rule: if closing fence is never found, treat remainder of file as `code_fence` (always skipped for rewrite).

Inline-code segmentation (only when not in code fence):

1. Scan backtick runs in a line.
2. Matching run length closes inline code of same run length.
3. Unclosed backticks leave remaining text in `normal_text` (no speculative skip).
4. Escaped backticks (`\``) are treated as literal characters.

Zones emitted per line/segment:

- `normal_text`: eligible for matching and rewriting.
- `inline_code`: detected, reported as skipped zone.
- `code_fence`: detected, reported as skipped zone.
- Indented code blocks (4+ spaces without fence markers) are treated as `normal_text` in v3.3 (explicit limitation, no hidden behavior).

##### Pass 2: Match Extraction

For each zone segment:

- If zone is `normal_text`, apply markdown-link and bare-token detection.
- If zone is skipped (`inline_code` or `code_fence`), only detect rename-target sightings for dry-run reporting (`rewritable=False`, skip reason set).

#### Bare-ID Tokenization Rules (B1)

Exact-match semantics are strict and shared by link-check/rename:

- Match must equal the full target ID.
- Valid boundaries before/after match are defined by two-tier boundary model below.
- No substring matches.
- IDs with regex metacharacters are escaped before matching.

Implementation rule (do not use `\b`):

```python
from typing import Optional

HARD_BOUNDARY = set([" ", "\t", "\n", "[", "]", "(", ")", "`", ","])
TRAILING_PUNCT_BOUNDARY = set([".", ":", ";", "!", "?", "|", "\"", "'", ">"])

def is_leading_boundary(ch: Optional[str]) -> bool:
    return ch is None or ch in HARD_BOUNDARY

def is_trailing_boundary(curr: Optional[str], next_ch: Optional[str]) -> bool:
    if curr is None:
        return True
    if curr in HARD_BOUNDARY:
        return True
    if curr in TRAILING_PUNCT_BOUNDARY:
        return next_ch is None or next_ch.isspace() or next_ch in HARD_BOUNDARY
    return False
```

A candidate occurrence at `[start:end]` is valid only if:

- `is_leading_boundary(text[start-1] if start > 0 else None)` is true
- `is_trailing_boundary(text[end] if end < len(text) else None, text[end+1] if end+1 < len(text) else None)` is true

##### Bare-ID Test Vectors

| Text | Target | Expected |
|------|--------|----------|
| `see v3_2 now` | `v3_2` | Match |
| `(v3_2)` | `v3_2` | Match |
| `` `v3_2` `` | `v3_2` | Skip (inline code zone) |
| `v3_2, next` | `v3_2` | Match |
| `v3_2.` | `v3_2` | Match |
| `v3_2: details` | `v3_2` | Match |
| `v3_2; also` | `v3_2` | Match |
| `v3_2?` | `v3_2` | Match |
| `| v3_2 |` | `v3_2` | Match |
| `> v3_2` | `v3_2` | Match |
| `v3_2.1` | `v3_2` | No match |
| `v3_2_foo` | `v3_2` | No match |
| `prefixv3_2` | `v3_2` | No match |
| `v3.0.4_Code_Review_Claude` | `v3.0.4_Code_Review_Claude` | Match (escaped literal dots) |
| `v3.0.4_Code_Review_Claude.` | `v3.0.4_Code_Review_Claude` | Match |
| `v3.0.4_Code_Review_Claude.pdf` | `v3.0.4_Code_Review_Claude` | No match |

#### Markdown Link Target Matching

Pattern detection in normal text segments:

- Supported inline forms:
  - `[label](target)`
  - `[label](<target>)`
  - `[label](target "optional title")`
  - `[label](target 'optional title')`
- Target parser for `(...)` content must support:
  - balanced parentheses in target path,
  - escaped closing paren (`\)`),
  - title stripping only after target parsing succeeds.
- Extract `target` only (label and title are not analyzed for references).
- Internal link target criteria:
  - no URI scheme (`http:`, `https:`, `mailto:`, etc.)
  - not anchor-only (`#...`)
  - not absolute filesystem path
- Normalize target to candidate ID:
  - strip surrounding `<...>` if present
  - drop fragment after `#`
  - if target ends in `.md`, remove extension
  - if target is a relative path, keep basename stem as candidate

Example:

- `[doc](v3_2_4_proposal)` -> `normalized_id=v3_2_4_proposal`
- `[manual](docs/reference/Ontos_Manual.md)` -> `normalized_id=Ontos_Manual` (later compared case-sensitively)

Unsupported markdown forms in v3.3 (explicitly ignored, never rewritten):

- Reference-style links (`[text][ref]` + `[ref]: target`)
- Autolinks (`<http://...>`, `<mailto:...>`)
- Wiki links (`[[target]]`)
- Raw HTML `<a href="...">`

#### Output Metadata

Every detected match includes:

- file path
- line number
- start/end columns
- zone classification (`normal_text`, `inline_code`, `code_fence`)
- match type (`markdown_link_target`, `bare_id_token`)
- raw matched text
- normalized candidate ID
- line context (`before`, `line`, `after`) with minimum one surrounding line (B3)
- rewritable flag + skip reason
- absolute offsets for rewrite operations

### 4.4 Output Format

#### Human-Readable Output

Section order:

1. Scope + file census
   - `scope`, roots scanned, file count loaded, parse warnings count.
2. Summary
   - duplicates, broken refs, external refs, parse-failed candidate count, orphan count, exit code.
3. Duplicate IDs
   - each duplicate ID with full path list.
4. Broken references by source field
   - `depends_on`, `impacts`, `describes`, `body.markdown_link_target`, `body.bare_id_token`.
5. External references (docs scope only)
   - references that resolve to out-of-scope IDs.
6. Parse-failed candidate references
   - raw-scan-only sightings from parse-failed files.
7. Suggestions
   - top candidates with confidence scores (0.00-1.00).
8. Orphans
   - orphan list (truncated display with count).
   - includes scope note: orphan computation is scope-relative.
9. Parse/load warnings
   - parse failures skipped per S4.

#### JSON Schema

Top-level shape:

```json
{
  "status": "success|error",
  "scope": "docs|library",
  "exit_code": 0,
  "summary": {
    "files_scanned": 0,
    "documents_loaded": 0,
    "load_warnings": 0,
    "duplicate_ids": 0,
    "broken_references": 0,
    "broken_frontmatter": 0,
    "broken_body": 0,
    "external_references": 0,
    "parse_failed_candidates": 0,
    "orphans": 0
  },
  "duplicates": [
    {
      "id": "string",
      "paths": ["string"]
    }
  ],
  "broken_references": [
    {
      "source_doc_id": "string",
      "source_path": "string",
      "field": "depends_on|impacts|describes|body.markdown_link_target|body.bare_id_token",
      "value": "string",
      "severity": "error|warning",
      "location": null,
      "suggestions": [
        {
          "candidate": "string",
          "confidence": 0.0,
          "reason": "string"
        }
      ]
    }
  ],
  "external_references": [
    {
      "source_doc_id": "string",
      "source_path": "string",
      "field": "depends_on|impacts|describes|body.markdown_link_target|body.bare_id_token",
      "value": "string",
      "resolved_external_id": "string"
    }
  ],
  "parse_failed_candidates": [
    {
      "path": "string",
      "line": 0,
      "match_type": "markdown_link_target|bare_id_token",
      "candidate": "string"
    }
  ],
  "orphans": [
    {
      "doc_id": "string",
      "path": "string",
      "type": "string"
    }
  ],
  "load_warnings": [
    {
      "code": "parse_error|io_error|invalid_enum|invalid_reference_type|duplicate_id",
      "path": "string",
      "message": "string"
    }
  ]
}
```

Field descriptions:

| Field | Description |
|------|-------------|
| `status` | `success` when report generation completed; `error` only for command execution failures. |
| `scope` | Effective resolved scope (`docs` or `library`) used for this run. |
| `exit_code` | Final process exit code per S1 truth table. |
| `summary.files_scanned` | Markdown files discovered before parse/loading. |
| `summary.documents_loaded` | Parsed `DocumentData` objects retained after load (first-win on duplicates). |
| `summary.load_warnings` | Count of non-fatal load issues (parse/IO/normalization). |
| `summary.duplicate_ids` | Number of duplicate-ID keys in `duplicate_ids`. |
| `summary.broken_references` | Total broken references across frontmatter and body sources. |
| `summary.broken_frontmatter` | Broken refs from `depends_on`, `impacts`, `describes`. |
| `summary.broken_body` | Broken refs from body parser (`markdown_link_target`, `bare_id_token`). |
| `summary.external_references` | Count of cross-scope references resolved to out-of-scope IDs (info only). |
| `summary.parse_failed_candidates` | Count of reference candidates from parse-failed raw scans. |
| `summary.orphans` | Count of orphaned documents after graph construction. |
| `duplicates[]` | Duplicate-ID detail entries with all participating paths. |
| `broken_references[]` | One record per broken reference occurrence with source and suggestions. |
| `broken_references[].field` | Source channel (`depends_on`, `impacts`, `describes`, `body.*`). |
| `broken_references[].location` | Positional metadata for body matches; `null` for pure frontmatter refs. |
| `broken_references[].location.{line,col_start,col_end,zone,match_type}` | Required when `field` starts with `body.`; omitted by setting `location=null` for frontmatter refs. |
| `broken_references[].suggestions[]` | Candidate replacement IDs from suggestion engine with confidence scores. |
| `external_references[]` | Cross-scope references resolved to IDs outside active scope. |
| `parse_failed_candidates[]` | Raw-scan candidates from parse-failed files (informational). |
| `orphans[]` | Orphan entries with ID/path/type for remediation. |
| `load_warnings[]` | Canonical loader issues, including parse skips per S4. |

### 4.5 Exit Code Logic

Binding S1:

- `0`: clean (no duplicates, no broken refs, no orphans).
- `1`: any duplicates OR any broken references (frontmatter or body).
- `2`: no duplicates/broken refs, but one or more orphans.

Additional semantics:

- `external_references` do not count as broken references.
- `parse_failed_candidates` do not count as broken references.
- Orphan detection uses `allowed_orphan_types` from `config.validation.allowed_orphan_types` (same source as map).
- Orphans are scope-relative by default (computed over loaded graph only). In `docs` scope, any document with inbound dependencies from `external_depends_on_index` is removed from orphan set before final count.
- Parse/load warnings alone do not force `1` or `2`.

Decision table:

| Duplicates | Broken refs | External refs only | Orphans | Exit |
|-----------|-------------|--------------------|---------|------|
| 0 | 0 | 0 | 0 | 0 |
| 1+ | any | any | any | 1 |
| 0 | 1+ | any | any | 1 |
| 0 | 0 | 1+ | 0 | 0 |
| 0 | 0 | any | 1+ | 2 |

### 4.6 Relationship to `maintain` and `doctor`

Create shared diagnostics orchestrator:

- `ontos/core/link_diagnostics.py`
- `run_link_diagnostics(...) -> LinkDiagnosticsResult`

Consumers:

- `link-check` command calls this directly with `include_body=True`.
- `maintain` task `check_links` calls the same function (S5 consolidation requirement), with `include_body=False`, `include_external_scope_resolution=True`.
- `doctor` remains lightweight and does not duplicate full link-check logic; it may recommend running `ontos link-check` when validation warns.

This resolves audit item `#11 (C-9)` by removing custom maintain-link logic drift.

## 5. Feature 3: `ontos rename`

### 5.1 Command Interface

Create: `ontos/commands/rename.py`

#### CLI

```text
ontos rename <old_id> <new_id> [--apply] [--scope {docs,library}] [--json] [--quiet]
```

#### Flags and Defaults

- Positional `old_id`: existing ID to rename.
- Positional `new_id`: replacement ID.
- `--apply`: execute rewrite. If omitted, command is dry-run.
- `--scope`: scan scope via shared utility.
- `--json`: structured dry-run/apply report.
- `--quiet`: suppress per-file detail output; still prints fatal diagnostics and final summary line.

Help text:

- Summary: `Plan or apply atomic ID rename across frontmatter and body references.`
- Safety note: `Dry-run by default. Use --apply to write changes.`

Exit codes:

- `0`: dry-run planned successfully OR apply succeeded.
- `1`: validation failure, planning failure, or apply failure.

### 5.2 Pre-Validation Pipeline

All checks execute before any write, in this strict order:

1. Identity check
   - if `old_id == new_id`, exit 0 with `nothing_to_do` message.
2. `new_id` format check
   - regex: `^[A-Za-z0-9](?:[A-Za-z0-9_.-]*[A-Za-z0-9])?$`
   - reject if invalid.
3. `new_id` YAML reserved-word check (case-insensitive)
   - reserved set: `true`, `false`, `yes`, `no`, `null`, `on`, `off`.
   - reject to prevent YAML type coercion.
4. Scope load and identity checks
   - `old_id` exists exactly once as explicit frontmatter `id` in active scope.
   - `new_id` does not exist as explicit frontmatter `id` in active scope.
5. Duplicate check in active scope
   - `load_result.duplicate_ids` must be empty (B5).
6. Cross-scope duplicate/split-brain guard (`--scope docs` only)
   - run lightweight `.ontos-internal` ID scan.
   - if `old_id` or `new_id` exists externally, abort with explicit message requiring `--scope library`.
7. Clean git state check (apply-mode only)
   - command: `git status --porcelain`
   - enforced only when `--apply` is set.
8. Parse integrity and raw-scan safety on skipped files
   - canonical parser only (`parse_frontmatter_content`, S4).
   - for each parse-failed file, run deterministic raw guard scan:
     1. read bytes,
     2. strip UTF-8 BOM if present,
     3. decode UTF-8 with `errors="replace"`,
     4. run `scan_body_references(path, decoded_text, rename_target=old_id, include_skipped=True)`.
   - if any match/sighting is found in parse-failed files, abort (`parse_failed_target_sighting`) because safe rewrite cannot be guaranteed.
9. Full rewrite plan built in memory
   - all frontmatter and body edits computed and conflict-checked before buffering writes.

No write is buffered before step 9 completes.

### 5.3 Frontmatter Update Strategy (Targeted, Non-Round-Trip)

Binding S3: do not use `serialize_frontmatter()` for rename.

#### Mechanism

Use raw frontmatter text patching with a field-aware line scanner:

1. Preprocess text using canonical-loader-compatible boundary rules:
   - read bytes,
   - strip UTF-8 BOM if present,
   - decode UTF-8 with `errors="replace"`,
   - compute `leading_prefix = decoded[:len(decoded)-len(decoded.lstrip())]`,
   - operate on `normalized = decoded.lstrip()` for frontmatter detection.
2. Split `normalized` into three parts only if frontmatter starts with `---`:
   - opening delimiter line
   - raw frontmatter block (unchanged order/comments)
   - body
3. Reconstruct final file as `leading_prefix + patched_normalized` to preserve original leading whitespace contract.
4. Parse frontmatter dict via canonical parser for semantic decisioning.
5. For each target field (`id`, `depends_on`, `impacts`, `describes`) patch only matching values in raw frontmatter block.

#### Field Patch Rules

- `id` scalar:
  - locate top-level `id:` line.
  - replace only scalar token equal to `old_id`.
  - preserve indentation, spacing, quote style, inline comment.
- list fields (`depends_on`, `impacts`, `describes`):
  - support inline list (`[a, b]`) and block list (`- a`).
  - replace only list members exactly equal to `old_id`.
  - preserve comments and order of other items.
- scalar fallback forms (`depends_on: old_id`) are patched equivalently.

Unsupported YAML structures for target fields (anchors, folded blocks, complex objects):

- Deterministic unsupported detection rules:
  1. target field appears more than once at top level,
  2. target field value starts with block-scalar indicator (`|` or `>`),
  3. parsed target field type is not scalar or list of scalars,
  4. target field line/list item uses YAML anchor/alias tokens (`&name`, `*name`),
  5. inline list contains nested list/map (`[a, [b]]`, `[a, {k: v}]`).
- On detection:
  - mark file as `unsupported_target_format`,
  - include machine-readable warning payload `{path, field, reason_code, reason_message}`,
  - abort apply (safe fail).

This strategy avoids field reordering/comment stripping and minimizes diff noise.

### 5.4 Body-Link Rewrite

Rename uses the shared parser (Section 4.3) in write mode (`rename_target=old_id`).

#### Replacement Logic

- Only `rewritable=True` matches in `normal_text` zones are changed.
- `inline_code` and `code_fence` matches are reported but never rewritten.
- For markdown links: replace target substring only, not label text.
- For bare tokens: replace token span only.

Implementation:

1. Collect non-overlapping match spans (`abs_start`, `abs_end`) from parser.
2. Sort descending by `abs_start`.
3. Apply replacements right-to-left on body string.
4. Reassemble file content with unchanged frontmatter delimiters and patched frontmatter block.

Zone boundaries are preserved because replacements are span-local and parser offsets originate from the original body text.

### 5.5 Dry-Run Output

Dry-run is default and must show complete plan detail.

Per B3, each body match entry includes:

- file path
- line number
- context (>=1 line before + current + >=1 line after)
- zone classification
- match type
- replacement preview or skip reason

#### Example (human output)

```text
DRY RUN: ontos rename v3_2 v3_2_renamed --scope library

Summary
  Files scanned: 593
  Documents loaded: 363
  Planned file edits: 4
  Frontmatter edits: 6
  Body edits (rewritable): 3
  Body sightings skipped (code zones): 2

File: docs/reference/Ontos_Manual.md
  Frontmatter
    - line 5 field=depends_on: v3_2 -> v3_2_renamed
  Body
    - line 84 zone=normal_text match=bare_id_token
      83 | Previous material references legacy IDs.
      84 | See v3_2 for migration notes.
      85 | Continue with upgrade workflow.
      replace: v3_2 -> v3_2_renamed

    - line 102 zone=inline_code match=bare_id_token [SKIPPED]
      101 | Example:
      102 | `depends_on: [v3_2]`
      103 | Do not edit code examples automatically.
      reason: zone is inline_code

No files written. Re-run with --apply to execute.
```

#### JSON Dry-Run Shape

```json
{
  "mode": "dry_run",
  "scope": "library",
  "old_id": "v3_2",
  "new_id": "v3_2_renamed",
  "summary": {
    "files_scanned": 0,
    "planned_files": 0,
    "frontmatter_edits": 0,
    "body_edits": 0,
    "skipped_zone_sightings": 0
  },
  "files": [
    {
      "path": "string",
      "frontmatter_edits": [
        {
          "field": "id|depends_on|impacts|describes",
          "line": 0,
          "old": "string",
          "new": "string"
        }
      ],
      "body_edits": [
        {
          "line": 0,
          "zone": "normal_text|inline_code|code_fence",
          "match_type": "markdown_link_target|bare_id_token",
          "rewritable": true,
          "old": "string",
          "new": "string",
          "context_before": "string",
          "context_line": "string",
          "context_after": "string",
          "skip_reason": "string|null"
        }
      ]
    }
  ],
  "warnings": ["string"]
}
```

#### JSON Apply Shape

```json
{
  "mode": "apply",
  "scope": "docs|library",
  "old_id": "string",
  "new_id": "string",
  "status": "success|error",
  "summary": {
    "planned_files": 0,
    "applied_files": 0,
    "frontmatter_edits": 0,
    "body_edits": 0,
    "skipped_zone_sightings": 0
  },
  "applied_paths": ["string"],
  "warnings": ["string"],
  "post_apply_warning": "Derived artifacts may be stale. Run `ontos map` and `ontos agents` to regenerate.",
  "partial_commit": {
    "detected": false,
    "message": "string|null"
  },
  "error": {
    "code": "string|null",
    "message": "string|null"
  }
}
```

Apply JSON contract requirements:

- On success: `status="success"`, `error.code=null`, `partial_commit.detected=false`.
- On pre-validation failure: `status="error"`, `applied_files=0`, `partial_commit.detected=false`.
- On commit exception after partial writes suspected: `status="error"`, `partial_commit.detected=true`, `partial_commit.message` required.

### 5.6 Apply Behavior

#### Write Path

1. Re-run pre-validation + plan build to avoid stale dry-run assumptions.
2. Buffer all file writes into `SessionContext`.
3. Execute `ctx.commit()` once.
4. Cross-check `modified_paths` returned by commit against planned file set.
   - if mismatch, set `partial_commit.detected=true` and return exit 1.
5. On success, print summary and exact post-apply warning:
   - `Derived artifacts may be stale. Run \`ontos map\` and \`ontos agents\` to regenerate.`

#### Error Handling

- Any pre-validation failure -> no writes, exit 1.
- `ctx.commit()` exception -> exit 1 with explicit partial-commit risk message.
- Clean git is required for apply mode only; dry-run always allowed on dirty trees.
- Because apply requires clean git state, recovery path is deterministic (`git restore`/`git checkout` by user policy).

#### Partial Failure Behavior

SessionContext two-phase rename stage can still partially apply if failure occurs during phase-2 renames. Rename command must:

- catch commit exceptions,
- print `commit failed after staging; repository may be partially updated`,
- include remediation instruction to restore from clean git baseline.

No automatic git operations are executed by rename.

### 5.7 Edge Cases

- `old_id == new_id`: treated as no-op and exits successfully with `nothing_to_do`.
- Self-reference (`old_id` in same doc's `depends_on`): treated as normal reference and updated.
- Prefix/substrings (`v3_2` vs `v3_2_1`, `v3_2.1`): prevented by B1 boundary rules.
- Files without frontmatter (library has many): frontmatter phase skipped; body-only scan/rewrite still applied.
- Files with leading whitespace/BOM before frontmatter: supported via canonical-compatible preprocessing (`.lstrip()` + BOM stripping).
- `Ontos_Context_Map.md` references: not renamed directly because scope roots exclude generated map; user is warned to regenerate (`ontos map`, `ontos agents`).
- Template files with YAML comments: targeted patching preserves comments/order; no serializer round-trip noise.

## 6. Absorbed Audit Items

### `#38 (CC-07)` — Nine Different Scan Scopes

Resolved by:

- introducing `scan_scope.py` as single root-resolution contract,
- migrating all scanning commands to shared scope resolver,
- unifying semantics around `docs` default + `--scope library` opt-in.

Verification criteria:

- no command constructs scan roots ad hoc,
- all migrated commands call shared resolver,
- scope behavior covered by command regression tests.

### `#11 (C-9)` — Maintain Link Check Drift

Resolved by:

- creating shared link diagnostics core (`link_diagnostics.py`),
- routing `maintain` task `check_links` through that shared core,
- removing duplicate maintain-specific graph/load/link logic.

Verification criteria:

- maintain and link-check share duplicate detection source (`duplicate_ids`),
- maintain no longer manually composes link error summary from separate code path.

## 7. Test Strategy

Tests are grouped by feature and include unit + integration coverage.

### Feature 1: Unified Scan Scope

#### Unit Tests

- `resolve_scan_scope()` precedence (CLI overrides config, invalid config fallback).
- `build_scope_roots()` for docs vs library.
- dedupe + non-existent root filtering.

#### Command Wiring Tests

- each migrated command parser accepts `--scope`.
- options dataclass receives scope value correctly.

#### Regression Tests

- `map` and `maintain` default docs-scope parity.
- explicit `--scope library` includes `.ontos-internal` docs.
- explicit path args override scope where applicable.

### Feature 2: Body Parser + Link Check

#### Body Parser Unit Corpus (required)

Use a fixed corpus in `tests/core/test_body_refs.py`.

IDs used:

- `v3_2_4_proposal`
- `v3.0.4_Code_Review_Claude`
- `v3_2`
- `v3_2_1`

Cases:

1. bare token in plain text (match)
2. token in code fence (skip)
3. token in inline code (skip)
4. markdown link target internal (match)
5. markdown link target external URL (ignore)
6. line boundary/start/end matches
7. prefix collision (`v3_2` in `v3_2_1`) no match
8. dot-containing ID literal exact match
9. escaped regex characters in target ID
10. mixed links + bare tokens in same line
11. punctuation-adjacent bare IDs (`.`, `:`, `;`, `?`, `!`)
12. table-cell boundary (`| id |`) and blockquote boundary (`> id`)
13. dotted ID at sentence end (`v3.0.4_Code_Review_Claude.`) match
14. dotted ID followed by extension (`v3.0.4_Code_Review_Claude.pdf`) no match
15. markdown links with titles (`[t](id "title")`, `[t](id 'title')`)
16. markdown links with balanced parentheses and escaped `\)` in target
17. unclosed fence EOF behavior (remainder skipped)
18. unsupported markdown forms ignored (reference-style, autolink, wikilink, HTML)

#### Link-Check Unit Tests

- duplicate ID reporting from `duplicate_ids` (without `has_fatal_errors`).
- broken refs in each field (`depends_on`, `impacts`, `describes`).
- body broken refs and suggestions with confidence values.
- selective validation path: `validate_impacts` + `validate_describes`; ensure `validate_all`/`validate_concepts` are not invoked.
- cross-scope classification in docs scope:
  - target in external IDs -> `external_reference` (info),
  - target missing everywhere -> broken reference.
- orphan semantics with external inbound dependencies and `allowed_orphan_types`.
- parse-failed candidate emission and non-impact on exit code.
- exit code truth table (0/1/2).

#### Link-Check Integration Tests

- end-to-end command run on fixture library with:
  - parse errors (skipped warnings),
  - duplicates,
  - broken refs,
  - orphans,
  - body refs.
- JSON schema contract test.
- `broken_references[].location` is `null` for frontmatter refs.
- external reference + parse-failed candidate sections appear when applicable.

#### A1 Gap Closure Test (explicit)

Add integration test for `load_documents()` with real fixture files (multi-file, mixed valid/invalid/duplicate content) to close adversarial gap noted in A1.

### Feature 3: Rename

#### Unit Tests

- pre-validation ordering and failure short-circuit.
- git-clean guard applies only in `--apply` mode.
- collision checks (`new_id` exists).
- `old_id == new_id` no-op path.
- `new_id` regex and YAML reserved-word rejection.
- duplicate-abort behavior from `duplicate_ids`.
- docs-scope cross-scope guard rejects old/new IDs existing in `.ontos-internal`.
- parse-failed raw guard scan algorithm (BOM strip + decode replace + parser reuse) aborts on sightings.
- frontmatter targeted patcher:
  - scalar `id`
  - inline lists
  - block lists
  - comment preservation
  - field order preservation
  - leading-whitespace/BOM frontmatter files
  - deterministic unsupported-target-format detection reasons
- body replacement engine:
  - markdown target replacement
  - bare token replacement
  - skipped zones unchanged.

#### Integration Tests (required)

1. dry-run produces complete plan with context lines.
2. apply modifies only intended files.
3. post-apply `ontos link-check` reports clean graph for renamed IDs.
4. collision detection rejects existing `new_id`.
5. dirty git state is rejected before apply writes.
6. dirty git state still allows dry-run planning.
7. apply JSON schema success/failure/partial-commit payloads.

#### Golden-Diff Tests

- template file with YAML comments retains comments after rename.
- no serializer-driven field reordering noise.

## 8. Risk Assessment

### Feature 1 Risks

- Risk: broad CLI/command touch points introduce inconsistent scope wiring.
- Mitigation: centralized `scan_scope.py`; parser registration tests for every migrated command.

### Feature 2 Risks (Highest)

- Risk: body parser false positives in normal prose.
- Risk: false negatives in markdown edge cases (fences/backticks).
- Risk: cross-scope false positives when docs scope excludes reference targets.
- Mitigation:
  - strict zone state machine,
  - explicit two-tier boundary/token rules (B1),
  - explicit markdown grammar support/skip contract,
  - external-ID cross-scope classification (`external_reference`),
  - extensive corpus tests with real ID formats,
  - parser output includes zone/match metadata for inspection.

### Feature 3 Risks

- Risk: unsafe bulk rewrite behavior on partial commit failure.
- Risk: frontmatter corruption if patching is too permissive.
- Mitigation:
  - apply-mode clean git precondition (dry-run allowed on dirty trees),
  - full in-memory planning before any write,
  - targeted raw frontmatter patcher with unsupported-format fail-fast,
  - SessionContext single commit path,
  - post-apply warning to regenerate derived artifacts.

## 9. Dependencies and Constraints

### A1 Infrastructure Used (mandatory)

- `io/files.py:load_documents()` for canonical load + issue tracking.
- `io/files.py:load_frontmatter()` for single-file parse contract (non-`.lstrip()` behavior must not be assumed equivalent to batch loader preprocessing).
- `DocumentLoadResult.duplicate_ids` for duplicate detection (B5, VUL-03-safe).
- `DocumentLoadIssue` for parse/IO warnings.
- `core/graph.py:build_graph()` + orphan/cycle helpers.
- `ValidationOrchestrator` with per-field severity overrides.
- `core/suggestions.py` candidate scoring.
- `core/frontmatter.py` normalization utilities.
- `core/context.py:SessionContext` for buffered writes.

### Architectural Constraints

- Canonical YAML parser only (`parse_frontmatter_content`, S4).
- Do not rely on `has_fatal_errors` for duplicate severity decisions.
- Do not claim concept validation completeness in link-check (VUL-06).
- VUL-07 `hasattr(...)` guard cleanup was completed in A1 hardening; no Track B action required.
- `core/suggestions.py:extract_doc_ids_from_text()` is explicitly out-of-scope for Track B reference parsing; link-check/rename must use `core/body_refs.py`.
- `core/history.py` remains a legacy parser consumer and is not migrated by Track B.

### Backward Compatibility Commitments

- `map`/`maintain` defaults remain stable under docs scope.
- legacy broad scans remain available via explicit `--scope library`.
- rename is opt-in apply (`--apply`) and never writes by default.
- no automatic file moves or URL mutation.

---

## Implementation Checklist (Execution Hand-off)

1. Add `scan_scope.py`, config field, and CLI `--scope` plumbing.
2. Migrate matrix-listed commands to shared scope resolver.
3. Implement `body_refs.py` with zone-aware parser and test corpus.
4. Implement `link_diagnostics.py` shared core.
5. Add `link_check.py` command + JSON/human output + exit logic.
6. Route maintain task 7 through shared diagnostics.
7. Implement `rename.py` planner, targeted patcher, and apply flow.
8. Add rename dry-run/apply integration tests.
9. Validate absorbed audit items #38 and #11 with regression tests.
