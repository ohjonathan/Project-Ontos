---
id: v3_3_track_b_pr3_review
type: review
status: active
depends_on:
  - v3_3_track_b_implementation_spec_v2
concepts:
  - v3.3b
  - track-b
  - code-review
  - rename
  - frontmatter-patcher
  - pr-review
---

# v3.3 Track B PR3 Review — `ontos rename`

**Branch:** `feature/v3.3-track-b-rename`
**Spec:** `v3.3_Track_B_Implementation_Spec_v2.md` — Section 5
**Developer:** Codex
**Reviewer:** Claude Code (Tier 1 Review Team)
**Date:** 2026-02-11
**Commit:** `e1b13b5`

---

## Verdict: Approve

No blocking issues. All three review passes clean. The implementation correctly delivers the dry-run-first atomic ID rename engine with targeted frontmatter patching, zone-aware body rewriting, two-phase atomic apply, and all pre-validation guards specified in Section 5. The targeted frontmatter patcher — the highest-risk component — was hand-traced through every patching path, preservation guarantee, unsupported format detection rule, and dangerous edge case. No corruption risk. All 10 settled decisions (B1, B3, B5, S3, S4, S5, P-M1, P-C1, A-MIN-03, VUL-03) verified compliant.

Track B is complete: scan scope (PR 1) + body parser + link-check (PR 2) + rename (PR 3) delivered.

**Recommended changes:**
1. NB-3: Remove unused `token` parameter from `_replace_preserving_padding`.
2. NB-5: Add tests for quoted id values, anchor/alias detection, block scalar detection, self-referential `depends_on`, `--scope library` rename, and `--quiet` mode.
3. NB-6: Add separate "Dry-run by default" safety note to CLI help description.

---

## Pass 1: Frontmatter Patcher Verification

### New Module: `ontos/commands/rename.py` (1,354 lines)

The targeted frontmatter patcher (lines ~530–1,078) is the highest-risk new infrastructure in PR 3. It edits raw YAML without round-tripping through a serializer. All subsections verified against spec Section 5.3.

### Preprocessing Alignment — CORRECT

| Check | Status | Notes |
|-------|--------|-------|
| BOM stripping in `_read_decoded_content` (line 638) | PASS | `raw.startswith(b"\xef\xbb\xbf")` strips 3-byte BOM |
| BOM stripping in `_decode_file_lenient` (line 539) | PASS | Same BOM detection pattern |
| `.lstrip()` applied before `---` detection | PASS | `prefix_len = len(decoded) - len(decoded.lstrip())` |
| `_split_frontmatter` delimiter check | PASS | `normalized.startswith("---")` after lstrip |
| Leading prefix preserved for reconstruction (line 617) | PASS | `new_content = decoded.leading_prefix + normalized_new` |
| Leading line offset for line numbering (line 648) | PASS | `leading_line_offset = leading_prefix.count("\n")` |

Preprocessing matches canonical loader contract (`io/files.py`) exactly. No divergence from byte-handling path.

### Field Patching — CORRECT

All scalar token forms verified through `_decode_scalar_token` (line 1017) and `_patch_scalar_after_colon` (line 941):

**`id` field:**

| Input | Quote Detected | Replacement Token | Output | Status |
|-------|---------------|-------------------|--------|--------|
| `id: old_id` | bare (`None`) | `new_id` | `id: new_id` | PASS |
| `id: "old_id"` | double (`"`) | `"new_id"` | `id: "new_id"` | PASS |
| `id: 'old_id'` | single (`'`) | `'new_id'` | `id: 'new_id'` | PASS |

**List fields (`depends_on`, `impacts`, `describes`):**

| Input Form | Mechanism | Status |
|------------|-----------|--------|
| Inline `[old_id, other]` | `_patch_inline_list_after_colon` — segments by comma, decodes each, exact `==` | PASS |
| Inline `[other, old_id]` | Same mechanism, position-independent | PASS |
| Inline `[old_id]` | Single-element case | PASS |
| Block `- old_id` / `- other` | Loop at line 890, `_patch_scalar_after_colon` on text after dash | PASS |
| Scalar `depends_on: old_id` | Parsed as string by YAML → falls to scalar path at line 922 | PASS |

**Multi-field patching:**

| Check | Status | Notes |
|-------|--------|-------|
| `old_id` in `id`, `depends_on`, AND body | PASS | Loop at line 711 iterates all four target fields; body rewrite at lines 576–611 |

### Preservation Guarantees — CORRECT

| Guarantee | Mechanism | Tested? |
|-----------|-----------|---------|
| Field ordering | Lines patched in-place in `lines` array, no reordering | Yes |
| YAML comments preserved | `_split_comment_unquoted` (line 1023) separates value/comment; only value touched | Yes (3 comment types) |
| Indentation preserved | `_replace_preserving_padding` (line 1045) preserves leading/trailing whitespace | Yes |
| Trailing newline preserved | `_split_line_ending` (line 1052) preserves `\n`, `\r\n`, or no newline | Yes |
| Non-target fields untouched | Only `("id", "depends_on", "impacts", "describes")` at line 710 | Yes |

Test coverage: `test_rename_frontmatter_comments_and_order_preserved_on_apply` verifies `# keep-id-comment`, `# keep-list-comment`, `# keep-tail-comment` all preserved through apply.

### Unsupported Format Detection — ALL 5 SPEC RULES PRESENT

| Rule | Detection | Reason Code | Location |
|------|-----------|-------------|----------|
| Duplicate top-level field | Lines 717–727 (`len(occurrences) != 1`) | `REASON_DUPLICATE_TOP_LEVEL` | PASS |
| Block scalar indicator (`\|` or `>`) | Line 851 | `REASON_BLOCK_SCALAR` | PASS |
| Non-scalar list member | Lines 824–826 (dict/list/tuple/set check) | `REASON_NON_SCALAR_LIST` | PASS |
| Anchor/alias (`&name`, `*name`) | `_ANCHOR_ALIAS_RE` at lines 942, 963 | `REASON_ANCHOR_ALIAS` | PASS |
| Nested inline collection (`[` or `{` inside list) | Lines 990–991 | `REASON_NESTED_INLINE` | PASS |

All unsupported detections emit blocking warnings. `_patch_frontmatter` returns `unsupported=True` (line 762), which blocks apply and skips the file's body rewrite (line 566). **No silent corruption path.**

Test coverage: `test_rename_unsupported_frontmatter_warns_in_dry_run_and_blocks_apply` verifies `non_scalar_list` detection, dry-run warning, and apply block.

### Dangerous Edge Cases — CORRECT

| Edge Case | Protection | Status |
|-----------|-----------|--------|
| `old_id` appears in YAML comment inside frontmatter | `_split_comment_unquoted` protects comment portion from modification | PASS |
| `old_id` as value of non-target field | Only target_fields iterated at line 710; other fields never inspected | PASS |
| `old_id` is substring of another value (e.g., `old_id_extended`) | `_decode_scalar_token` extracts full token; exact `==` comparison at line 950 | PASS |
| Inline list substring (e.g., `[old_id_extended, old_id]`) | Each segment individually decoded and compared; only exact match replaced | PASS |

---

## Pass 2: Spec Compliance

### Command Interface (Section 5.1)

| Check | Status | Notes |
|-------|--------|-------|
| Positional `old_id` | PASS | `cli.py` line 233 |
| Positional `new_id` | PASS | `cli.py` line 234 |
| `--apply` flag (default False = dry-run) | PASS | `cli.py` lines 235–238, `action="store_true"` |
| `--scope` flag via shared utility | PASS | `cli.py` line 239, `_add_scope_argument(p)` |
| `--json` flag | PASS | Inherited from global parent parser |
| `--quiet` flag | PASS | Inherited from global parent parser |
| CLI registered | PASS | `cli.py` line 68, `_register_rename(subparsers, global_parser)` |
| Help text | PASS | `"Plan or apply atomic ID rename across frontmatter and body references"` |

### Pre-Validation Pipeline (Section 5.2)

All 10 checks present. Implementation order differs from spec for efficiency (fail-fast). No correctness impact — all checks execute before any write.

| Spec Step | Description | Impl Line | Impl Position | Status |
|-----------|-------------|-----------|---------------|--------|
| 1 | `old_id == new_id` → no-op | 294 | 1st | PASS |
| 2 | `new_id` format regex | 325 | 2nd | PASS |
| 3 | YAML reserved-word rejection | 330 | 3rd | PASS |
| 7 | Clean git state (apply only) | 339 | 4th (moved up) | PASS |
| 4a | Scope load | 348–355 | 5th | PASS |
| 5 | Duplicate check via `duplicate_ids` (B5) | 357 | 6th | PASS |
| 4b | `old_id` exists exactly once | 367–379 | 7th | PASS |
| 4c | `new_id` does not exist | 381–385 | 8th | PASS |
| 6 | Cross-scope guard (docs only) | 387–396 | 9th | PASS |
| 8 | Parse-failed raw-scan guard | 398–410 | 10th | PASS |
| 9 | Build rewrite plan | 412+ | 11th | PASS |

Key compliance checks:
- **P-M1**: Git check is apply-only (`if mode == "apply":` at line 339) — dry-run on dirty trees always works. **COMPLIANT.**
- **VUL-03**: Duplicate check uses `load_result.duplicate_ids` (line 357), NOT `has_fatal_errors`. **COMPLIANT.**
- **B5**: Duplicate-abort from `duplicate_ids` empty check. **COMPLIANT.**

### Body Rewrite (Section 5.4)

| Check | Status | Notes |
|-------|--------|-------|
| Uses `scan_body_references(rename_target=old_id)` | PASS | Lines 576–579 |
| `include_skipped=True` for dry-run visibility | PASS | Line 581 |
| Only `rewritable=True` refs replaced | PASS | Line 606 conditional |
| Reverse-order replacement (prevents offset drift) | PASS | Line 610, `sorted(..., reverse=True)` |
| Skipped refs reported in output | PASS | `BodyEdit` includes non-rewritable with `skip_reason` |
| Markdown link: target substring only replaced | PASS | `_rewrite_markdown_target` at line 1087 handles path/fragment/angle |
| Bare token: full token replaced | PASS | `_replacement_for_match` returns `new_id` for `BARE_ID_TOKEN` |

### Dry-Run Output (Section 5.5)

| Check | Status | Notes |
|-------|--------|-------|
| Summary header | PASS | Files scanned, planned edits, frontmatter/body/skipped counts |
| Per-file changes with line numbers | PASS | Frontmatter edits + body edits per file |
| Context lines (B3) | PASS | `context_before`, `context_line`, `context_after` |
| Zone classification shown | PASS | `zone=normal_text\|inline_code\|code_fence` |
| Match type shown | PASS | `match=markdown_link_target\|bare_id_token` |
| Skipped files with reasons | PASS | `[SKIPPED]` marker + `reason: {skip_reason}` |
| Total footer | PASS | `"No files written. Re-run with --apply to execute."` |
| JSON dry-run shape | PASS | Matches spec with non-breaking superset (`status`, `error` added) |
| JSON apply shape (P-C1) | PASS | `mode`, `status`, `summary`, `applied_paths`, `partial_commit`, `error`, `post_apply_warning` |

### Apply Behavior (Section 5.6)

| Check | Status | Notes |
|-------|--------|-------|
| `SessionContext` used for atomic writes | PASS | Line 219 |
| Two-phase commit (temp write → atomic rename) | PASS | `context.py` `commit()` method |
| Commit result cross-checked against plan (A-MIN-03) | PASS | Lines 244–265: `planned_paths != committed_paths` check |
| Partial failure handling | PASS | Lines 223–242: catches `ctx.commit()` exception |
| `partial_commit.detected` flag | PASS | Set `True` on mismatch or exception |
| Post-apply warning exact text (S5) | PASS | `"Derived artifacts may be stale. Run \`ontos map\` and \`ontos agents\` to regenerate."` |
| No automatic git operations | PASS | Only `git status --porcelain` for read; no `git add/commit/restore` |

### Edge Cases (Section 5.7)

| Case | Spec Requirement | Status | Verified By |
|------|-----------------|--------|-------------|
| `old_id == new_id` | Exit 0 with `nothing_to_do` | PASS | `test_rename_noop_old_equals_new` |
| Self-referential `depends_on` | Patched normally | PASS | Spec Section 5.7 (trace) |
| Substring collision (`v3_2` vs `v3_2_1`) | B1 boundary rules prevent | PASS | `test_rename_substring_ids_not_matched` |
| Body-only files (no frontmatter) | Frontmatter skipped; body scan/rewrite applied | PASS | `test_rename_body_only_rewrite_for_files_without_frontmatter` |
| Context map references | Excluded via scope roots; user warned to regenerate | PASS | `POST_APPLY_WARNING` text |
| Dot-containing IDs | `re.escape()` via PR 2 parser | PASS | `test_rename_dot_id_regex_safety` |

### Settled Decision Compliance

| Decision | Requirement | Implementation | Status |
|----------|-------------|----------------|--------|
| B1 | Exact-match boundary model (body rewrite) | Two-tier boundaries from PR 2 parser | PASS |
| B3 | Context lines in dry-run output | >= 1 context line per body match | PASS |
| B5 | Duplicate detection via `duplicate_ids` | `load_result.duplicate_ids` at line 357 | PASS |
| S3 | No `serialize_frontmatter()` round-trip | Targeted raw text patching | PASS |
| S4 | Canonical parser only (`parse_frontmatter_content`) | Line 689 for semantic decisioning | PASS |
| S5 | Exact post-apply warning text | Exact string match verified | PASS |
| P-M1 | Git check apply-only | `if mode == "apply":` guard at line 339 | PASS |
| P-C1 | Dry-run default; apply-mode JSON schema | `--apply` default False; JSON schema compliant | PASS |
| A-MIN-03 | Cross-check committed paths vs plan | Lines 244–265 path set comparison | PASS |
| VUL-03 | No `has_fatal_errors` for duplicates | `duplicate_ids` used directly | PASS |

---

## Pass 3: Integration & Foundation

### Pipeline Trace — CORRECT

Two execution paths verified end-to-end:

**Dry-run path:**
1. Parse args → `rename_command(options)` → `mode = "dry_run"`
2. `_prepare_plan(options, mode="dry_run")`
3. Pre-validation steps 1–3 (identity, format, reserved word)
4. Skip git check (dry-run always allowed on dirty trees)
5. Scope load → duplicate check → identity checks → cross-scope guard
6. Parse-failed scan
7. Build rewrite plan via `_build_file_plan` for each document
8. `_emit_dry_run` (human or JSON output)
9. Return exit 0

**Apply path:**
1. Parse args → `mode = "apply"`
2. `_prepare_plan(options, mode="apply")`
3. Pre-validation steps 1–3
4. Clean git state check (enforced)
5. Scope load → duplicate check → identity checks → cross-scope guard
6. Parse-failed scan
7. Build rewrite plan
8. Check blocking warnings (unsupported format → abort if any)
9. Buffer writes into `SessionContext`
10. `ctx.commit()` (two-phase: temp write + atomic rename)
11. Cross-check `modified_paths` vs `planned_paths`
12. `_emit_apply_success` with `POST_APPLY_WARNING`
13. Return exit 0

No gaps in pipeline. All A1/PR1/PR2 infrastructure consumed correctly: `resolve_scan_scope`, `collect_scoped_documents`, `load_documents`, `parse_frontmatter_content`, `scan_body_references`, `SessionContext`.

### Gold Standard E2E Test — PRESENT

`test_rename_end_to_end_dry_run_apply_then_link_check` executes the complete rename cycle:

1. **Dry-run** → verifies "No files written" in output
2. **Apply** (`--apply`) → verifies return code 0
3. **`ontos link-check` (JSON)** → verifies `broken_references == 0` AND `duplicate_ids == 0`

This confirms the full pipeline: rename plan → apply → graph remains clean. The definitive Track B integration test.

### Track B Completion Assessment

| PR | Feature | Status |
|----|---------|--------|
| PR 1 (#68) | Unified scan scope | Merged |
| PR 2 (#69) | Body parser + link diagnostics + `link-check` | Merged |
| PR 3 | `ontos rename` | Review: Approve |

All three features work together: rename uses scan scope (`resolve_scan_scope`) and body parser (`scan_body_references`). No orphaned code from intermediate PRs. Track A3 can proceed without blockers from Track B.

---

## Non-Blocking Issues

| ID | Category | Finding | Recommendation |
|----|----------|---------|----------------|
| NB-1 | Spec deviation | Pre-validation order differs from spec Section 5.2. Git check at position 4 (between format checks and scope load) instead of position 7 (between cross-scope guard and parse-failed scan). Duplicate check positioned before identity checks. | Document as intentional fail-fast optimization. No correctness impact — all checks execute before any write. |
| NB-2 | Spec deviation | Dry-run JSON includes `status` and `error` fields not in spec Section 5.5 dry-run JSON shape. Present in apply shape. | Non-breaking superset. Improves consistency between dry-run and apply JSON. Accept as-is or update spec. |
| NB-3 | Code quality | `_replace_preserving_padding` (line 1045) has unused `token` parameter. Function ignores it; uses only `original` and `replacement`. | Remove dead parameter in follow-up cleanup. |
| NB-4 | Robustness | `_split_frontmatter` (line 652) uses `split("---", 2)` which could break if `---` appears inside a YAML string value on the same line. | Mitigated: canonical parser re-check at line 688 catches misparse and marks file as unsupported. Low risk in Ontos context. Note for future hardening. |
| NB-5 | Test gap | Missing tests for: quoted id values (`id: "old_id"`, `id: 'old_id'`), anchor/alias detection, block scalar detection, self-referential `depends_on`, `--scope library` rename, `--quiet` mode output suppression. | Add in follow-up. Current coverage is sufficient for merge safety — all critical paths tested. |
| NB-6 | Documentation | Spec Section 5.1 defines a separate safety note: `Dry-run by default. Use --apply to write changes.` CLI only captures this in `--apply` flag help text, not as a standalone description line. | Add as `description` parameter to `add_parser()` or epilog. |

---

## Test Coverage Assessment

### Coverage Summary

| Area | Tests | Adequate? |
|------|-------|-----------|
| Pre-validation: noop (`old_id == new_id`) | 1 test | Yes |
| Pre-validation: reserved word rejection | 1 test | Yes |
| Pre-validation: invalid format rejection | 1 test | Yes |
| Pre-validation: duplicate IDs (B5) | 1 test | Yes |
| Pre-validation: `old_id` not found | 1 test | Yes |
| Pre-validation: `new_id` already exists | 1 test | Yes |
| Pre-validation: cross-scope guard | 1 test | Yes |
| Pre-validation: parse-failed file scan | 1 test | Yes |
| Pre-validation: dirty git apply/dry-run (P-M1) | 1 test (both paths) | Yes |
| Frontmatter: comments/order preservation | 1 test (3 comment types) | Yes |
| Frontmatter: unsupported format detection | 1 test (nested list + apply block) | Yes |
| Body: line context + skipped zones | 1 test | Yes |
| Body: body-only files (no frontmatter) | 1 test | Yes |
| Body: substring safety (B1) | 1 test | Yes |
| Body: dot-ID regex safety | 1 test | Yes |
| Output: dry-run JSON schema | 1 test | Yes |
| Output: apply JSON schema + post-apply warning (S5) | 1 test | Yes |
| E2E: dry-run → apply → link-check | 1 test | Yes |

**Total: 17 tests across 358 lines.**

### Test Gaps

1. No tests for quoted id values (`id: "old_id"`, `id: 'old_id'`) — patching logic verified by code trace.
2. No tests for anchor/alias detection (`&name`, `*name`) in target fields.
3. No tests for block scalar detection (`|`, `>`) in target fields.
4. No test for self-referential `depends_on` (same doc references own id).
5. No integration test for `--scope library` rename.
6. No test for `--quiet` mode output suppression.

**Overall test quality: Strong.** All critical paths tested. The E2E golden test (`dry-run → apply → link-check`) provides high confidence in end-to-end correctness. Gaps are in secondary detection paths and output modes, not in core safety logic.

---

## Codebase Verification

### Files Created

- `ontos/commands/rename.py` (1,354 lines) — Rename planner, targeted frontmatter patcher, body rewrite engine, apply flow
- `tests/commands/test_rename.py` (358 lines, 17 tests) — Integration tests

### Files Modified (implementation)

- `ontos/cli.py` (+34) — `rename` subparser with positional args, `--apply`, `--scope`
- `ontos/commands/__init__.py` (+7) — `rename_command` and `RenameOptions` exports

### Files Modified (tests)

- `tests/test_cli.py` (+4) — `rename` added to command lists and help test
- `tests/commands/test_scan_scope_integration.py` (+1) — `rename` added to parametrized scope help test

### Files Modified (other)

- `.ontos-internal/reference/decision_history.md` — Regenerated timestamp only
- `Ontos_Context_Map.md` — Regenerated with rename command entry

### Change Volume

- **+1,824 / -48 lines** across 8 files
- ~1,712 lines implementation + tests (`rename.py` + `test_rename.py`)
- ~112 lines context map regeneration
- Within spec's estimated implementation range

---

## Appendix: Verified Correct Implementations

These areas were specifically attacked and found correctly implemented:

- **Targeted frontmatter patcher** — Raw line-level text patching with `_decode_scalar_token` for quote-style detection, `_split_comment_unquoted` for comment preservation, `_replace_preserving_padding` for whitespace preservation, and `_split_line_ending` for newline preservation. No serializer round-trip per S3. All five unsupported format detection rules emit machine-readable warnings with distinct reason codes. Any detection aborts apply. No silent corruption path.

- **BOM and leading whitespace preprocessing** — Matches canonical loader byte-handling exactly. `_read_decoded_content` and `_decode_file_lenient` both strip BOM. `.lstrip()` applied before frontmatter delimiter detection. Leading prefix reconstructed after patching. Line offsets correctly track prefix newlines.

- **Inline list patching** — `_patch_inline_list_after_colon` segments by comma with quote-awareness. Each segment individually decoded and compared with exact `==`. Nested collection detection (`[` or `{` inside list) triggers `REASON_NESTED_INLINE` and aborts. Anchor/alias detection via `_ANCHOR_ALIAS_RE` aborts. Quote-style preserved per segment.

- **Body rewrite safety** — Reverse-order span replacement (sorted descending by `abs_start`) prevents offset drift. Only `rewritable=True` matches modified. Markdown link targets rewritten with path/fragment/angle-bracket awareness via `_rewrite_markdown_target`. Skipped zones reported for dry-run visibility but never touched.

- **Two-phase atomic commit** — `SessionContext` buffers all writes, commits once via temp-then-rename pattern. `_check_clean_git_state` enforced only in apply mode (P-M1). Planned vs committed path cross-check detects partial failure (A-MIN-03). Clean git precondition enables deterministic user recovery.

- **Pre-validation completeness** — All 10 spec checks present. Order optimization (git check early, duplicate before identity) improves efficiency without affecting safety invariant: no write is buffered before step 9 completes. YAML reserved-word rejection prevents type coercion. Cross-scope guard prevents split-brain. Parse-failed scan prevents blind rewrites.

- **Markdown target rewriting** — `_rewrite_markdown_target` correctly handles: bare targets (`old_id` → `new_id`), fragment targets (`old_id#section` → `new_id#section`), path targets (`docs/old_id.md` → `docs/new_id.md`), and angle-bracket targets (`<old_id>` → `<new_id>`). Only the leaf stem is compared and replaced.
