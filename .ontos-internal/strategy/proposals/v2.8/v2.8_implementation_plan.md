---
id: v2_8_implementation_plan
type: strategy
status: draft
depends_on: [master_plan_v4, v2_7_1_implementation_plan]
concepts: [architecture, refactor, cli, context-object]
---

# v2.8 Implementation Plan

**Author:** Claude Code (Opus 4.5) as Chief Architect
**Date:** 2025-12-20
**Version:** 1.0.0 (Draft for LLM Review)
**Goal:** Prepare architecture for v3.0 (MCP Server) through Context Object Refactor and Unified CLI
**Status:** PENDING LLM REVIEW BOARD APPROVAL

---

## Executive Summary

v2.8 is an **architectural refactoring release** with two major features:

1. **Context Object Refactor** — Split `ontos_lib.py` into pure logic (`ontos.lib.core`) and I/O (`ontos.lib.ui`), introduce `SessionContext` dataclass with transaction boundaries.

2. **Unified CLI** — Create `ontos.py` dispatcher to replace direct script invocation, preparing users for v3.0 syntax.

**Why Now:** v3.0 will expose Ontos functionality via MCP Server. The current architecture mixes I/O with logic, making it impossible to expose as an API. v2.8 creates the clean separation required.

**Current State:** v2.7.1 stable (225 tests, 0 validation issues)
**Target State:** v2.8 with clean architecture ready for v3.0

---

## Table of Contents

1. [Current Architecture Analysis](#1-current-architecture-analysis)
2. [Feature 1: Context Object Refactor](#2-feature-1-context-object-refactor)
3. [Feature 2: Unified CLI](#3-feature-2-unified-cli)
4. [Implementation Phases](#4-implementation-phases)
5. [Open Questions for LLM Review Board](#5-open-questions-for-llm-review-board)
6. [Success Criteria](#6-success-criteria)
7. [Risk Analysis](#7-risk-analysis)
8. [Testing Strategy](#8-testing-strategy)

---

## 1. Current Architecture Analysis

### 1.1 Script Inventory

| Script | Lines | Has main() | Uses argparse | Purpose |
|--------|-------|------------|---------------|---------|
| `ontos_lib.py` | 1,286 | No | No | Shared library |
| `ontos_end_session.py` | 1,693 | Yes | Yes | Archive sessions |
| `ontos_generate_context_map.py` | 1,223 | Yes | Yes | Generate context map |
| `ontos_consolidate.py` | 396 | Yes | Yes | Archive old logs |
| `ontos_verify.py` | 262 | Yes | Yes | Verify describes dates |
| `ontos_maintain.py` | 250 | Yes | Yes | Maintenance tasks |
| `ontos_query.py` | 234 | Yes | Yes | Query documents |
| Others (10) | ~2,900 | Mixed | Mixed | Various utilities |

**Total:** ~7,900 lines across 17 scripts

### 1.2 Current I/O Violations in ontos_lib.py

The library currently contains **7 print() statements** that violate the "Functional Core, Imperative Shell" principle:

| Line | Statement | Context |
|------|-----------|---------|
| 94 | `print("WARN: git not found...")` | Git fallback |
| 100 | `print("WARN: git command timed out...")` | Git timeout |
| 558 | `print(f"WARN: {w}")` | Validation warning |
| 641 | `print(f"Error parsing YAML...")` | YAML error |
| 987-989 | `print()` x3 | Deprecation warning |

**Problem:** These print statements prevent the library from being used in non-CLI contexts (API, MCP Server, tests).

### 1.3 Current State Access Patterns

Scripts currently access state through multiple patterns:

```python
# Pattern 1: Direct function calls with implicit config
from ontos_lib import get_logs_dir, resolve_config
logs_dir = get_logs_dir()  # Uses config internally

# Pattern 2: Config module import
from ontos_config import DOCS_DIR, AUTO_ARCHIVE_ON_PUSH

# Pattern 3: Environment variable fallback
source = os.environ.get('ONTOS_SOURCE', config.DEFAULT_SOURCE)
```

**Problem:** State is scattered across module-level variables, environment variables, and config imports. This makes testing difficult and prevents dependency injection.

---

## 2. Feature 1: Context Object Refactor

### 2.1 Design: SessionContext Dataclass

Per the Master Plan (Section 3.1), we implement a transactional session pattern:

```python
from dataclasses import dataclass, field
from pathlib import Path
from typing import Dict, List, Optional, Callable
from enum import Enum

class FileOperation(Enum):
    WRITE = "write"
    DELETE = "delete"
    MOVE = "move"

@dataclass
class PendingWrite:
    """A buffered file operation."""
    operation: FileOperation
    path: Path
    content: Optional[str] = None  # For WRITE
    destination: Optional[Path] = None  # For MOVE

@dataclass
class SessionContext:
    """Captures all state for an Ontos session.

    This is the single source of truth for:
    - Repository configuration
    - Environment state
    - Pending file operations (transaction buffer)
    """
    # Immutable state (set at creation)
    repo_root: Path
    config: Dict
    cwd: Path = field(default_factory=Path.cwd)
    env: Dict[str, str] = field(default_factory=lambda: dict(os.environ))

    # Mutable state (changes during session)
    pending_writes: List[PendingWrite] = field(default_factory=list)
    warnings: List[str] = field(default_factory=list)
    errors: List[str] = field(default_factory=list)

    # Callbacks for I/O (dependency injection)
    output_handler: Optional[Callable[[str], None]] = None

    def buffer_write(self, path: Path, content: str) -> None:
        """Buffer a file write for later commit."""
        self.pending_writes.append(PendingWrite(
            operation=FileOperation.WRITE,
            path=path,
            content=content
        ))

    def commit(self) -> List[Path]:
        """Execute all buffered operations atomically.

        Returns list of paths that were modified.
        """
        modified = []
        # TODO: Acquire lock (.ontos/write.lock)
        try:
            for op in self.pending_writes:
                if op.operation == FileOperation.WRITE:
                    op.path.parent.mkdir(parents=True, exist_ok=True)
                    op.path.write_text(op.content)
                    modified.append(op.path)
                elif op.operation == FileOperation.DELETE:
                    if op.path.exists():
                        op.path.unlink()
                        modified.append(op.path)
                elif op.operation == FileOperation.MOVE:
                    if op.path.exists():
                        op.path.rename(op.destination)
                        modified.append(op.destination)
        finally:
            # Release lock
            self.pending_writes.clear()
        return modified

    def rollback(self) -> None:
        """Discard all buffered operations."""
        self.pending_writes.clear()

    def warn(self, message: str) -> None:
        """Record a warning (does not print)."""
        self.warnings.append(message)

    def error(self, message: str) -> None:
        """Record an error (does not print)."""
        self.errors.append(message)
```

### 2.2 Library Split Strategy

**Current structure:**
```
.ontos/scripts/
├── ontos_lib.py          # Mixed pure + impure
├── ontos_config.py       # Config wrapper
├── ontos_config_defaults.py
└── ontos_*.py            # Scripts (impure)
```

**Proposed structure:**
```
.ontos/scripts/
├── ontos/                 # New package
│   ├── __init__.py
│   ├── core/              # Pure logic (no I/O)
│   │   ├── __init__.py
│   │   ├── context.py     # SessionContext
│   │   ├── frontmatter.py # Parsing, validation
│   │   ├── graph.py       # Dependency analysis
│   │   ├── history.py     # Decision history generation
│   │   └── staleness.py   # Describes/staleness logic
│   └── ui/                # I/O layer
│       ├── __init__.py
│       ├── cli.py         # Unified CLI dispatcher
│       ├── output.py      # Print handlers
│       └── prompts.py     # Interactive input
├── ontos_lib.py           # DEPRECATED: Shim for backwards compat
├── ontos_config.py        # Unchanged
└── ontos_*.py             # Scripts (refactored to use core/)
```

### 2.3 Function Classification

| Function | Current Location | Target Location | Pure? |
|----------|------------------|-----------------|-------|
| `parse_frontmatter()` | lib | core/frontmatter | ✅ Yes |
| `normalize_describes()` | lib | core/staleness | ✅ Yes |
| `validate_describes_field()` | lib | core/staleness | ✅ Yes |
| `check_staleness()` | lib | core/staleness | ⚠️ Needs git abstraction |
| `generate_decision_history()` | lib | core/history | ✅ Yes |
| `get_file_modification_date()` | lib | core/staleness | ⚠️ Calls subprocess |
| `get_logs_dir()` | lib | core/context | ⚠️ Reads config |
| `resolve_config()` | lib | core/context | ✅ Yes (with injected config) |
| `_warn_deprecated()` | lib | ui/output | ❌ No (prints) |

### 2.4 Handling Subprocess Calls

**Problem:** Functions like `get_file_modification_date()` call `subprocess.run()` for git operations. This is I/O.

**Solution Options:**

| Option | Description | Pros | Cons |
|--------|-------------|------|------|
| A. Abstract to interface | Create `GitProvider` interface, inject into context | Clean, testable | Over-engineering? |
| B. Pass as callback | `ctx.git_log(path)` | Simple | Slightly awkward |
| C. Keep in core with isolation | Document as "external I/O" but keep simple | Pragmatic | Less pure |

**Open Question Q1:** Which approach should we use for subprocess abstraction?

### 2.5 Backwards Compatibility Shim

To maintain backwards compatibility, `ontos_lib.py` becomes a shim:

```python
# ontos_lib.py (DEPRECATED - backwards compatibility shim)
"""
DEPRECATED: Import from ontos.core instead.
This module will be removed in v3.0.
"""
import warnings
from ontos.core.frontmatter import parse_frontmatter, normalize_depends_on
from ontos.core.staleness import (
    ModifiedSource, normalize_describes, parse_describes_verified,
    validate_describes_field, detect_describes_cycles, check_staleness,
    get_file_modification_date, clear_git_cache
)
from ontos.core.history import (
    ParsedLog, parse_log_for_history, sort_logs_deterministically,
    generate_decision_history
)
# ... re-export all functions

def __getattr__(name):
    warnings.warn(
        f"ontos_lib.{name} is deprecated. Import from ontos.core instead.",
        DeprecationWarning,
        stacklevel=2
    )
    # Return the function from new location
```

**Open Question Q2:** Should we emit deprecation warnings immediately, or wait until v2.9?

---

## 3. Feature 2: Unified CLI

### 3.1 Design: ontos.py Dispatcher

**Current invocation:**
```bash
python3 .ontos/scripts/ontos_end_session.py -e feature
python3 .ontos/scripts/ontos_generate_context_map.py --strict
python3 .ontos/scripts/ontos_verify.py --all
```

**Proposed invocation:**
```bash
python3 ontos.py log -e feature          # Archive session
python3 ontos.py map --strict            # Generate context map
python3 ontos.py verify --all            # Verify describes
python3 ontos.py init                    # Initialize project
python3 ontos.py maintain                # Run maintenance
```

### 3.2 Command Mapping

| New Command | Old Script | Aliases |
|-------------|------------|---------|
| `ontos.py log` | `ontos_end_session.py` | `archive`, `session` |
| `ontos.py map` | `ontos_generate_context_map.py` | `context`, `generate` |
| `ontos.py verify` | `ontos_verify.py` | `check` |
| `ontos.py init` | `ontos_init.py` | `setup` |
| `ontos.py maintain` | `ontos_maintain.py` | `maintenance` |
| `ontos.py consolidate` | `ontos_consolidate.py` | `archive-old` |
| `ontos.py query` | `ontos_query.py` | `search`, `find` |
| `ontos.py update` | `ontos_update.py` | `upgrade` |

### 3.3 CLI Implementation

```python
#!/usr/bin/env python3
"""Ontos CLI - Unified command interface.

Usage:
    python3 ontos.py <command> [options]
    python3 ontos.py --help
    python3 ontos.py --version

Commands:
    log         Archive a session (creates log file)
    map         Generate context map
    verify      Verify describes dates
    init        Initialize Ontos in a project
    maintain    Run maintenance tasks
    consolidate Archive old logs
    query       Search documents
    update      Update Ontos scripts

Examples:
    python3 ontos.py log -e feature         # Log a feature session
    python3 ontos.py map --strict           # Generate with strict validation
    python3 ontos.py verify --all           # Verify all stale docs
"""

import sys
import argparse
from pathlib import Path

# Add scripts directory to path
SCRIPTS_DIR = Path(__file__).parent / '.ontos' / 'scripts'
sys.path.insert(0, str(SCRIPTS_DIR))

COMMANDS = {
    'log': ('ontos_end_session', 'Archive a session'),
    'map': ('ontos_generate_context_map', 'Generate context map'),
    'verify': ('ontos_verify', 'Verify describes dates'),
    'init': ('ontos_init', 'Initialize Ontos'),
    'maintain': ('ontos_maintain', 'Run maintenance'),
    'consolidate': ('ontos_consolidate', 'Archive old logs'),
    'query': ('ontos_query', 'Search documents'),
    'update': ('ontos_update', 'Update Ontos'),
}

ALIASES = {
    'archive': 'log', 'session': 'log',
    'context': 'map', 'generate': 'map',
    'check': 'verify',
    'setup': 'init',
    'maintenance': 'maintain',
    'archive-old': 'consolidate',
    'search': 'query', 'find': 'query',
    'upgrade': 'update',
}

def main():
    if len(sys.argv) < 2 or sys.argv[1] in ('-h', '--help'):
        print(__doc__)
        return 0

    if sys.argv[1] in ('-V', '--version'):
        from ontos_config_defaults import ONTOS_VERSION
        print(f"Ontos {ONTOS_VERSION}")
        return 0

    command = sys.argv[1]
    command = ALIASES.get(command, command)

    if command not in COMMANDS:
        print(f"Unknown command: {command}")
        print(f"Available: {', '.join(COMMANDS.keys())}")
        return 1

    module_name, _ = COMMANDS[command]

    # Import and run the module
    import importlib
    module = importlib.import_module(module_name)

    # Replace sys.argv for the subcommand
    sys.argv = [module_name + '.py'] + sys.argv[2:]

    return module.main()

if __name__ == '__main__':
    sys.exit(main() or 0)
```

### 3.4 Deprecation Strategy

**Phase 1 (v2.8):** Introduce `ontos.py`, no deprecation warnings yet.

**Phase 2 (v2.9):** Add deprecation warnings to direct script usage:
```python
# In each script's main():
if __name__ == '__main__':
    import warnings
    import sys
    script_name = Path(__file__).stem
    if 'ontos.py' not in ' '.join(sys.argv):
        warnings.warn(
            f"Direct script usage is deprecated. Use 'python3 ontos.py {COMMAND}' instead.",
            DeprecationWarning
        )
    main()
```

**Phase 3 (v3.0):** Scripts become internal-only, CLI is the only interface.

**Open Question Q3:** Should v2.8 emit any deprecation warnings, or keep it silent until v2.9?

### 3.5 Location of ontos.py

**Option A:** Project root (`ontos.py`)
- Pros: Easy discovery, matches v3.0 pattern
- Cons: Adds file to user's repo

**Option B:** Scripts directory (`.ontos/scripts/ontos.py`)
- Pros: Keeps user repo clean
- Cons: Longer path, less discoverable

**Option C:** Both (symlink or copy)
- Pros: Maximum flexibility
- Cons: Complexity, sync issues

**Open Question Q4:** Where should `ontos.py` be located?

---

## 4. Implementation Phases

### Phase 1: Core Library Split (Days 1-2)

| Task | Description | Risk |
|------|-------------|------|
| 1.1 | Create `ontos/` package structure | Low |
| 1.2 | Move pure functions to `ontos/core/` | Medium |
| 1.3 | Replace print() with warning collection | Medium |
| 1.4 | Implement `SessionContext` dataclass | Medium |
| 1.5 | Create backwards-compat shim in `ontos_lib.py` | Low |
| 1.6 | Update tests to use new imports | Medium |

### Phase 2: Context Integration (Day 3)

| Task | Description | Risk |
|------|-------------|------|
| 2.1 | Refactor `ontos_generate_context_map.py` to use context | High |
| 2.2 | Refactor `ontos_end_session.py` to use context | High |
| 2.3 | Add transaction boundaries (commit/rollback) | Medium |
| 2.4 | Verify all file writes go through context | Medium |

### Phase 3: Unified CLI (Day 4)

| Task | Description | Risk |
|------|-------------|------|
| 3.1 | Create `ontos.py` dispatcher | Low |
| 3.2 | Test all command mappings | Low |
| 3.3 | Update documentation | Low |
| 3.4 | Add --help for each command | Low |

### Phase 4: Testing & Polish (Day 5)

| Task | Description | Risk |
|------|-------------|------|
| 4.1 | Run full test suite | Low |
| 4.2 | Manual testing of all scripts | Low |
| 4.3 | Update Manual with new CLI syntax | Low |
| 4.4 | Version bump to 2.8.0 | Low |

---

## 5. Open Questions for LLM Review Board

### Architecture Questions

**Q1: Subprocess Abstraction Strategy**

How should we handle subprocess calls (git, etc.) in the pure core?

| Option | Vote Here |
|--------|-----------|
| A. Create `GitProvider` interface, inject into SessionContext | |
| B. Pass git operations as callbacks to functions | |
| C. Keep subprocess calls in core, document as "external I/O exception" | |
| D. Other (describe) | |

**Considerations:**
- v3.0 MCP Server will need to mock git for tests
- Over-abstraction adds complexity
- Current git calls are isolated to 2-3 functions

---

**Q2: Deprecation Warning Timing**

When should we start emitting deprecation warnings for old imports?

| Option | Vote Here |
|--------|-----------|
| A. v2.8: Immediate warnings on `from ontos_lib import ...` | |
| B. v2.9: Delayed warnings (v2.8 is silent transition) | |
| C. v3.0: Only warn at major version | |
| D. Never warn, just document | |

**Considerations:**
- Too early = annoys users during transition
- Too late = users don't migrate
- Warnings in tests are noisy

---

**Q3: CLI Deprecation for Direct Scripts**

When should `python3 .ontos/scripts/ontos_end_session.py` emit warnings?

| Option | Vote Here |
|--------|-----------|
| A. v2.8: Immediate warnings | |
| B. v2.9: Delayed warnings | |
| C. v3.0: Scripts become internal (not callable directly) | |
| D. Never deprecate, keep both paths forever | |

---

**Q4: ontos.py Location**

Where should the unified CLI entry point live?

| Option | Vote Here |
|--------|-----------|
| A. Project root: `./ontos.py` | |
| B. Scripts directory: `./.ontos/scripts/ontos.py` | |
| C. Both (primary in root, copy in scripts) | |
| D. User's choice during init | |

---

### Design Questions

**Q5: SessionContext Granularity**

How much state should SessionContext capture?

| Option | Vote Here |
|--------|-----------|
| A. Minimal: Just config + pending_writes | |
| B. Standard: Config + env + cwd + pending_writes + warnings | |
| C. Maximal: Above + git state + parsed docs cache | |

---

**Q6: Transaction Scope**

What is the scope of a transaction (commit/rollback)?

| Option | Vote Here |
|--------|-----------|
| A. Per-command: Each CLI command is one transaction | |
| B. Per-operation: Explicit commit() calls in code | |
| C. Nested: Support savepoints within commands | |

---

**Q7: Package Name**

What should the new package be called?

| Option | Vote Here |
|--------|-----------|
| A. `ontos/` (simple, matches v3.0) | |
| B. `ontos_core/` (distinguishes from future pip package) | |
| C. `_ontos/` (indicates internal) | |
| D. Keep everything flat (no package, just split files) | |

---

### Implementation Questions

**Q8: Test Migration Strategy**

How should we handle test file updates?

| Option | Vote Here |
|--------|-----------|
| A. Update all imports at once in one commit | |
| B. Gradual migration over multiple PRs | |
| C. Support both import paths in tests until v3.0 | |

---

**Q9: Config Injection**

How should SessionContext receive config?

| Option | Vote Here |
|--------|-----------|
| A. Constructor parameter: `SessionContext(config=load_config())` | |
| B. Class method: `SessionContext.from_repo(path)` | |
| C. Global singleton with override: `SessionContext.current()` | |
| D. Environment-based: Auto-detect from cwd | |

---

**Q10: File Locking Strategy**

The master plan mentions `.ontos/write.lock`. How should we implement it?

| Option | Vote Here |
|--------|-----------|
| A. `fcntl.flock()` (Unix only) | |
| B. `filelock` library (cross-platform, but adds dependency) | |
| C. Simple lock file with PID (stdlib only) | |
| D. No locking in v2.8, defer to v3.0 | |

**Considerations:**
- v2.x must remain zero-dependency
- Concurrent writes are rare in current usage
- v3.0 MCP Server will need proper locking

---

## 6. Success Criteria

v2.8 is complete when:

### Core Requirements

1. ✅ `ontos/core/` package exists with pure functions
2. ✅ `SessionContext` dataclass implemented
3. ✅ No print() statements in `ontos/core/`
4. ✅ All functions accept context parameter or are pure
5. ✅ Backwards-compat shim works for all existing imports
6. ✅ `ontos.py` CLI dispatcher works for all commands

### Testing Requirements

7. ✅ All 225+ tests pass
8. ✅ New tests for SessionContext (commit/rollback)
9. ✅ CLI commands work identically to old scripts

### Documentation Requirements

10. ✅ Manual updated with new CLI syntax
11. ✅ Migration guide for v2.7 → v2.8

### Quality Requirements

12. ✅ Strict validation passes
13. ✅ No new warnings in test suite
14. ✅ Performance unchanged (no regression)

---

## 7. Risk Analysis

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Breaking existing scripts | Medium | High | Backwards-compat shim, extensive testing |
| Over-engineering SessionContext | Medium | Medium | Start minimal, expand as needed |
| Test migration complexity | Low | Medium | Support both import paths temporarily |
| CLI command confusion | Low | Low | Clear aliases, good help text |
| Performance regression | Low | Low | Profile before/after |

### Rollback Plan

If v2.8 causes issues:

1. Revert to v2.7.1 (git revert)
2. `ontos_lib.py` shim ensures old code still works
3. No user data is affected (this is code-only change)

---

## 8. Testing Strategy

### 8.1 Unit Tests

```python
# test_context.py
class TestSessionContext:
    def test_buffer_write(self):
        ctx = SessionContext(repo_root=Path('/tmp'), config={})
        ctx.buffer_write(Path('/tmp/test.md'), 'content')
        assert len(ctx.pending_writes) == 1

    def test_commit_creates_file(self, tmp_path):
        ctx = SessionContext(repo_root=tmp_path, config={})
        ctx.buffer_write(tmp_path / 'test.md', 'content')
        modified = ctx.commit()
        assert (tmp_path / 'test.md').read_text() == 'content'
        assert len(modified) == 1

    def test_rollback_clears_buffer(self):
        ctx = SessionContext(repo_root=Path('/tmp'), config={})
        ctx.buffer_write(Path('/tmp/test.md'), 'content')
        ctx.rollback()
        assert len(ctx.pending_writes) == 0

    def test_warn_collects_warnings(self):
        ctx = SessionContext(repo_root=Path('/tmp'), config={})
        ctx.warn("Test warning")
        assert "Test warning" in ctx.warnings
```

### 8.2 Integration Tests

```python
# test_cli.py
class TestUnifiedCLI:
    def test_log_command(self, tmp_path, monkeypatch):
        monkeypatch.chdir(tmp_path)
        result = subprocess.run(['python3', 'ontos.py', 'log', '--help'])
        assert result.returncode == 0

    def test_map_command(self, tmp_path, monkeypatch):
        monkeypatch.chdir(tmp_path)
        result = subprocess.run(['python3', 'ontos.py', 'map', '--help'])
        assert result.returncode == 0

    def test_aliases_work(self, tmp_path, monkeypatch):
        monkeypatch.chdir(tmp_path)
        result = subprocess.run(['python3', 'ontos.py', 'archive', '--help'])
        assert result.returncode == 0  # 'archive' → 'log'
```

### 8.3 Regression Tests

- Run existing test suite without modification
- Verify backwards-compat shim preserves behavior
- Compare output of old vs new CLI for same operations

---

## 9. Appendix: Master Plan References

### From Section 0 (Core Invariants)

> **4. Functional Core, Imperative Shell:** Logic must be separated from I/O. The "Brain" (Logic) never calls print() or input().

### From Section II (Roadmap)

> **v2.8 Context Object Refactor (Arch):** SessionContext dataclass. Split ontos.lib.core (Pure) vs ontos.lib.ui.
>
> **v2.8 Unified CLI (UX):** Dispatcher python3 ontos.py [init|log]. Deprecate direct script usage.

### From Section III.1 (Context Object Pattern)

> We must implement a Transactional Session pattern. The Core Logic never touches disk directly; it buffers changes.

### Watch-outs from LLM Consensus

> **Claude/Gemini:** CRITICAL. Do not hide state. Use "Transaction Boundaries" (commit/rollback) for file writes. Logic layer must capture all env state (CWD, Env Vars) to be testable.
>
> **Codex:** Ensure this wrapper handles sys.argv parsing robustly. Provide clear deprecation warnings for old scripts.

---

*End of v2.8 Implementation Plan v1.0.0*

*Awaiting LLM Review Board approval before implementation.*
