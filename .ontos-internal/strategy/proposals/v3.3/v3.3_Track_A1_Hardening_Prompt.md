---
id: v3_3_track_a1_hardening_prompt
type: strategy
status: draft
depends_on: [v3_3_track_a1_adversarial_review]
concepts: [cleanup, testing, schema]
---

# v3.3 Track A1 Hardening — Implementation Prompt

**Source:** Round 2 Adversarial Review (`v3.3_Track_A1_Adversarial_Review.md`)
**Scope:** 11 remaining items (4 accepted/document, 4 backlog cleanup, 3 observations)
**Priority:** P3 — none of these block the PR #67 merge

---

## Instructions

Fix all 11 items below in a single branch (`fix/v3.3-a1-hardening`). Each item includes the exact file, line numbers, current code, what's wrong, and what to do. Items are ordered by dependency — complete them top-to-bottom.

After all fixes, run:

```bash
python -m pytest tests/ -x
python -m ontos map
```

All 636+ existing tests must pass. `ontos map` must produce zero new errors. New tests are specified per-item below.

---

## Item 1 — VUL-08: Remove 4 Unused `parse_frontmatter` Imports

**Why:** Dead imports from the pre-unification codebase. They make it look like legacy parser paths are still active and confuse future reviewers.

**Files and exact lines to change:**

### `ontos/commands/promote.py` line 7

Current:
```python
from ontos.core.frontmatter import parse_frontmatter
```

Action: **Delete this line.** The file only uses `parse_frontmatter_content` (imported from `ontos.io.yaml` at line 10).

### `ontos/commands/maintain.py` line 20

Current:
```python
from ontos.core.frontmatter import parse_frontmatter
```

Action: **Delete this line.** The file uses `parse_frontmatter_content` at lines 247, 374, 450 (imported from `ontos.io.yaml`).

### `ontos/commands/scaffold.py` line 7

Current:
```python
from ontos.core.frontmatter import parse_frontmatter
```

Action: **Delete this line.** The file uses `parse_frontmatter_content` at lines 63, 86, 150 (imported from `ontos.io.yaml`).

### `ontos/commands/verify.py` line 9

Current:
```python
from ontos.core.frontmatter import parse_frontmatter
```

Action: **Delete this line.** The file uses `parse_frontmatter_content` at lines 37, 151, 224 (imported from `ontos.io.yaml`).

**Verification:** `grep -rn "from ontos.core.frontmatter import parse_frontmatter" ontos/commands/` should return zero results after the fix.

**Test:** No new test needed — existing tests confirm these imports are unused.

---

## Item 2 — VUL-09: Delete `parse_frontmatter_yaml()` Legacy Wrapper

**Why:** CC-13 audit finding recommended deletion. The function is marked "NON-CANONICAL internal-legacy API" and adds API surface confusion. The module currently exports three overlapping functions: `parse_yaml`, `parse_frontmatter_yaml`, and `parse_frontmatter_content`.

**File:** `ontos/io/yaml.py` lines 45-57

Current:
```python
def parse_frontmatter_yaml(content: str) -> Optional[Dict[str, Any]]:
    """Parse YAML frontmatter from document content.

    NON-CANONICAL internal-legacy API. Wraps parse_frontmatter_content.

    Args:
        content: Full document content with potential frontmatter

    Returns:
        Parsed frontmatter dict, or None if no valid frontmatter found
    """
    fm, _ = parse_frontmatter_content(content)
    return fm if fm else None
```

Action: **Delete this entire function (lines 45-57).** Then search the entire codebase for any caller:

```bash
grep -rn "parse_frontmatter_yaml" ontos/ tests/
```

If any callers exist, replace them with `parse_frontmatter_content()` and unpack the tuple. Example:

```python
# Before
fm = parse_frontmatter_yaml(content)

# After
fm, _ = parse_frontmatter_content(content)
```

Also remove `parse_frontmatter_yaml` from any `__all__` exports or re-exports if present.

**Test:** No new test needed — removal of dead code.

---

## Item 3 — VUL-10: Fix Bare `except:` in `io/snapshot.py`

**Why:** Bare `except:` catches `KeyboardInterrupt`, `SystemExit`, and `GeneratorExit`, which masks fatal signals. Standard Python practice is `except Exception:`.

**File:** `ontos/io/snapshot.py` lines 88-92

Current:
```python
git_commit = None
if git_commit_provider:
    try:
        git_commit = git_commit_provider()
    except:
        pass
```

Change to:
```python
git_commit = None
if git_commit_provider:
    try:
        git_commit = git_commit_provider()
    except Exception:
        pass
```

**Test:** No new test needed — behavioral change only affects exceptional signal handling.

---

## Item 4 — VUL-07: Remove 2 Residual `hasattr` Defensive Checks

**Why:** The CC-06 cleanup removed all `hasattr(doc.type, 'value')` patterns because the unified loader guarantees typed `DocumentData` objects with all fields populated. These two `hasattr(doc, ...)` checks are the same dead defensive pattern — `DocumentData` is a dataclass that always has `depends_on` and `aliases` attributes.

**File 1:** `ontos/core/graph.py` line 76

Current:
```python
depends_on = doc.depends_on if hasattr(doc, 'depends_on') else []
```

Change to:
```python
depends_on = doc.depends_on
```

**File 2:** `ontos/core/suggestions.py` line 213

Current:
```python
aliases = doc.aliases if hasattr(doc, 'aliases') else []
```

Change to:
```python
aliases = doc.aliases
```

**Verification:** Confirm `DocumentData` in `ontos/core/types.py` defines both `depends_on` and `aliases` as fields with default values (they should default to empty list `field(default_factory=list)` or similar). If for some reason these fields don't have defaults and could be missing, do NOT make this change — instead add a comment explaining why the `hasattr` is needed.

**Test:** Existing tests cover these paths. Run `python -m pytest tests/ -k "graph or suggestion" -x` to verify.

---

## Item 5 — VUL-04: Document the `.lstrip()` Frontmatter Detection Boundary

**Why:** The `.lstrip()` call changes behavior vs. the legacy parser — files with leading whitespace before `---` are now detected as having frontmatter when they previously weren't. This is intentional but undocumented in-code.

**File:** `ontos/io/files.py` lines 213-215

Current (approximate):
```python
raw_bytes = raw_bytes[3:]
content = raw_bytes.decode('utf-8', errors='replace').lstrip()
```

Action: Add a comment explaining the design choice:

```python
raw_bytes = raw_bytes[3:]
# .lstrip() intentionally strips leading whitespace/BOM before frontmatter detection.
# This is more lenient than the legacy parser (core/frontmatter.py) which required
# content.startswith('---') with no leading whitespace. The leniency handles BOM
# artifacts and minor formatting issues in imported/external files.
content = raw_bytes.decode('utf-8', errors='replace').lstrip()
```

Apply the same comment pattern to any other `.lstrip()` call on content in this file (check line 279 as well).

**Test:** Add one test to codify the intended behavior:

```python
# In tests/test_document_loading_contract_a1.py

def test_lstrip_frontmatter_detection_with_leading_whitespace(tmp_path):
    """VUL-04: Verify that leading whitespace before --- is handled leniently."""
    content = "\n\n---\nid: lstrip_test\ntype: atom\n---\nBody content"
    path = tmp_path / "lstrip_test.md"
    path.write_text(content)

    doc, issues = load_document_from_content(path, content, parse_frontmatter_content)

    # The lstrip behavior means this IS detected as having frontmatter
    assert doc.id == "lstrip_test"
```

---

## Item 6 — VUL-06: Load Vocabulary From `Common_Concepts.md` Instead of Self-Referencing

**Why:** The current implementation collects all concepts from all documents and passes them as `known_concepts`. Since every concept that exists is by definition "known," the vocabulary check never fires. The fix loads the authoritative vocabulary from `Common_Concepts.md`.

**File:** `ontos/commands/map.py` lines 68-86

Current:
```python
# Collect vocabulary for concepts validation (#42 / CC-16)
all_concepts = set()
for doc in docs.values():
    concepts = doc.frontmatter.get("concepts")
    if isinstance(concepts, list):
        for c in concepts:
            if isinstance(c, str):
                all_concepts.add(c)
```

Change to:
```python
# Load authoritative vocabulary from Common_Concepts.md (#42 / CC-16 / VUL-06)
known_concepts = _load_known_concepts(root)
```

Add a helper function in the same file (or in `ontos/core/curation.py` if you prefer a shared location):

```python
def _load_known_concepts(root: Path) -> set:
    """Load known concept vocabulary from Common_Concepts.md.

    Returns an empty set if the file doesn't exist or can't be parsed,
    which disables vocabulary checking (structural checks still run).
    """
    # Check both possible locations
    for candidate in [
        root / ".ontos-internal" / "reference" / "Common_Concepts.md",
        root / "docs" / "reference" / "Common_Concepts.md",
    ]:
        if candidate.exists():
            try:
                content = candidate.read_text(encoding='utf-8')
                concepts = set()
                # Extract concept names from the markdown table rows
                # Format: | `concept_name` | ... |
                for line in content.split('\n'):
                    line = line.strip()
                    if line.startswith('|') and '`' in line:
                        cells = line.split('|')
                        if len(cells) >= 2:
                            cell = cells[1].strip()
                            # Extract backtick-wrapped concept name
                            if cell.startswith('`') and cell.endswith('`'):
                                concepts.add(cell[1:-1])
                return concepts
            except Exception:
                pass
    return set()
```

Then update the `ValidationOrchestrator` call to use `known_concepts` instead of `all_concepts`:

```python
validator = ValidationOrchestrator(docs, {
    ...
    "known_concepts": known_concepts
})
```

**Important behavioral note:** If `Common_Concepts.md` doesn't exist or is empty, `known_concepts` will be an empty set, which means the vocabulary check is silently skipped (same as today). The structural checks (empty, non-string, duplicate) still run regardless.

**Test:**

```python
# In tests/commands/test_map.py (or new file test_map_vocabulary.py)

def test_map_vocabulary_check_uses_authoritative_source(tmp_path, monkeypatch):
    """VUL-06: Vocabulary check should use Common_Concepts.md, not self-reference."""
    # Set up minimal project structure
    docs_dir = tmp_path / "docs"
    docs_dir.mkdir()

    # Create a doc with a concept NOT in Common_Concepts.md
    (docs_dir / "test.md").write_text(
        "---\nid: test_doc\ntype: atom\nconcepts: [auth, totally_unknown_concept]\n---\nBody"
    )

    # Create Common_Concepts.md with only 'auth'
    ref_dir = tmp_path / ".ontos-internal" / "reference"
    ref_dir.mkdir(parents=True)
    (ref_dir / "Common_Concepts.md").write_text(
        "---\nid: common_concepts\ntype: atom\n---\n"
        "# Common Concepts\n\n"
        "| Concept | Covers |\n|:---|:---|\n| `auth` | Authentication |\n"
    )

    # _load_known_concepts should return {'auth'}
    from ontos.commands.map import _load_known_concepts
    concepts = _load_known_concepts(tmp_path)
    assert concepts == {"auth"}
```

---

## Item 7 — VUL-11: Document Case-Sensitive Duplicate Detection

**Why:** The duplicate ID comparison is case-sensitive. `my_doc` and `MY_DOC` are treated as different IDs. This is correct (YAML is case-sensitive) but undocumented. Track B `rename` will need to decide its case-matching semantics.

**File:** `ontos/io/files.py` — in the `load_documents()` function, near the duplicate check

Action: Add a comment at the duplicate comparison:

```python
# Duplicate ID detection is case-sensitive by design.
# YAML keys are case-sensitive per spec, so 'my_doc' and 'MY_DOC' are distinct IDs.
# Track B rename should preserve this behavior.
if doc.id in documents:
```

**Test:** Add one explicit test:

```python
# In tests/test_document_loading_contract_a1.py

def test_loader_duplicate_detection_is_case_sensitive(tmp_path):
    """VUL-11: IDs differing only in case should be treated as distinct."""
    docs_dir = tmp_path / "docs"
    docs_dir.mkdir()

    (docs_dir / "lower.md").write_text("---\nid: my_doc\ntype: atom\n---\n")
    (docs_dir / "upper.md").write_text("---\nid: MY_DOC\ntype: atom\n---\n")

    files = list(docs_dir.glob("*.md"))
    load_result = load_documents(files, parse_frontmatter_content)

    # Both should load — they are NOT duplicates
    assert "my_doc" in load_result.documents
    assert "MY_DOC" in load_result.documents
    assert len(load_result.duplicate_ids) == 0
```

---

## Item 8 — VUL-12: Document Empty Config in Snapshot Validation

**Why:** `create_snapshot()` passes `{}` to `ValidationOrchestrator`, which means no vocabulary checking. This is acceptable (snapshot is IO-layer, shouldn't need vocabulary) but should be explicit.

**File:** `ontos/io/snapshot.py` lines 82-84

Current:
```python
# Run validation
orchestrator = ValidationOrchestrator(filtered_docs, {})
validation_result = orchestrator.validate_all()
```

Change to:
```python
# Run structural validation only (no vocabulary check).
# Snapshot is an IO-layer operation — vocabulary checking requires
# project-level config (known_concepts) which is a command-layer concern.
orchestrator = ValidationOrchestrator(filtered_docs, {})
validation_result = orchestrator.validate_all()
```

**Test:** No new test needed — documentation-only change.

---

## Item 9 — OBS-01: Eliminate Double Document Load in `consolidate.py`

**Why:** `consolidate_command()` loads documents at line 163 to check for errors, then calls `find_logs_to_consolidate()` which loads the exact same documents again at line 43. This is pure waste — the load result should be computed once and passed through.

**File:** `ontos/commands/consolidate.py`

### Step 1: Modify `find_logs_to_consolidate()` to accept an optional pre-loaded result

Current signature (line 36):
```python
def find_logs_to_consolidate(options: ConsolidateOptions) -> List[Tuple[Path, str, dict]]:
```

Change to:
```python
def find_logs_to_consolidate(options: ConsolidateOptions, load_result=None) -> List[Tuple[Path, str, dict]]:
```

Then at line 42-45, conditionally load:

Current:
```python
all_logs = []
load_result = load_documents(list(logs_dir.glob("*.md")), parse_frontmatter_content)
if load_result.has_fatal_errors or load_result.duplicate_ids:
    return []
```

Change to:
```python
all_logs = []
if load_result is None:
    load_result = load_documents(list(logs_dir.glob("*.md")), parse_frontmatter_content)
    if load_result.has_fatal_errors or load_result.duplicate_ids:
        return []
```

### Step 2: Pass the load result from `consolidate_command()`

In `consolidate_command()`, around lines 162-170:

Current:
```python
logs_dir = Path(get_logs_dir())
if logs_dir.exists():
    load_result = load_documents(list(logs_dir.glob("*.md")), parse_frontmatter_content)
    if load_result.has_fatal_errors or load_result.duplicate_ids:
        for issue in load_result.issues:
            if issue.code in {"duplicate_id", "parse_error", "io_error"}:
                output.error(issue.message)
        return 1, "Document load failed"

logs_to_consolidate = find_logs_to_consolidate(options)
```

Change to:
```python
logs_dir = Path(get_logs_dir())
load_result = None
if logs_dir.exists():
    load_result = load_documents(list(logs_dir.glob("*.md")), parse_frontmatter_content)
    if load_result.has_fatal_errors or load_result.duplicate_ids:
        for issue in load_result.issues:
            if issue.code in {"duplicate_id", "parse_error", "io_error"}:
                output.error(issue.message)
        return 1, "Document load failed"

logs_to_consolidate = find_logs_to_consolidate(options, load_result=load_result)
```

**Test:** Existing consolidate tests should continue passing. No new test needed — this is a pure optimization with no behavioral change.

---

## Item 10 — OBS-02: Add Code Comment Explaining `normalize_describes` vs `normalize_reference_list` Asymmetry

**Why:** `normalize_reference_list()` coerces `int/float/bool` to strings (for `depends_on`/`impacts`), while `normalize_describes()` drops non-strings entirely. This is documented as intentional by tests (`doc.describes == ["valid_atom"]`), but the code lacks an explanation of why.

**File:** `ontos/core/staleness.py` — in `normalize_describes()`, at the non-string handling block

Current (around line 153):
```python
            else:
                if on_warning:
                    on_warning(f"Non-string member '{v}' in describes field dropped.")
```

Change to:
```python
            else:
                # describes targets must be exact document IDs (always strings).
                # Unlike normalize_reference_list() which coerces int/float/bool
                # for depends_on/impacts (YAML convenience), describes is strict:
                # non-string values are dropped, not coerced.
                if on_warning:
                    on_warning(f"Non-string member '{v}' in describes field dropped.")
```

**Test:** No new test needed — the existing test at `test_document_loading_contract_a1.py:43-58` already asserts the drop behavior.

---

## Item 11 — OBS-03: Add Explicit Duplicate Handling to `scaffold.py`

**Why:** After the VUL-03 fix, `has_fatal_errors` no longer includes `duplicate_id`. Scaffold silently continues with first-wins on duplicates. This may be intentional (scaffold creates new files and doesn't care about existing duplicates), but it's inconsistent with `consolidate` and `map` which both fail. The behavior should be explicit.

**File:** `ontos/commands/scaffold.py` line 64

Current:
```python
load_result = load_documents(files, parse_frontmatter_content)
if load_result.has_fatal_errors:
    # We can't safely scaffold if the graph is broken
    return []
```

Change to:
```python
load_result = load_documents(files, parse_frontmatter_content)
if load_result.has_fatal_errors:
    # We can't safely scaffold if the graph is broken
    return []
# Duplicate IDs are intentionally tolerated in scaffold context.
# Scaffold creates new files and only needs the existing ID set for
# collision avoidance — first-wins resolution is sufficient.
```

Also check if there are other `load_documents` + `has_fatal_errors` gates in scaffold.py (the explore agent found calls at lines 63, 86, 150). Apply the same comment pattern where relevant, or add duplicate-fails logic if the context requires it.

**Test:**

```python
# In tests/commands/test_scaffold_parity.py (new file or existing)

def test_scaffold_tolerates_duplicate_ids(tmp_path, monkeypatch):
    """OBS-03: Scaffold should continue despite duplicate IDs."""
    docs_dir = tmp_path / "docs"
    docs_dir.mkdir()

    (docs_dir / "a.md").write_text("---\nid: collision\ntype: atom\n---\n")
    (docs_dir / "b.md").write_text("---\nid: collision\ntype: atom\n---\n")
    (docs_dir / "untagged.md").write_text("# No frontmatter\nJust content")

    # scaffold should still find untagged.md despite the duplicate collision
    from ontos.commands.scaffold import find_untagged_files
    # (adjust imports and setup as needed for your test harness)
```

---

## Checklist

After completing all 11 items:

- [ ] `grep -rn "from ontos.core.frontmatter import parse_frontmatter" ontos/` → 0 results
- [ ] `grep -rn "parse_frontmatter_yaml" ontos/` → 0 results
- [ ] `grep -rn "except:" ontos/` → 0 results (or only legitimate bare excepts)
- [ ] `grep -rn "hasattr(doc," ontos/core/` → 0 results
- [ ] `python -m pytest tests/ -x` → all pass
- [ ] `python -m ontos map` → runs successfully, check warning count
- [ ] All new comments use imperative voice, no TODOs left behind
- [ ] No unrelated formatting changes in the diff

---

## Files Changed (Expected)

| File | Change Type |
|---|---|
| `ontos/commands/promote.py` | Remove import |
| `ontos/commands/maintain.py` | Remove import |
| `ontos/commands/scaffold.py` | Remove import, add comment |
| `ontos/commands/verify.py` | Remove import |
| `ontos/commands/map.py` | Replace self-referencing vocab with `_load_known_concepts()` |
| `ontos/commands/consolidate.py` | Eliminate double load |
| `ontos/io/yaml.py` | Delete `parse_frontmatter_yaml()` |
| `ontos/io/snapshot.py` | Fix bare except, add validation comment |
| `ontos/io/files.py` | Add `.lstrip()` comment, add case-sensitivity comment |
| `ontos/core/graph.py` | Remove `hasattr` guard |
| `ontos/core/suggestions.py` | Remove `hasattr` guard |
| `ontos/core/staleness.py` | Add asymmetry rationale comment |
| `tests/test_document_loading_contract_a1.py` | Add 2 tests (lstrip, case-sensitivity) |
| `tests/commands/test_map.py` | Add vocabulary test |
| `tests/commands/test_scaffold_parity.py` | Add duplicate tolerance test |
