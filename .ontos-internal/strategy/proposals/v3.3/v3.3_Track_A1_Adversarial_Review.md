---
id: v3_3_track_a1_adversarial_review
type: review
status: active
depends_on: [v3_3_track_a1_implementation_spec, v3_3_merged_audit_findings]
concepts: [v3.3, track-a1, adversarial-review, code-review]
---

# v3.3 Track A1 Adversarial Review — Phase D

**PR:** #67 (`feature/v3.3-track-a1-unified-loader`)
**Reviewer:** Claude Code (Adversarial Track)
**Date:** 2026-02-11

---

## Verdict: Request Changes

Three critical vulnerabilities found in production code paths. One causes a crash on real library content. One silently corrupts data. One breaks backward compatibility for every user with duplicate IDs. All three are exploitable during normal `ontos map` or `ontos query` usage — no exotic inputs required.

**Unblock requirements (must fix before merge):**

1. Fix `validate_concepts()` TypeError crash on unhashable concept values (VUL-01)
2. Fix `normalize_describes()` "dropped but kept" inconsistency (VUL-02)
3. Make `has_fatal_errors` not include `duplicate_id` unconditionally, or provide commands a way to continue with duplicates (VUL-03)

---

## Vulnerabilities Found

### Critical (Exploitable in Normal Use)

#### VUL-01 — validate_concepts() Crashes on Unhashable Concept Values

| Field | Detail |
|-------|--------|
| **Files** | `ontos/core/validation.py:279` |
| **Severity** | Critical — crash, zero output |
| **Track B impact** | Yes — link-check and rename both call `validate_all()` |

**Attack scenario:**

Any document with a dict or nested list in its `concepts` field:

```yaml
---
id: some_doc
concepts: [{key: val}, "normal-concept"]
---
```

PyYAML `safe_load` produces `[{"key": "val"}, "normal-concept"]` — a list containing a dict.

**Execution trace:**

1. `validate_concepts()` at validation.py:242: `concepts = doc.frontmatter.get("concepts")` → `[{"key": "val"}, "normal-concept"]`
2. Line 255: `if concepts:` → True
3. Line 256: `if not isinstance(concepts, list):` → False (it IS a list)
4. Line 267: `non_strings = [str(c) for c in concepts if not isinstance(c, str)]` → `["{'key': 'val'}"]` — detects the dict and reports a warning at line 269
5. **Line 279:** `if len(concepts) != len(set(concepts)):` → **`TypeError: unhashable type: 'dict'`**

The non-string check at line 267 correctly identifies the dict, but execution falls through to the duplicate check at line 279 where `set()` crashes on unhashable types.

**Blast radius:** Every code path that calls `validate_all()`:
- `ontos map` (map.py:82)
- `io/snapshot.py:84` (affects export_data, migration_report)
- Any future command using the orchestrator

**Expected behavior:** Warning about non-hashable concepts, then skip duplicate check.

**Actual behavior:** Unhandled `TypeError`, full crash, no output.

**Why tests missed it:** Test at `test_validation_concepts_a1.py:23` uses `concepts: ["c1", 123]` — an int (hashable). No test uses a dict (unhashable). The test exercises the non-string warning path but not the subsequent set() crash.

**Fix:** Guard the duplicate check:

```python
try:
    if len(concepts) != len(set(concepts)):
        ...
except TypeError:
    pass  # Already warned about non-hashable items above
```

---

#### VUL-02 — normalize_describes() Says "Dropped" But Keeps Values

| Field | Detail |
|-------|--------|
| **Files** | `ontos/core/staleness.py:154-156` vs `ontos/core/frontmatter.py:187-189` |
| **Severity** | Critical — silent data corruption + misleading diagnostics |
| **Track B impact** | Yes — rename must understand what describes targets exist |

**Attack scenario:**

```yaml
---
id: my_doc
describes:
  - valid_atom
  - 123
  - [nested, list]
---
```

**Execution trace for `normalize_describes()` (staleness.py:129-161):**

1. Item `123` (int): Line 153 — `isinstance(v, str)` → False
2. Line 154-155: Warning emitted: `"Non-string member '123' in describes field dropped."`
3. **Line 156:** `results.append(str(v))` — **VALUE IS KEPT as "123"**

The warning says **"dropped"** but the code **keeps** the value by converting it to string.

Compare with `normalize_reference_list()` (frontmatter.py:175-190) for `depends_on`/`impacts`:

```python
# frontmatter.py:187-189
else:
    if on_warning:
        on_warning(f"Invalid nested type ... dropped.")
    # NO append — item truly dropped
```

For `depends_on`, non-scalar items are genuinely dropped. For `describes`, they claim to be "dropped" but are kept. The two normalizers have divergent contracts despite serving the same purpose.

**Impact:**
- Users see "dropped" warnings but the corrupted values persist in `doc.describes`
- `validate_describes()` at validation.py:228-235 checks these corrupted string-ified values against `valid_ids`
- `"123"` becomes a describes target that doesn't match any real document ID → generates a broken-reference warning
- The user gets TWO warnings for the same problem: "dropped" (false) and "not found" (true but confusing)
- Track B `rename` would need to handle these ghost describes targets

**Fix:** Either truly drop (remove `results.append(str(v))`) or fix the warning message to say "coerced to string" instead of "dropped."

---

#### VUL-03 — has_fatal_errors Unconditionally Blocks All Commands on Duplicate IDs

| Field | Detail |
|-------|--------|
| **Files** | `ontos/io/files.py:44-47`, 11 callsites across 8 commands |
| **Severity** | Critical — breaks backward compatibility |
| **Track B impact** | Yes — link-check/rename must handle existing libraries with duplicates |

**Attack scenario:** Any library with two files sharing the same `id` field in their frontmatter. This is common — the Content Report found duplicate IDs in the real library.

**The change:**

```python
# files.py:44-47
@property
def has_fatal_errors(self) -> bool:
    fatal_codes = {"duplicate_id", "parse_error", "io_error"}
    return any(issue.code in fatal_codes for issue in self.issues)
```

Every command gates execution on this:
- `query.py:165`: `if load_result.has_fatal_errors: return 1, "Document load failed"`
- `map.py:743`, `scaffold.py:64,152`, `consolidate.py:44,164`, `promote.py:169`, `verify.py:38,153`, `migrate.py:72`

**Old behavior:** `dict[doc.id] = doc` — silent overwrite, command continues.
**New behavior:** Exit code 1, no output, "Document load failed."

This is a hard behavioral regression. Users who previously ran `ontos query --health` successfully will now get a failure message with zero health output if ANY file in the scan scope has a duplicate ID. The query command scans the entire project root (`scan_docs_for_query` at query.py:38 passes `[root]`), so even a stray file with a conflicting ID blocks everything.

**Per-command severity analysis:**

The implementation spec (section 4.2) says "commands choose severity." But `has_fatal_errors` makes the choice for them — `duplicate_id` is always fatal. No command overrides this. The claimed policy of "query: warn and continue with canonical" is not implemented — query fails hard.

| Command | Spec intent | Actual behavior |
|---------|------------|-----------------|
| map | error | error (correct) |
| query | warn + continue | **error (wrong)** |
| maintain | task failed | no check (see VUL-05) |
| snapshot | warn + continue | **no check** |
| verify | unclear | error |
| scaffold | unclear | error |

**Fix:** Either (a) remove `duplicate_id` from `has_fatal_errors` and let each command check `load_result.duplicate_ids` explicitly, or (b) add a `has_blocking_errors` property that excludes duplicates for commands that should continue.

---

### Potential (Requires Specific Conditions)

#### VUL-04 — .lstrip() Changes Frontmatter Detection Boundary

| Field | Detail |
|-------|--------|
| **Files** | `ontos/io/files.py:215` |
| **Severity** | Potential — behavioral divergence from legacy parser |

**The change:**

```python
# files.py:215
content = raw_bytes.decode('utf-8', errors='replace').lstrip()
```

The legacy parser (`core/frontmatter.py:47-52`) reads content without stripping:

```python
with open(filepath, 'r', encoding='utf-8', errors='replace') as f:
    content = f.read()
if not content.startswith('---'):
    return None
```

After `.lstrip()`, a file starting with `\n---\nid: test\n---\n` is now detected as having frontmatter. The old parser would return None (no frontmatter) because `content.startswith('---')` would be False.

**Impact:** Documents that were previously "plain markdown" (ignored by the graph, never validated) could become frontmatter documents. Their content would be parsed as YAML, potentially generating false errors. This is an invisible behavioral change — no warning or diagnostic indicates the frontier shifted.

**Likelihood:** Low-to-medium. Files in the library are generally well-formed, but imported/external files could have leading whitespace.

---

#### VUL-05 — maintain.py Doesn't Check has_fatal_errors

| Field | Detail |
|-------|--------|
| **Files** | `ontos/commands/maintain.py:245-249` |
| **Severity** | Potential — silent degradation |

`_load_docs_for_graph()` returns `load_documents()` result directly. No `has_fatal_errors` check anywhere in the maintain command's graph-dependent tasks. This means:

- Duplicate IDs are silently resolved to first-wins
- Parse errors are silently skipped
- The maintain command operates on a potentially incomplete document set without warning

Contrast with every other command which fails hard. This asymmetry is undocumented and likely unintentional.

---

#### VUL-06 — Vocabulary Check is Effectively a No-Op in map.py

| Field | Detail |
|-------|--------|
| **Files** | `ontos/commands/map.py:64-70,80` |
| **Severity** | Potential — feature doesn't deliver value |

```python
# map.py:64-70 — collect ALL concepts from ALL docs
all_concepts = set()
for doc in docs.values():
    concepts = doc.frontmatter.get("concepts")
    if isinstance(concepts, list):
        for c in concepts:
            if isinstance(c, str):
                all_concepts.add(c)

# map.py:80 — pass as known vocabulary
"known_concepts": all_concepts
```

`validate_concepts()` at validation.py:291-301 checks each document's concepts against `known_concepts`. But `known_concepts` is the union of ALL concepts from ALL documents. Every concept that exists is, by definition, "known." The vocabulary check can only fire if a concept appears for the first time in a single document and nowhere else — which is indistinguishable from a correctly-used new concept.

This renders the CC-16 fix (concepts validation) weaker than the spec implies. The structural checks (duplicates, empty lists, non-strings) work. The vocabulary check does not.

**Fix:** Load vocabulary from an authoritative source (Common_Concepts.md) rather than from the documents being validated.

---

#### VUL-07 — Residual Defensive Checks Contradict CC-06 Cleanup Premise

| Field | Detail |
|-------|--------|
| **Files** | `ontos/core/graph.py:76`, `ontos/core/suggestions.py:213` |
| **Severity** | Potential — inconsistency |

Two `hasattr(doc, ...)` checks survive:

```python
# graph.py:76
depends_on = doc.depends_on if hasattr(doc, 'depends_on') else []

# suggestions.py:213
aliases = doc.aliases if hasattr(doc, 'aliases') else []
```

These are different from the CC-06 `hasattr(doc.type, 'value')` enum checks, but they follow the same defensive pattern. If the unified loader guarantees `DocumentData` with all fields populated, these checks are dead code. If it doesn't, the CC-06 cleanup was premature.

Either remove them (consistent with CC-06 cleanup) or explain why `depends_on`/`aliases` need defense when `type`/`status` don't.

---

#### VUL-08 — Unused Imports of parse_frontmatter in 4 Commands

| Field | Detail |
|-------|--------|
| **Files** | `promote.py:7`, `maintain.py:20`, `scaffold.py:7`, `verify.py:9` |
| **Severity** | Potential — confuses migration audit |

Four command files import `parse_frontmatter` from `ontos.core.frontmatter` but never call it. Migration is functionally complete (all runtime paths use canonical loader), but the leftover imports create confusion about whether migration is truly done.

A `grep` for `parse_frontmatter` finds these imports and makes it look like legacy paths are still active. Future reviewers (or Track B implementers) may waste time verifying these are dead imports.

**Fix:** Remove unused imports.

---

### Theoretical (Defensive)

#### VUL-09 — parse_frontmatter_yaml() Not Deleted (CC-13)

`ontos/io/yaml.py:45-57` retains `parse_frontmatter_yaml()` as a thin wrapper around `parse_frontmatter_content()`, marked "NON-CANONICAL." The CC-13 audit finding recommended deletion. Keeping it as a wrapper is technically safe but adds API surface confusion — the module now exports `parse_yaml`, `parse_frontmatter_yaml`, and `parse_frontmatter_content`, three of which have overlapping purposes.

#### VUL-10 — Bare except in io/snapshot.py:91

```python
try:
    git_commit = git_commit_provider()
except:
    pass
```

Bare `except:` catches `KeyboardInterrupt`, `SystemExit`, and `GeneratorExit`. Should be `except Exception:`.

#### VUL-11 — Duplicate ID Detection is Case-Sensitive (Undocumented)

`load_documents()` compares `doc.id` directly (`if doc.id in documents`). IDs `v3_2_4_proposal` and `V3_2_4_Proposal` are treated as different. This is likely correct (IDs come from YAML which is case-sensitive), but should be documented since Track B rename will need to decide its case-matching semantics.

#### VUL-12 — io/snapshot.py Runs validate_all() Without Concepts Config

`io/snapshot.py:83` creates `ValidationOrchestrator(filtered_docs, {})` with empty config. This means:
- `known_concepts` defaults to empty set → vocabulary check silently skipped (OK)
- `severity_map` defaults to `REFERENCE_SEVERITY_DEFAULT` → all defaults apply
- But if any document has unhashable concepts → VUL-01 crash applies here too

---

## Regression Risk Assessment

| Behavior | Before PR #67 | After PR #67 | Intentional? |
|----------|--------------|-------------|--------------|
| Duplicate IDs in query scope | Silent overwrite, command works | Exit code 1, no output | **Unclear — spec says "warn+continue" but code says "fail"** |
| Duplicate IDs in maintain scope | Silent overwrite | Silent first-wins (no `has_fatal_errors` check) | **Accidental asymmetry** |
| Leading whitespace before `---` | No frontmatter detected | Frontmatter detected | **Accidental** |
| Concepts validation on `ontos map` | Not run | Run (structural checks + no-op vocab check) | **Intentional** — new warnings will appear |
| Enum defensive checks | Graceful degradation to string | Direct `.value` access | **Intentional** — correct if loader guarantees enums |
| `query --health` graph builder | Local simple dict-based | Core `DependencyGraph` object | **Intentional** — verify output parity |

---

## Test Gap Analysis

**Priority 1 — Must add before merge:**

1. **Unhashable concepts crash (VUL-01):** Test `validate_concepts()` with `concepts: [{"key": "val"}]`. Currently zero tests for unhashable types. This will crash in production.

2. **`load_documents()` with duplicate IDs:** No test verifies that `load_documents()` handles duplicates correctly (first-wins, issues recorded, `duplicate_ids` dict populated). This is a Track B prerequisite.

3. **`load_documents()` end-to-end with real content:** No integration test loads multiple files and checks the full pipeline (scan → load → normalize → deduplicate → result). Unit tests exist for individual functions but the orchestration is untested.

**Priority 2 — Should add:**

4. **`.lstrip()` frontmatter boundary change:** Test that a file with `\n---\nid: test\n---\n` is handled as expected (document or ignored). Codify the intended behavior.

5. **`query_health` output parity:** Before/after test comparing `query --health` output structure to ensure the graph builder switch didn't change results.

6. **`normalize_describes()` drop/keep behavior:** Test that non-string describes values produce the correct normalized list (either truly dropped or correctly coerced, but matching the warning text).

**Priority 3 — Defensive:**

7. **`parse_frontmatter_content()` with 24+ `---` separators:** The Manual has this. Verify the `maxsplit=2` correctly isolates frontmatter from body.

8. **`normalize_type()` with list input:** `type: [kernel, atom]` → should use first element. Test this path at frontmatter.py:231-232.

9. **Concepts validation false positive rate:** Run `validate_concepts()` against a snapshot of real library documents. Count how many new warnings it generates. If > 50, the noise-to-signal ratio may cause users to ignore warnings.

---

## Failure Mode Summary

| Change | Worst case if wrong | Tests catch it? | Track B surfaces it? |
|--------|-------------------|----------------|---------------------|
| Parser unification (#1) | Wrong parse results → corrupt graph | Partially (unit tests, no integration) | Yes — link-check reads all docs |
| Duplicate ID detection (#10) | Commands refuse to run | **No** (no test) | **Yes** — rename can't operate |
| Input normalization (#9, #25) | Silent wrong describes/types | Partially | Yes — rename writes these fields |
| Graph builder unification (#36) | query --health wrong output | **No** (no regression test) | No |
| validate_concepts (#42) | **Crash on unhashable** | **No** | Yes — link-check validate_all |
| Enum cleanup (#37) | Crash if raw string leaks | Partially (hasattr residuals suggest uncertainty) | No |
| Severity model (#44) | Wrong error/warning classification | Yes (test_validation_concepts_a1.py) | Yes — link-check exit codes |
| Layer boundary (#33) | Subtle behavior change in snapshot | Partially (test_snapshot.py) | No |

---

## Appendix: Verified Fixes (No Issues Found)

These audit items were attacked and found to be correctly implemented:

- **#1 (CC-03) Parser unification:** All 8 migrated commands use canonical `load_documents(files, parse_frontmatter_content)`. Legacy `parse_frontmatter()` is marked NON-CANONICAL and has zero runtime callers.

- **#25 (C-6) Enum coercion:** `normalize_type()` and `normalize_status()` both catch `(ValueError, TypeError)` at frontmatter.py:236,266. The `TypeError` gap from the audit is closed.

- **#37 (CC-06) Enum defensive checks:** All 21 `hasattr(doc.type, 'value')` patterns removed from production code. Zero remaining in `ontos/` (2 residual `hasattr(doc, ...)` in graph.py and suggestions.py are different pattern — see VUL-07).

- **#33 (CC-01) Layer boundary:** `ontos/core/snapshot.py` has zero imports from `ontos.io`. `create_snapshot()` correctly moved to `ontos/io/snapshot.py` with proper dependency injection.

- **#36 (CC-05) Duplicate build_graph:** Local `build_graph()` in query.py is deleted. `query_health()` uses `core_build_graph()` at query.py:81. `DependencyGraph` attributes accessed correctly.

- **#44 (CC-19) Severity model:** `REFERENCE_SEVERITY_DEFAULT` at validation.py:34-43 explicitly documents the asymmetry. Override mechanism at validation.py:91-94 works. Test at test_validation_concepts_a1.py:88-109 verifies overrides.

- **#9 (C-7) Reference normalization:** `normalize_reference_list()` at frontmatter.py:155-194 handles None, str, int, float, bool, list, dict, nested types. All edge cases produce deterministic output with callback warnings.

- **#8 (C-5) Describes list-safe:** `validate_describes_field()` at validation.py:46-72 now returns `List[ValidationError]` and iterates `doc.describes` (normalized list). No TypeError on list input.

---

# Round 2 — Post-Remediation Re-Review

**Date:** 2026-02-11
**Commits reviewed:** `8e4c8db` through `21c3de0` (6 remediation commits)

---

## Verdict: Approve with Hardening

All three critical unblock requirements from Round 1 are correctly fixed and tested. No new critical or potential vulnerabilities introduced by the remediation. Five low-severity items from Round 1 remain unfixed — acceptable as tech debt if documented in the backlog.

**Unblock requirements — all satisfied:**

| Requirement | Status | Evidence |
|---|---|---|
| VUL-01: Fix unhashable concepts crash | **FIXED** | `validation.py:280-281` — hashable filter before `set()` |
| VUL-02: Fix normalize_describes drop/keep | **FIXED** | `staleness.py:153-155` — truly drops, no `append()` |
| VUL-03: Fix has_fatal_errors blocking on duplicates | **FIXED** | `files.py:46` — `duplicate_id` removed from `fatal_codes` |

---

## Critical Fixes Verified

### VUL-01 — FIXED: validate_concepts() No Longer Crashes on Unhashable Concepts

**Fix location:** `ontos/core/validation.py:279-282`

```python
# Guard against unhashable members (dicts, lists) during set conversion (VUL-01)
hashable_concepts = [c for c in concepts if isinstance(c, (str, int, float, bool))]
if len(hashable_concepts) != len(set(hashable_concepts)):
    dupes = [c for c in set(hashable_concepts) if hashable_concepts.count(c) > 1]
```

**Verification:** Re-ran the attack scenario mentally:
1. `concepts: [{"key": "val"}, "normal-concept"]`
2. Line 267: non_strings check detects dict → warning emitted ✓
3. Line 280: `hashable_concepts = ["normal-concept"]` (dict filtered out)
4. Line 281: `set(["normal-concept"])` — no TypeError ✓
5. Duplicate check runs on clean list only ✓

**Test coverage:** `test_validate_concepts_unhashable_items_no_crash` (test_validation_concepts_a1.py:112-129) directly exercises the exact attack input `[{"key": "val"}, "valid"]`.

**Minor gap:** Unhashable duplicate detection is silently skipped. If `concepts: [{"a":"b"}, {"a":"b"}]`, the duplicate dicts won't be caught by the duplicate check (only by the non-string warning). Acceptable — the non-string warning already flags the issue.

---

### VUL-02 — FIXED: normalize_describes() Now Truly Drops Non-Strings

**Fix location:** `ontos/core/staleness.py:153-156`

```python
else:
    if on_warning:
        on_warning(f"Non-string member '{v}' in describes field dropped.")
    # NO results.append() — truly dropped
return results
```

**Verification:** The `results.append(str(v))` line is gone. Non-string items emit the "dropped" warning and are excluded from the returned list.

**Test coverage:** `test_load_document_with_mixed_describes` (test_document_loading_contract_a1.py:43-58) explicitly asserts:
```python
# VUL-02: Ensure non-string target '123' is dropped, not coerced to "123"
assert doc.describes == ["valid_atom"]
```

**New design asymmetry (non-blocking):** `normalize_reference_list()` (frontmatter.py:180-186) coerces `int/float/bool` to strings for `depends_on`/`impacts`, while `normalize_describes()` drops them. This means `depends_on: [123]` → `["123"]` (kept) but `describes: [123]` → `[]` (dropped). The test documents this as intentional. Recommend adding a comment in `normalize_describes()` explaining why it's stricter than `normalize_reference_list()`.

---

### VUL-03 — FIXED: has_fatal_errors No Longer Blocks on Duplicates

**Fix location:** `ontos/io/files.py:44-47`

```python
@property
def has_fatal_errors(self) -> bool:
    """True if any fatal issues (parse/IO errors) were found. Duplicates are handled by commands."""
    fatal_codes = {"parse_error", "io_error"}
    return any(issue.code in fatal_codes for issue in self.issues)
```

**Per-command duplicate handling verified:**

| Command | Duplicate behavior | Code location | Correct? |
|---|---|---|---|
| map | Fail (exit 1) | `map.py:747` — `has_fatal_errors or load_result.duplicate_ids` | ✓ |
| query | Warn + continue | `query.py:171-175` — warns, then uses `load_result.documents` | ✓ |
| maintain | Fail task | `maintain.py:568,588` — reports duplicates, fails if `duplicate_count > 0` | ✓ |
| consolidate | Fail (exit 1) | `consolidate.py:44,164` — `has_fatal_errors or load_result.duplicate_ids` | ✓ |
| scaffold | Fail | `scaffold.py:64` — `has_fatal_errors` only (no duplicate check) | ⚠️ See below |
| verify | Fail | `verify.py:38,153` — checks fatal errors | Needs verification |
| promote | Fail | `promote.py:169` — checks fatal errors | Needs verification |
| migrate | Fail | `migrate.py:72` — checks fatal errors | Needs verification |

**Test coverage:** Comprehensive. Six new parity tests verify per-command duplicate behavior:
- `test_consolidate_fails_on_duplicates` (test_consolidate_parity.py)
- `test_map_fails_on_duplicate_ids` (test_map.py)
- `test_schema_migrate_fails_on_duplicates` (test_migrate_parity.py)
- `test_promote_fails_on_duplicates` (test_promote_parity.py)
- `test_query_warns_on_duplicate_ids` (test_query_parity.py)
- `test_verify_all_fails_on_duplicates` (test_verify_parity.py)

Plus three loader-level contract tests:
- `test_loader_duplicate_contract_deterministic_first_wins`
- `test_loader_duplicate_contract_collision_reporting`
- `test_loader_duplicate_contract_no_crash_resilience`

---

## Previously Reported Items — Status Update

### VUL-04 — UNCHANGED: .lstrip() Still Present

`files.py:215` still has `.lstrip()`. This is now documented as intentional behavior (lenient frontmatter detection). The comment on line 211 reads "Lenient read (BOM stripping and leading lstrip for frontmatter detection)."

**Severity downgrade:** Theoretical → the lstrip is an intentional design choice for robustness against BOM/whitespace. No production incident likely.

### VUL-05 — FIXED: maintain.py Now Handles Load Issues

`maintain.py:549-599` — `_task_check_links()` now:
- Checks `load_result.issues` count (line 553-555)
- Reports duplicates explicitly (line 568, 572-574)
- Fails on `error_count > 0 or duplicate_count > 0` (line 588)

**Status:** Fully resolved. No longer an asymmetric gap.

### VUL-06 — UNCHANGED: Vocabulary Check Still a No-Op

`map.py:68-85` still collects all concepts from all docs and passes them as `known_concepts`. Self-referential vocabulary check. Structural checks (empty, non-string, duplicate) work. Vocabulary check does not fire for any concept that appears in any document.

**Severity:** Low. Structural validation delivers value. Vocabulary check is a nice-to-have.

### VUL-07 — UNCHANGED: 2 Residual hasattr Checks

Still present at `graph.py:76` and `suggestions.py:213`. Non-harmful dead code.

### VUL-08 — UNCHANGED: 4 Unused parse_frontmatter Imports

Still present in promote.py, maintain.py, scaffold.py, verify.py. Dead imports.

### VUL-09 — UNCHANGED: parse_frontmatter_yaml() Still Exists

Still at `yaml.py:45-57`. Thin wrapper, marked NON-CANONICAL.

### VUL-10 — UNCHANGED: Bare except in io/snapshot.py

Still at `snapshot.py:91`. Should be `except Exception:`.

### VUL-11 — UNCHANGED: Case-Sensitive Duplicate Detection

Undocumented but correct behavior.

### VUL-12 — UNCHANGED: Snapshot Runs validate_all() Without Concepts Config

Still at `snapshot.py:83`. VUL-01 fix prevents the crash, so this is no longer a crash vector. Just means no vocabulary checking in snapshot context.

---

## New Observations From Remediation

### OBS-01 — consolidate.py Double-Loads Documents

`consolidate_command()` loads docs at line 163, checks for errors. Then calls `find_logs_to_consolidate()` which loads the same docs again at line 43. Both checks pass or fail identically. Performance waste, not a bug.

### OBS-02 — normalize_describes vs normalize_reference_list Asymmetry

`normalize_reference_list()` (frontmatter.py:180-186): Coerces `int/float/bool` to strings.
`normalize_describes()` (staleness.py:149-155): Drops non-strings entirely.

This is documented as intentional by the test assertion (`doc.describes == ["valid_atom"]`), but should have a code comment explaining the design rationale: describes targets must be exact document IDs (strings), while depends_on allows numeric coercion for YAML convenience.

### OBS-03 — scaffold.py May Not Check Duplicates

`scaffold.py:64` checks `has_fatal_errors` only. Since `duplicate_id` is no longer in `fatal_codes`, scaffold silently continues with first-wins on duplicates. This may be intentional (scaffold creates new files, doesn't care about existing duplicates) but is inconsistent with consolidate/map which both fail. Should be documented.

---

## Test Coverage Assessment

**Round 1 gaps now covered:**

| Gap | Status | Test |
|---|---|---|
| Unhashable concepts (VUL-01) | **Covered** | `test_validate_concepts_unhashable_items_no_crash` |
| Duplicate ID handling (VUL-03) | **Covered** | 9 tests across 7 files |
| normalize_describes drop (VUL-02) | **Covered** | `test_load_document_with_mixed_describes` asserts `["valid_atom"]` |
| Load pipeline end-to-end | **Covered** | Duplicate contract tests load multiple files |

**Still uncovered:**

| Gap | Risk | Recommendation |
|---|---|---|
| `.lstrip()` frontmatter boundary | Low | Document as intentional |
| `query_health` output parity | Low | Manual verification sufficient |
| Concepts false positive rate on real library | Medium | Run `ontos map` on real library, count new warnings |
| `parse_frontmatter_content()` with 24+ `---` | Low | `maxsplit=2` handles this correctly by construction |

---

## Final Disposition

| Category | Count | Items |
|---|---|---|
| Fixed + Tested | 4 | VUL-01, VUL-02, VUL-03, VUL-05 |
| Accepted (documented/low-risk) | 4 | VUL-04, VUL-06, VUL-11, VUL-12 |
| Backlog (non-blocking cleanup) | 4 | VUL-07, VUL-08, VUL-09, VUL-10 |
| New observations | 3 | OBS-01, OBS-02, OBS-03 |

**Recommendation:** Merge PR #67. The three critical blockers are resolved. Remaining items should be added to the v3.3 backlog as P3 cleanup tasks.

---

# Round 3 — Post-Hardening Verification

**Date:** 2026-02-11
**Scope:** Verification of 11 hardening items from `v3.3_Track_A1_Hardening_Prompt.md`

## Verdict: All 11 items correctly implemented. One new observation.

All items pass verification. No rework needed.

| # | Item | Status |
|---|------|--------|
| 1 | VUL-08: Remove 4 dead imports | PASS |
| 2 | VUL-09: Delete `parse_frontmatter_yaml()` | PASS |
| 3 | VUL-10: Fix bare `except:` | PASS |
| 4 | VUL-07: Remove 2 `hasattr` guards | PASS |
| 5 | VUL-04: Document `.lstrip()` + test | PASS |
| 6 | VUL-06: Load vocab from `Common_Concepts.md` | PASS |
| 7 | VUL-11: Document case-sensitive duplicates + test | PASS |
| 8 | VUL-12: Document empty config in snapshot | PASS |
| 9 | OBS-01: Eliminate double load in consolidate | PASS |
| 10 | OBS-02: Add asymmetry comment in staleness.py | PASS |
| 11 | OBS-03: Document scaffold duplicate tolerance + test | PASS |

### OBS-04 — `history.py` is the Last Active Caller of Legacy `parse_frontmatter()`

`ontos/core/history.py` imports and calls `parse_frontmatter()` from `core/frontmatter.py` at lines 46 and 87. It also uses `normalize_depends_on()` at lines 102-103. These are **active runtime callers**, not dead imports — they were correctly out of scope for VUL-08 (which targeted dead imports in command files).

**Consequence:** The legacy `parse_frontmatter()` function and its re-exports in `ontos/__init__.py:14` and `ontos/core/__init__.py:19` cannot be deleted until `history.py` is migrated to the canonical `parse_frontmatter_content()` from `ontos.io.yaml`.

**Priority:** P4 — not blocking anything, but it's the last piece preventing full legacy parser removal. Recommend adding as a v3.3 backlog task.
