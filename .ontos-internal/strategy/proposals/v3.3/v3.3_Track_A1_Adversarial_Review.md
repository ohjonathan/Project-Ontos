---
id: v3_3_track_a1_adversarial_review
type: review
status: active
depends_on: [v3_3_track_a1_implementation_spec, v3_3_merged_audit_findings]
concepts: [v3.3, track-a1, adversarial-review, code-review]
---

# v3.3 Track A1 Adversarial Review — Phase D

**PR:** #67 (`feature/v3.3-track-a1-unified-loader`)
**Reviewer:** Claude Code (Adversarial Track)
**Date:** 2026-02-11

---

## Verdict: Request Changes

Three critical vulnerabilities found in production code paths. One causes a crash on real library content. One silently corrupts data. One breaks backward compatibility for every user with duplicate IDs. All three are exploitable during normal `ontos map` or `ontos query` usage — no exotic inputs required.

**Unblock requirements (must fix before merge):**

1. Fix `validate_concepts()` TypeError crash on unhashable concept values (VUL-01)
2. Fix `normalize_describes()` "dropped but kept" inconsistency (VUL-02)
3. Make `has_fatal_errors` not include `duplicate_id` unconditionally, or provide commands a way to continue with duplicates (VUL-03)

---

## Vulnerabilities Found

### Critical (Exploitable in Normal Use)

#### VUL-01 — validate_concepts() Crashes on Unhashable Concept Values

| Field | Detail |
|-------|--------|
| **Files** | `ontos/core/validation.py:279` |
| **Severity** | Critical — crash, zero output |
| **Track B impact** | Yes — link-check and rename both call `validate_all()` |

**Attack scenario:**

Any document with a dict or nested list in its `concepts` field:

```yaml
---
id: some_doc
concepts: [{key: val}, "normal-concept"]
---
```

PyYAML `safe_load` produces `[{"key": "val"}, "normal-concept"]` — a list containing a dict.

**Execution trace:**

1. `validate_concepts()` at validation.py:242: `concepts = doc.frontmatter.get("concepts")` → `[{"key": "val"}, "normal-concept"]`
2. Line 255: `if concepts:` → True
3. Line 256: `if not isinstance(concepts, list):` → False (it IS a list)
4. Line 267: `non_strings = [str(c) for c in concepts if not isinstance(c, str)]` → `["{'key': 'val'}"]` — detects the dict and reports a warning at line 269
5. **Line 279:** `if len(concepts) != len(set(concepts)):` → **`TypeError: unhashable type: 'dict'`**

The non-string check at line 267 correctly identifies the dict, but execution falls through to the duplicate check at line 279 where `set()` crashes on unhashable types.

**Blast radius:** Every code path that calls `validate_all()`:
- `ontos map` (map.py:82)
- `io/snapshot.py:84` (affects export_data, migration_report)
- Any future command using the orchestrator

**Expected behavior:** Warning about non-hashable concepts, then skip duplicate check.

**Actual behavior:** Unhandled `TypeError`, full crash, no output.

**Why tests missed it:** Test at `test_validation_concepts_a1.py:23` uses `concepts: ["c1", 123]` — an int (hashable). No test uses a dict (unhashable). The test exercises the non-string warning path but not the subsequent set() crash.

**Fix:** Guard the duplicate check:

```python
try:
    if len(concepts) != len(set(concepts)):
        ...
except TypeError:
    pass  # Already warned about non-hashable items above
```

---

#### VUL-02 — normalize_describes() Says "Dropped" But Keeps Values

| Field | Detail |
|-------|--------|
| **Files** | `ontos/core/staleness.py:154-156` vs `ontos/core/frontmatter.py:187-189` |
| **Severity** | Critical — silent data corruption + misleading diagnostics |
| **Track B impact** | Yes — rename must understand what describes targets exist |

**Attack scenario:**

```yaml
---
id: my_doc
describes:
  - valid_atom
  - 123
  - [nested, list]
---
```

**Execution trace for `normalize_describes()` (staleness.py:129-161):**

1. Item `123` (int): Line 153 — `isinstance(v, str)` → False
2. Line 154-155: Warning emitted: `"Non-string member '123' in describes field dropped."`
3. **Line 156:** `results.append(str(v))` — **VALUE IS KEPT as "123"**

The warning says **"dropped"** but the code **keeps** the value by converting it to string.

Compare with `normalize_reference_list()` (frontmatter.py:175-190) for `depends_on`/`impacts`:

```python
# frontmatter.py:187-189
else:
    if on_warning:
        on_warning(f"Invalid nested type ... dropped.")
    # NO append — item truly dropped
```

For `depends_on`, non-scalar items are genuinely dropped. For `describes`, they claim to be "dropped" but are kept. The two normalizers have divergent contracts despite serving the same purpose.

**Impact:**
- Users see "dropped" warnings but the corrupted values persist in `doc.describes`
- `validate_describes()` at validation.py:228-235 checks these corrupted string-ified values against `valid_ids`
- `"123"` becomes a describes target that doesn't match any real document ID → generates a broken-reference warning
- The user gets TWO warnings for the same problem: "dropped" (false) and "not found" (true but confusing)
- Track B `rename` would need to handle these ghost describes targets

**Fix:** Either truly drop (remove `results.append(str(v))`) or fix the warning message to say "coerced to string" instead of "dropped."

---

#### VUL-03 — has_fatal_errors Unconditionally Blocks All Commands on Duplicate IDs

| Field | Detail |
|-------|--------|
| **Files** | `ontos/io/files.py:44-47`, 11 callsites across 8 commands |
| **Severity** | Critical — breaks backward compatibility |
| **Track B impact** | Yes — link-check/rename must handle existing libraries with duplicates |

**Attack scenario:** Any library with two files sharing the same `id` field in their frontmatter. This is common — the Content Report found duplicate IDs in the real library.

**The change:**

```python
# files.py:44-47
@property
def has_fatal_errors(self) -> bool:
    fatal_codes = {"duplicate_id", "parse_error", "io_error"}
    return any(issue.code in fatal_codes for issue in self.issues)
```

Every command gates execution on this:
- `query.py:165`: `if load_result.has_fatal_errors: return 1, "Document load failed"`
- `map.py:743`, `scaffold.py:64,152`, `consolidate.py:44,164`, `promote.py:169`, `verify.py:38,153`, `migrate.py:72`

**Old behavior:** `dict[doc.id] = doc` — silent overwrite, command continues.
**New behavior:** Exit code 1, no output, "Document load failed."

This is a hard behavioral regression. Users who previously ran `ontos query --health` successfully will now get a failure message with zero health output if ANY file in the scan scope has a duplicate ID. The query command scans the entire project root (`scan_docs_for_query` at query.py:38 passes `[root]`), so even a stray file with a conflicting ID blocks everything.

**Per-command severity analysis:**

The implementation spec (section 4.2) says "commands choose severity." But `has_fatal_errors` makes the choice for them — `duplicate_id` is always fatal. No command overrides this. The claimed policy of "query: warn and continue with canonical" is not implemented — query fails hard.

| Command | Spec intent | Actual behavior |
|---------|------------|-----------------|
| map | error | error (correct) |
| query | warn + continue | **error (wrong)** |
| maintain | task failed | no check (see VUL-05) |
| snapshot | warn + continue | **no check** |
| verify | unclear | error |
| scaffold | unclear | error |

**Fix:** Either (a) remove `duplicate_id` from `has_fatal_errors` and let each command check `load_result.duplicate_ids` explicitly, or (b) add a `has_blocking_errors` property that excludes duplicates for commands that should continue.

---

### Potential (Requires Specific Conditions)

#### VUL-04 — .lstrip() Changes Frontmatter Detection Boundary

| Field | Detail |
|-------|--------|
| **Files** | `ontos/io/files.py:215` |
| **Severity** | Potential — behavioral divergence from legacy parser |

**The change:**

```python
# files.py:215
content = raw_bytes.decode('utf-8', errors='replace').lstrip()
```

The legacy parser (`core/frontmatter.py:47-52`) reads content without stripping:

```python
with open(filepath, 'r', encoding='utf-8', errors='replace') as f:
    content = f.read()
if not content.startswith('---'):
    return None
```

After `.lstrip()`, a file starting with `\n---\nid: test\n---\n` is now detected as having frontmatter. The old parser would return None (no frontmatter) because `content.startswith('---')` would be False.

**Impact:** Documents that were previously "plain markdown" (ignored by the graph, never validated) could become frontmatter documents. Their content would be parsed as YAML, potentially generating false errors. This is an invisible behavioral change — no warning or diagnostic indicates the frontier shifted.

**Likelihood:** Low-to-medium. Files in the library are generally well-formed, but imported/external files could have leading whitespace.

---

#### VUL-05 — maintain.py Doesn't Check has_fatal_errors

| Field | Detail |
|-------|--------|
| **Files** | `ontos/commands/maintain.py:245-249` |
| **Severity** | Potential — silent degradation |

`_load_docs_for_graph()` returns `load_documents()` result directly. No `has_fatal_errors` check anywhere in the maintain command's graph-dependent tasks. This means:

- Duplicate IDs are silently resolved to first-wins
- Parse errors are silently skipped
- The maintain command operates on a potentially incomplete document set without warning

Contrast with every other command which fails hard. This asymmetry is undocumented and likely unintentional.

---

#### VUL-06 — Vocabulary Check is Effectively a No-Op in map.py

| Field | Detail |
|-------|--------|
| **Files** | `ontos/commands/map.py:64-70,80` |
| **Severity** | Potential — feature doesn't deliver value |

```python
# map.py:64-70 — collect ALL concepts from ALL docs
all_concepts = set()
for doc in docs.values():
    concepts = doc.frontmatter.get("concepts")
    if isinstance(concepts, list):
        for c in concepts:
            if isinstance(c, str):
                all_concepts.add(c)

# map.py:80 — pass as known vocabulary
"known_concepts": all_concepts
```

`validate_concepts()` at validation.py:291-301 checks each document's concepts against `known_concepts`. But `known_concepts` is the union of ALL concepts from ALL documents. Every concept that exists is, by definition, "known." The vocabulary check can only fire if a concept appears for the first time in a single document and nowhere else — which is indistinguishable from a correctly-used new concept.

This renders the CC-16 fix (concepts validation) weaker than the spec implies. The structural checks (duplicates, empty lists, non-strings) work. The vocabulary check does not.

**Fix:** Load vocabulary from an authoritative source (Common_Concepts.md) rather than from the documents being validated.

---

#### VUL-07 — Residual Defensive Checks Contradict CC-06 Cleanup Premise

| Field | Detail |
|-------|--------|
| **Files** | `ontos/core/graph.py:76`, `ontos/core/suggestions.py:213` |
| **Severity** | Potential — inconsistency |

Two `hasattr(doc, ...)` checks survive:

```python
# graph.py:76
depends_on = doc.depends_on if hasattr(doc, 'depends_on') else []

# suggestions.py:213
aliases = doc.aliases if hasattr(doc, 'aliases') else []
```

These are different from the CC-06 `hasattr(doc.type, 'value')` enum checks, but they follow the same defensive pattern. If the unified loader guarantees `DocumentData` with all fields populated, these checks are dead code. If it doesn't, the CC-06 cleanup was premature.

Either remove them (consistent with CC-06 cleanup) or explain why `depends_on`/`aliases` need defense when `type`/`status` don't.

---

#### VUL-08 — Unused Imports of parse_frontmatter in 4 Commands

| Field | Detail |
|-------|--------|
| **Files** | `promote.py:7`, `maintain.py:20`, `scaffold.py:7`, `verify.py:9` |
| **Severity** | Potential — confuses migration audit |

Four command files import `parse_frontmatter` from `ontos.core.frontmatter` but never call it. Migration is functionally complete (all runtime paths use canonical loader), but the leftover imports create confusion about whether migration is truly done.

A `grep` for `parse_frontmatter` finds these imports and makes it look like legacy paths are still active. Future reviewers (or Track B implementers) may waste time verifying these are dead imports.

**Fix:** Remove unused imports.

---

### Theoretical (Defensive)

#### VUL-09 — parse_frontmatter_yaml() Not Deleted (CC-13)

`ontos/io/yaml.py:45-57` retains `parse_frontmatter_yaml()` as a thin wrapper around `parse_frontmatter_content()`, marked "NON-CANONICAL." The CC-13 audit finding recommended deletion. Keeping it as a wrapper is technically safe but adds API surface confusion — the module now exports `parse_yaml`, `parse_frontmatter_yaml`, and `parse_frontmatter_content`, three of which have overlapping purposes.

#### VUL-10 — Bare except in io/snapshot.py:91

```python
try:
    git_commit = git_commit_provider()
except:
    pass
```

Bare `except:` catches `KeyboardInterrupt`, `SystemExit`, and `GeneratorExit`. Should be `except Exception:`.

#### VUL-11 — Duplicate ID Detection is Case-Sensitive (Undocumented)

`load_documents()` compares `doc.id` directly (`if doc.id in documents`). IDs `v3_2_4_proposal` and `V3_2_4_Proposal` are treated as different. This is likely correct (IDs come from YAML which is case-sensitive), but should be documented since Track B rename will need to decide its case-matching semantics.

#### VUL-12 — io/snapshot.py Runs validate_all() Without Concepts Config

`io/snapshot.py:83` creates `ValidationOrchestrator(filtered_docs, {})` with empty config. This means:
- `known_concepts` defaults to empty set → vocabulary check silently skipped (OK)
- `severity_map` defaults to `REFERENCE_SEVERITY_DEFAULT` → all defaults apply
- But if any document has unhashable concepts → VUL-01 crash applies here too

---

## Regression Risk Assessment

| Behavior | Before PR #67 | After PR #67 | Intentional? |
|----------|--------------|-------------|--------------|
| Duplicate IDs in query scope | Silent overwrite, command works | Exit code 1, no output | **Unclear — spec says "warn+continue" but code says "fail"** |
| Duplicate IDs in maintain scope | Silent overwrite | Silent first-wins (no `has_fatal_errors` check) | **Accidental asymmetry** |
| Leading whitespace before `---` | No frontmatter detected | Frontmatter detected | **Accidental** |
| Concepts validation on `ontos map` | Not run | Run (structural checks + no-op vocab check) | **Intentional** — new warnings will appear |
| Enum defensive checks | Graceful degradation to string | Direct `.value` access | **Intentional** — correct if loader guarantees enums |
| `query --health` graph builder | Local simple dict-based | Core `DependencyGraph` object | **Intentional** — verify output parity |

---

## Test Gap Analysis

**Priority 1 — Must add before merge:**

1. **Unhashable concepts crash (VUL-01):** Test `validate_concepts()` with `concepts: [{"key": "val"}]`. Currently zero tests for unhashable types. This will crash in production.

2. **`load_documents()` with duplicate IDs:** No test verifies that `load_documents()` handles duplicates correctly (first-wins, issues recorded, `duplicate_ids` dict populated). This is a Track B prerequisite.

3. **`load_documents()` end-to-end with real content:** No integration test loads multiple files and checks the full pipeline (scan → load → normalize → deduplicate → result). Unit tests exist for individual functions but the orchestration is untested.

**Priority 2 — Should add:**

4. **`.lstrip()` frontmatter boundary change:** Test that a file with `\n---\nid: test\n---\n` is handled as expected (document or ignored). Codify the intended behavior.

5. **`query_health` output parity:** Before/after test comparing `query --health` output structure to ensure the graph builder switch didn't change results.

6. **`normalize_describes()` drop/keep behavior:** Test that non-string describes values produce the correct normalized list (either truly dropped or correctly coerced, but matching the warning text).

**Priority 3 — Defensive:**

7. **`parse_frontmatter_content()` with 24+ `---` separators:** The Manual has this. Verify the `maxsplit=2` correctly isolates frontmatter from body.

8. **`normalize_type()` with list input:** `type: [kernel, atom]` → should use first element. Test this path at frontmatter.py:231-232.

9. **Concepts validation false positive rate:** Run `validate_concepts()` against a snapshot of real library documents. Count how many new warnings it generates. If > 50, the noise-to-signal ratio may cause users to ignore warnings.

---

## Failure Mode Summary

| Change | Worst case if wrong | Tests catch it? | Track B surfaces it? |
|--------|-------------------|----------------|---------------------|
| Parser unification (#1) | Wrong parse results → corrupt graph | Partially (unit tests, no integration) | Yes — link-check reads all docs |
| Duplicate ID detection (#10) | Commands refuse to run | **No** (no test) | **Yes** — rename can't operate |
| Input normalization (#9, #25) | Silent wrong describes/types | Partially | Yes — rename writes these fields |
| Graph builder unification (#36) | query --health wrong output | **No** (no regression test) | No |
| validate_concepts (#42) | **Crash on unhashable** | **No** | Yes — link-check validate_all |
| Enum cleanup (#37) | Crash if raw string leaks | Partially (hasattr residuals suggest uncertainty) | No |
| Severity model (#44) | Wrong error/warning classification | Yes (test_validation_concepts_a1.py) | Yes — link-check exit codes |
| Layer boundary (#33) | Subtle behavior change in snapshot | Partially (test_snapshot.py) | No |

---

## Appendix: Verified Fixes (No Issues Found)

These audit items were attacked and found to be correctly implemented:

- **#1 (CC-03) Parser unification:** All 8 migrated commands use canonical `load_documents(files, parse_frontmatter_content)`. Legacy `parse_frontmatter()` is marked NON-CANONICAL and has zero runtime callers.

- **#25 (C-6) Enum coercion:** `normalize_type()` and `normalize_status()` both catch `(ValueError, TypeError)` at frontmatter.py:236,266. The `TypeError` gap from the audit is closed.

- **#37 (CC-06) Enum defensive checks:** All 21 `hasattr(doc.type, 'value')` patterns removed from production code. Zero remaining in `ontos/` (2 residual `hasattr(doc, ...)` in graph.py and suggestions.py are different pattern — see VUL-07).

- **#33 (CC-01) Layer boundary:** `ontos/core/snapshot.py` has zero imports from `ontos.io`. `create_snapshot()` correctly moved to `ontos/io/snapshot.py` with proper dependency injection.

- **#36 (CC-05) Duplicate build_graph:** Local `build_graph()` in query.py is deleted. `query_health()` uses `core_build_graph()` at query.py:81. `DependencyGraph` attributes accessed correctly.

- **#44 (CC-19) Severity model:** `REFERENCE_SEVERITY_DEFAULT` at validation.py:34-43 explicitly documents the asymmetry. Override mechanism at validation.py:91-94 works. Test at test_validation_concepts_a1.py:88-109 verifies overrides.

- **#9 (C-7) Reference normalization:** `normalize_reference_list()` at frontmatter.py:155-194 handles None, str, int, float, bool, list, dict, nested types. All edge cases produce deterministic output with callback warnings.

- **#8 (C-5) Describes list-safe:** `validate_describes_field()` at validation.py:46-72 now returns `List[ValidationError]` and iterates `doc.describes` (normalized list). No TypeError on list input.
