---
id: v2_5_promises_implementation_plan
type: strategy
status: draft
depends_on: [v2_strategy, mission]
---

# Ontos v2.5 Implementation Plan: "The Promises"

**Version:** 2.5.0
**Theme:** The Promises
**Date:** 2025-12-17 (Updated)
**Status:** ‚úÖ APPROVED FOR IMPLEMENTATION
**Architect:** Claude Code (Opus 4.5)
**Reviewers:** Claude Opus 4.5, Codex, Gemini

---

## 1. Executive Summary

### Problem
Users won't remember to consolidate logs. The current system relies on passive warnings that get ignored, violating the "zero friction" promise of automated mode.

### Solution
Implement mode-based consolidation behavior:
- **Automated mode:** Auto-consolidate on commit (pre-commit hook)
- **Prompted mode:** Agent reminder at activation
- **Advisory mode:** Warning only (current behavior)

### Key Innovation
Use **pre-commit** hook instead of pre-push. This allows consolidation changes to be included in the commit, avoiding the "left behind" paradox.

---

## 2. The Promises (User-Facing)

These messages will be shown during `ontos_init.py` mode selection:

### Automated
> "Zero friction ‚Äî just works."
>
> Push your code ‚Äî sessions are archived, old logs are consolidated, nothing is left behind. You focus on building.

### Prompted
> "Keep me in the loop."
>
> You stay in control of what gets archived and when. Perfect for teams who want visibility.

### Advisory
> "Maximum flexibility."
>
> Ontos watches and advises but never blocks. You run consolidation and archiving on your own schedule.

---

## 3. Behavior Matrix

| Behavior | automated | prompted | advisory |
|----------|-----------|----------|----------|
| **Session Archiving** | Auto on push | Blocks push until archived | Warning only |
| **Consolidation** | Auto on commit (pre-commit) | Agent reminder at activation | Warning only |
| **Auto-stage changes** | Yes | No | No |
| **Source attribution** | Optional (uses DEFAULT_SOURCE) | Required | Optional |
| **Log enrichment** | Optional (auto-generated OK) | Encouraged | Optional |

### Hook Configuration

| Hook | automated | prompted | advisory |
|------|-----------|----------|----------|
| **pre-commit** | Consolidate if over threshold ‚Üí auto-stage | ‚Äî | ‚Äî |
| **pre-push** | Auto-archive session | Block until archived | Warn if unarchived |
| **activation** | ‚Äî | Remind if consolidation needed | ‚Äî |

---

## 4. Architecture Decision: Pre-commit vs Pre-push

### The "Dirty Push" Paradox (Why not pre-push)

If consolidation runs in pre-push:
1. User runs `git push`
2. Pre-push hook runs consolidation ‚Üí moves files
3. Hook exits 0 (success)
4. Push sends ORIGINAL state to remote
5. User now has DIRTY working tree with uncommitted changes
6. User must run `git add . && git commit && git push` AGAIN

This violates the "zero friction" promise.

### The Pre-commit Solution

```
Timeline:
1. User stages changes: git add .
2. User runs: git commit -m "feat: something"
3. [PRE-COMMIT HOOK FIRES]
4. Hook detects: logs > threshold
5. Consolidation runs ‚Üí moves files, updates decision_history.md
6. Hook runs: git add (consolidated files)
7. Commit proceeds with BOTH user changes AND consolidation
```

**Result:** Everything is in one commit. User never sees "dirty" state. True zero friction.

---

## 5. Deliverables

### 5.1 Update `ontos_init.py` - Promise Messaging

**File:** `ontos_init.py`
**Function:** `prompt_for_mode()` (lines 29-63)

Replace current mode selection with ASCII-only promise messaging (Unicode breaks in Windows CMD, SSH, CI logs):

```python
def prompt_for_mode() -> str:
    """Interactive mode selection with promises."""
    print("""
+================================================================+
|                    Choose Your Workflow                        |
+================================================================+

   [1] Automated (recommended for solo devs)

       "Zero friction - just works."

       - Sessions auto-archived on push
       - Old logs auto-consolidated on commit
       - Nothing left behind, you focus on building

   ----------------------------------------------------------------

   [2] Prompted (recommended for teams) [DEFAULT]

       "Keep me in the loop."

       - Push blocked until you archive
       - Consolidation warning shown at activation
       - Full control with gentle guidance

   ----------------------------------------------------------------

   [3] Advisory (for power users)

       "Maximum flexibility."

       - Warnings only, never blocks
       - You decide if/when to archive
       - Run consolidation on your schedule

+================================================================+
""")

    while True:
        choice = input("Enter choice [1-3, default=2]: ").strip()
        if choice == '' or choice == '2':
            return 'prompted'
        elif choice == '1':
            return 'automated'
        elif choice == '3':
            return 'advisory'
        else:
            print("Please enter 1, 2, or 3")
```

**Rationale:** ASCII-only ensures compatibility across all terminals (Windows CMD, SSH, CI logs). The promise is the first thing users see ‚Äî reliability over aesthetics.

---

### 5.2 Create Pre-commit Hook

**New File:** `.ontos/hooks/pre-commit`

```bash
#!/bin/bash
# Ontos pre-commit hook v2.5
# Auto-consolidates old logs in automated mode

SCRIPTS_DIR=".ontos/scripts"
HOOK_SCRIPT="$SCRIPTS_DIR/ontos_pre_commit_check.py"

# Bypass if Ontos not installed
if [ ! -f "$HOOK_SCRIPT" ]; then
    exit 0
fi

# Hand off to Python
python3 "$HOOK_SCRIPT"
exit $?
```

**Rationale:** Thin bash wrapper delegates to Python for testability and complex logic.

---

### 5.3 Create Pre-commit Check Script

**New File:** `.ontos/scripts/ontos_pre_commit_check.py`

```python
"""Pre-commit hook for Ontos auto-consolidation (v2.5).

Safety features (from architectural review):
- CI detection: Skips in automated environments
- Rebase detection: Skips during rebase/cherry-pick
- Explicit staging: Only stages Ontos files, never user files
- Try/except wrapper: Guarantees return 0
- Dual condition: Count AND old_logs must both be true
"""

import os
import sys
import subprocess
import datetime

sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

from ontos_lib import resolve_config
from ontos_config import PROJECT_ROOT, LOGS_DIR


def get_mode() -> str:
    """Get current Ontos mode."""
    return resolve_config('ONTOS_MODE', 'prompted')


def get_log_count() -> int:
    """Count active logs in logs directory."""
    if not os.path.exists(LOGS_DIR):
        return 0
    return len([f for f in os.listdir(LOGS_DIR)
                if f.endswith('.md') and f[0].isdigit()])


def get_logs_older_than(days: int) -> list:
    """Get list of log filenames older than N days."""
    if not os.path.exists(LOGS_DIR):
        return []

    cutoff = datetime.datetime.now() - datetime.timedelta(days=days)
    old_logs = []

    for filename in os.listdir(LOGS_DIR):
        if not filename.endswith('.md') or not filename[0].isdigit():
            continue
        try:
            log_date = datetime.datetime.strptime(filename[:10], '%Y-%m-%d')
            if log_date < cutoff:
                old_logs.append(filename)
        except ValueError:
            continue

    return old_logs


def is_ci_environment() -> bool:
    """Detect CI/CD environments where hook should be skipped."""
    ci_indicators = [
        'CI',                    # Generic (GitHub Actions, GitLab CI, etc.)
        'CONTINUOUS_INTEGRATION', # Travis CI
        'GITHUB_ACTIONS',        # GitHub Actions
        'GITLAB_CI',             # GitLab CI
        'JENKINS_URL',           # Jenkins
        'CIRCLECI',              # CircleCI
        'BUILDKITE',             # Buildkite
        'TF_BUILD',              # Azure Pipelines
    ]
    return any(os.environ.get(var) for var in ci_indicators)


def is_special_git_operation() -> bool:
    """Detect rebase, cherry-pick, etc. where hook should be skipped."""
    result = subprocess.run(
        ['git', 'rev-parse', '--git-dir'],
        capture_output=True, text=True
    )
    if result.returncode != 0:
        return False

    git_dir = result.stdout.strip()

    # Rebase in progress
    if (os.path.exists(os.path.join(git_dir, 'rebase-merge')) or
        os.path.exists(os.path.join(git_dir, 'rebase-apply'))):
        return True

    # Cherry-pick in progress
    if os.path.exists(os.path.join(git_dir, 'CHERRY_PICK_HEAD')):
        return True

    return False


def should_consolidate() -> bool:
    """Check if consolidation should run.

    Uses DUAL CONDITION (from architectural review):
    - Count must exceed threshold AND
    - There must be logs old enough to consolidate

    This prevents confusing "nothing to consolidate" messages.
    """
    mode = get_mode()

    # Only auto-consolidate in automated mode
    if mode != 'automated':
        return False

    # Skip in CI environments
    if is_ci_environment():
        return False

    # Skip during rebase/cherry-pick
    if is_special_git_operation():
        return False

    # Skip if explicitly disabled
    if os.environ.get('ONTOS_SKIP_HOOKS', '').lower() in ('1', 'true', 'yes'):
        return False

    # Check if feature is enabled (allows override)
    if not resolve_config('AUTO_CONSOLIDATE_ON_COMMIT', True):
        return False

    # DUAL CONDITION: Count high AND old logs exist
    log_count = get_log_count()
    threshold_count = resolve_config('LOG_RETENTION_COUNT', 15)

    if log_count <= threshold_count:
        return False  # Count is fine

    # Count is high - are there old logs to consolidate?
    threshold_days = resolve_config('CONSOLIDATION_THRESHOLD_DAYS', 30)
    old_logs = get_logs_older_than(threshold_days)

    return len(old_logs) > 0


def run_consolidation() -> tuple[bool, str]:
    """Run consolidation in quiet, auto mode.

    Returns:
        (success, output) tuple
    """
    script = os.path.join(PROJECT_ROOT, '.ontos', 'scripts', 'ontos_consolidate.py')
    threshold_days = resolve_config('CONSOLIDATION_THRESHOLD_DAYS', 30)

    result = subprocess.run(
        [sys.executable, script, '--all', '--quiet', '--days', str(threshold_days)],
        capture_output=True,
        text=True
    )
    return result.returncode == 0, result.stdout + result.stderr


def stage_consolidated_files() -> None:
    """Stage ONLY files modified by consolidation.

    CRITICAL: Do NOT use 'git add -u' which stages ALL tracked files.
    Only stage specific Ontos-managed paths.
    """
    from ontos_config import is_ontos_repo

    # Determine paths based on mode (contributor vs user)
    if is_ontos_repo():
        decision_history = os.path.join(PROJECT_ROOT, '.ontos-internal', 'strategy', 'decision_history.md')
        archive_dir = os.path.join(PROJECT_ROOT, '.ontos-internal', 'archive')
        logs_dir = os.path.join(PROJECT_ROOT, '.ontos-internal', 'logs')
    else:
        decision_history = os.path.join(PROJECT_ROOT, 'docs', 'decision_history.md')
        archive_dir = os.path.join(PROJECT_ROOT, 'docs', 'archive')
        logs_dir = os.path.join(PROJECT_ROOT, 'docs', 'logs')

    # Stage ONLY Ontos-managed files
    if os.path.exists(decision_history):
        subprocess.run(['git', 'add', decision_history], capture_output=True)

    if os.path.exists(archive_dir):
        subprocess.run(['git', 'add', archive_dir], capture_output=True)

    # Stage logs directory (captures moved/deleted logs)
    if os.path.exists(logs_dir):
        subprocess.run(['git', 'add', logs_dir], capture_output=True)


def main() -> int:
    """Main entry point for pre-commit hook.

    Returns:
        0 ALWAYS (never block commit) - wrapped in try/except
    """
    try:
        verbose = os.environ.get('ONTOS_VERBOSE', '').lower() in ('1', 'true')

        if verbose:
            print("   [Ontos pre-commit hook running...]")

        if not should_consolidate():
            if verbose:
                print("   [Ontos: No consolidation needed]")
            return 0

        log_count = get_log_count()
        threshold = resolve_config('LOG_RETENTION_COUNT', 15)

        print(f"üì¶ Auto-consolidating ({log_count} logs > {threshold} threshold)...")

        success, output = run_consolidation()

        if success:
            stage_consolidated_files()
            print("   ‚úì Consolidated and staged")
        else:
            # Check if it's a "no work" vs "real error"
            if "No logs older than" in output or "No logs found" in output:
                if verbose:
                    print("   [Ontos: No old logs to consolidate]")
            else:
                # Surface real errors (permission, disk, etc.)
                print(f"   ‚ö† Consolidation issue: {output[:200]}")

        return 0  # Never block commit

    except Exception as e:
        # Guarantee return 0 even on unexpected errors
        print(f"   ‚ö† Ontos pre-commit hook error: {e}")
        return 0


if __name__ == "__main__":
    sys.exit(main())
```

**Design Decisions (Updated from Review):**
1. **Never blocks:** Returns 0 always, wrapped in try/except for guarantee.
2. **CI-aware:** Skips in GitHub Actions, GitLab CI, Jenkins, etc.
3. **Rebase-safe:** Skips during rebase/cherry-pick to avoid history contamination.
4. **Explicit staging:** Only stages Ontos files, never `git add -u`.
5. **Dual condition:** Count AND old_logs prevents false alarms.
6. **Verbose mode:** `ONTOS_VERBOSE=1` for debugging.
7. **Granular errors:** Surfaces permission/disk errors, silences "no old logs".

---

### 5.4 Update Hook Installation in `ontos_init.py`

**File:** `ontos_init.py`
**Location:** After pre-push installation (~line 333)

Hook installation now detects existing hook frameworks and provides integration instructions instead of silently overwriting:

```python
def install_pre_commit_hook() -> None:
    """Install pre-commit hook with conflict detection.

    Detects:
    - Husky (.husky/ directory)
    - pre-commit framework (.pre-commit-config.yaml)
    - Existing non-Ontos hooks

    Provides integration instructions instead of breaking user workflows.
    """
    pre_commit_src = os.path.join(PROJECT_ROOT, '.ontos', 'hooks', 'pre-commit')
    pre_commit_dst = os.path.join(HOOKS_DIR, 'pre-commit')

    if not os.path.exists(pre_commit_src):
        print("   ‚ö† Warning: Pre-commit hook source not found")
        return

    # Detect Husky
    husky_dir = os.path.join(PROJECT_ROOT, '.husky')
    if os.path.exists(husky_dir):
        print("\n   ‚ö† Husky detected. Manual integration required:")
        print("   Add to .husky/pre-commit:")
        print("   python3 .ontos/scripts/ontos_pre_commit_check.py")
        return

    # Detect pre-commit framework
    pre_commit_config = os.path.join(PROJECT_ROOT, '.pre-commit-config.yaml')
    if os.path.exists(pre_commit_config):
        print("\n   ‚ö† pre-commit framework detected. Manual integration required:")
        print("   Add to .pre-commit-config.yaml:")
        print("""
   - repo: local
     hooks:
       - id: ontos-consolidate
         name: Ontos Auto-Consolidation
         entry: python3 .ontos/scripts/ontos_pre_commit_check.py
         language: system
         always_run: true
         pass_filenames: false
        """)
        return

    # Check for existing non-Ontos hook
    if os.path.exists(pre_commit_dst):
        with open(pre_commit_dst, 'r') as f:
            content = f.read()
            if 'ontos' not in content.lower():
                print("\n   ‚ö† Existing pre-commit hook detected")
                print("   Add this line to your existing hook:")
                print("   python3 .ontos/scripts/ontos_pre_commit_check.py")

                response = input("   Overwrite existing hook? [y/N]: ").strip().lower()
                if response != 'y':
                    # Create backup and skip
                    backup = pre_commit_dst + '.backup'
                    shutil.copy2(pre_commit_dst, backup)
                    print(f"   ‚Ñπ Existing hook backed up to {backup}")
                    return

    # Safe to install
    try:
        shutil.copy2(pre_commit_src, pre_commit_dst)
        st = os.stat(pre_commit_dst)
        os.chmod(pre_commit_dst, st.st_mode | 0o111)  # Make executable
        print("   ‚úì Installed pre-commit hook")
    except Exception as e:
        print(f"   ‚ö† Warning: Failed to install pre-commit hook: {e}")
```

**Design Decisions (Updated from Review):**
1. **Detect Husky:** Common in JavaScript projects, provide `.husky/pre-commit` instructions.
2. **Detect pre-commit framework:** Industry standard, provide YAML config snippet.
3. **Prompt before overwrite:** If existing hook found, ask user instead of silently replacing.
4. **Backup on skip:** If user declines overwrite, backup existing hook.

---

### 5.5 Update Agent Instructions

**File:** `docs/reference/Ontos_Agent_Instructions.md`
**Section:** "Ontos" (Activate)

```markdown
### "Ontos" (Activate)
1. Check for `Ontos_Context_Map.md`
2. If missing: `python3 .ontos/scripts/ontos_generate_context_map.py`
3. Read map, identify relevant IDs for user's request
4. **Check consolidation status (prompted/advisory modes only):**
   - Count logs in logs directory
   - If count > LOG_RETENTION_COUNT (default: 15):
     ```
     print("‚ö†Ô∏è {count} active logs (threshold: {limit}). Run 'Consolidate Ontos' to archive old sessions.")
     ```
   - Note: In automated mode, consolidation happens automatically on commit
5. Read ONLY those files
6. print("Loaded: [id1, id2]")
```

---

### 5.6 Update Mode Presets

**File:** `.ontos/scripts/ontos_config_defaults.py`
**Section:** MODE_PRESETS (~line 193)

```python
MODE_PRESETS = {
    'automated': {
        'AUTO_ARCHIVE_ON_PUSH': True,
        'ENFORCE_ARCHIVE_BEFORE_PUSH': False,
        'REQUIRE_SOURCE_IN_LOGS': False,
        'AUTO_CONSOLIDATE': True,
        'AUTO_CONSOLIDATE_ON_COMMIT': True,  # NEW v2.5
    },
    'prompted': {
        'AUTO_ARCHIVE_ON_PUSH': False,
        'ENFORCE_ARCHIVE_BEFORE_PUSH': True,
        'REQUIRE_SOURCE_IN_LOGS': True,
        'AUTO_CONSOLIDATE': True,
        'AUTO_CONSOLIDATE_ON_COMMIT': False,  # NEW v2.5
    },
    'advisory': {
        'AUTO_ARCHIVE_ON_PUSH': False,
        'ENFORCE_ARCHIVE_BEFORE_PUSH': False,
        'REQUIRE_SOURCE_IN_LOGS': False,
        'AUTO_CONSOLIDATE': False,
        'AUTO_CONSOLIDATE_ON_COMMIT': False,  # NEW v2.5
    },
}
```

**Also add documentation:**

```python
# Auto-consolidate on commit (v2.5+)
# - True: Pre-commit hook consolidates old logs automatically
# - False: Manual consolidation only (or agent reminder in prompted mode)
# Only applies to 'automated' mode by default
AUTO_CONSOLIDATE_ON_COMMIT = False
```

---

### 5.7 Update Documentation

**File:** `docs/reference/Ontos_Manual.md`
**Section:** Configuration Modes

```markdown
### Configuration Modes (v2.5)

Ontos offers three workflow modes to match your preferences:

| Mode | Promise | Archiving | Consolidation |
|------|---------|-----------|---------------|
| **automated** | "Zero friction ‚Äî just works" | Auto on push | Auto on commit |
| **prompted** | "Keep me in the loop" | Blocks push | Agent reminder |
| **advisory** | "Maximum flexibility" | Warning only | Manual only |

**Choosing Your Mode:** During installation, `ontos_init.py` shows each mode's promise. Change later with:
```bash
python3 ontos_init.py --reconfig
```
```

**File:** `Ontos_CHANGELOG.md`

```markdown
## [2.5.0] - 2025-12-XX

### Theme: "The Promises"

Clear, honest communication about what each mode delivers.

### Added
- **Mode Promises**: Redesigned setup flow showing clear promises for each mode
- **Pre-commit hook**: Auto-consolidation for automated mode
- **`AUTO_CONSOLIDATE_ON_COMMIT`**: New config setting for pre-commit consolidation
- **Agent consolidation reminders**: Prompted mode reminds at activation when logs exceed threshold

### Changed
- `ontos_init.py`: Visually distinct mode selection with promise messaging
- `MODE_PRESETS`: Added consolidation-on-commit settings per mode
- `Ontos_Agent_Instructions.md`: Added consolidation check to activation flow

### Technical
- Pre-commit hook stages consolidated files automatically
- Consolidation never blocks commit (graceful degradation)
- CI environments detected and skipped automatically
- Hook conflicts detected with integration instructions provided
```

---

### 5.8 Add Context Map Consolidation Warning (NEW)

**File:** `.ontos/scripts/ontos_generate_context_map.py`
**Location:** End of `generate_context_map()` or as post-processing

This implements the "prompted" mode promise: "Keep me in the loop." The context map generation (which agents always run at activation) now prints a consolidation warning when needed.

```python
def check_consolidation_status():
    """Print warning if consolidation needed (prompted/advisory modes only).

    Called at end of context map generation to honor the "prompted" promise.
    Agents always activate (read context map) before work, so this warning
    is reliable without requiring a separate script.
    """
    mode = resolve_config('ONTOS_MODE', 'prompted')
    if mode == 'automated':
        return  # Auto-consolidation handles this in pre-commit hook

    log_count = get_log_count()
    threshold_count = resolve_config('LOG_RETENTION_COUNT', 15)

    if log_count <= threshold_count:
        return  # Count is fine

    # Count is high - check if there are old logs
    threshold_days = resolve_config('CONSOLIDATION_THRESHOLD_DAYS', 30)
    old_logs = get_logs_older_than(threshold_days)

    if len(old_logs) > 0:
        print(f"\n‚ö†Ô∏è  {log_count} active logs (threshold: {threshold_count})")
        print(f"   {len(old_logs)} logs are older than {threshold_days} days")
        print(f"   Run: python3 .ontos/scripts/ontos_consolidate.py")


# Add to end of main() or generate_context_map():
if __name__ == "__main__":
    generate_context_map()
    check_consolidation_status()  # Always check at end
```

**Rationale:** This honors the "Keep me in the loop" promise for prompted mode users without requiring agents to follow prose instructions. Since agents always read the context map at activation, this warning reliably appears.

---

## 6. File Changes Summary

| File | Action | Description |
|------|--------|-------------|
| `ontos_init.py` | MODIFY | ASCII mode selection UI, hook conflict detection |
| `.ontos/hooks/pre-commit` | CREATE | Bash wrapper for pre-commit check |
| `.ontos/scripts/ontos_pre_commit_check.py` | CREATE | Main pre-commit logic with safety features |
| `.ontos/scripts/ontos_generate_context_map.py` | MODIFY | Add consolidation warning for prompted mode |
| `.ontos/scripts/ontos_config_defaults.py` | MODIFY | Add `AUTO_CONSOLIDATE_ON_COMMIT` to mode presets |
| `docs/reference/Ontos_Agent_Instructions.md` | MODIFY | Update activation flow |
| `docs/reference/Ontos_Manual.md` | MODIFY | Document v2.5 mode behaviors |
| `Ontos_CHANGELOG.md` | MODIFY | v2.5 release notes |

*Line estimates removed per architectural review ‚Äî they're always wrong by implementation time.*

---

## 7. Testing Plan

### 7.1 Unit Tests

**New File:** `tests/test_pre_commit_check.py`

```python
"""Tests for pre-commit consolidation hook (v2.5)."""

import pytest
import os
import tempfile
from unittest.mock import patch

class TestPreCommitCheck:

    # --- Mode Tests ---

    def test_automated_mode_triggers_consolidation(self, mock_config, mock_old_logs):
        """In automated mode with old logs over threshold, should consolidate."""
        mock_config['ONTOS_MODE'] = 'automated'
        mock_config['LOG_RETENTION_COUNT'] = 5
        # Create 10 mock logs, 5 older than 30 days
        assert should_consolidate() == True

    def test_prompted_mode_skips_consolidation(self, mock_config):
        """In prompted mode, should never auto-consolidate."""
        mock_config['ONTOS_MODE'] = 'prompted'
        assert should_consolidate() == False

    def test_advisory_mode_skips_consolidation(self, mock_config):
        """In advisory mode, should never auto-consolidate."""
        mock_config['ONTOS_MODE'] = 'advisory'
        assert should_consolidate() == False

    # --- Dual Condition Tests ---

    def test_high_count_but_no_old_logs_skips(self, mock_config, mock_recent_logs):
        """Count > threshold but all logs recent: should NOT consolidate."""
        mock_config['ONTOS_MODE'] = 'automated'
        mock_config['LOG_RETENTION_COUNT'] = 5
        # Create 10 logs all from this week
        assert should_consolidate() == False

    def test_low_count_with_old_logs_skips(self, mock_config, mock_old_logs):
        """Count < threshold even with old logs: should NOT consolidate."""
        mock_config['ONTOS_MODE'] = 'automated'
        mock_config['LOG_RETENTION_COUNT'] = 50
        # Create 5 old logs (under threshold)
        assert should_consolidate() == False

    # --- CI Detection Tests ---

    def test_skips_in_github_actions(self, mock_config):
        """Should skip when GITHUB_ACTIONS env var is set."""
        mock_config['ONTOS_MODE'] = 'automated'
        with patch.dict(os.environ, {'GITHUB_ACTIONS': 'true'}):
            assert should_consolidate() == False

    def test_skips_in_gitlab_ci(self, mock_config):
        """Should skip when GITLAB_CI env var is set."""
        mock_config['ONTOS_MODE'] = 'automated'
        with patch.dict(os.environ, {'GITLAB_CI': 'true'}):
            assert should_consolidate() == False

    def test_skips_with_ci_env_var(self, mock_config):
        """Should skip when generic CI env var is set."""
        mock_config['ONTOS_MODE'] = 'automated'
        with patch.dict(os.environ, {'CI': 'true'}):
            assert should_consolidate() == False

    # --- Rebase/Cherry-pick Tests ---

    def test_skips_during_rebase(self, mock_config, mock_rebase_state):
        """Should skip when rebase-merge directory exists."""
        mock_config['ONTOS_MODE'] = 'automated'
        # Mock .git/rebase-merge exists
        assert should_consolidate() == False

    def test_skips_during_cherry_pick(self, mock_config, mock_cherry_pick_state):
        """Should skip when CHERRY_PICK_HEAD exists."""
        mock_config['ONTOS_MODE'] = 'automated'
        # Mock .git/CHERRY_PICK_HEAD exists
        assert should_consolidate() == False

    # --- Explicit Skip Tests ---

    def test_skips_with_ontos_skip_hooks_env(self, mock_config):
        """Should skip when ONTOS_SKIP_HOOKS=1."""
        mock_config['ONTOS_MODE'] = 'automated'
        with patch.dict(os.environ, {'ONTOS_SKIP_HOOKS': '1'}):
            assert should_consolidate() == False

    # --- Staging Tests ---

    def test_stage_only_ontos_files(self, mock_git):
        """Should stage only decision_history, archive, logs ‚Äî never git add -u."""
        stage_consolidated_files()
        # Verify git add was called with specific paths, not -u
        calls = mock_git.call_args_list
        assert not any('-u' in str(call) for call in calls)

    # --- Error Handling Tests ---

    def test_main_returns_zero_on_success(self):
        """Hook should return 0 on successful consolidation."""
        assert main() == 0

    def test_main_returns_zero_on_failure(self, mock_consolidation_failure):
        """Hook should return 0 even when consolidation fails."""
        assert main() == 0

    def test_main_returns_zero_on_exception(self, mock_exception):
        """Hook should return 0 even on unexpected exceptions."""
        assert main() == 0
```

### 7.2 Hook Installation Tests

**New File:** `tests/test_hook_installation.py`

```python
"""Tests for hook conflict detection (v2.5)."""

class TestHookInstallation:

    def test_detects_husky(self, mock_husky_project):
        """Should detect .husky/ directory and skip installation."""
        result = install_pre_commit_hook()
        assert "Husky detected" in captured_output

    def test_detects_pre_commit_framework(self, mock_pre_commit_project):
        """Should detect .pre-commit-config.yaml and provide YAML snippet."""
        result = install_pre_commit_hook()
        assert "pre-commit framework detected" in captured_output
        assert "repo: local" in captured_output

    def test_detects_existing_non_ontos_hook(self, mock_existing_hook):
        """Should prompt before overwriting non-Ontos hook."""
        # ... test prompts user
```

### 7.2 Integration Tests

**Manual Test Script:**

```bash
#!/bin/bash
# Test auto-consolidation flow

# Setup
cd /tmp
mkdir test-ontos && cd test-ontos
git init
cp -r /path/to/ontos/.ontos .
python3 ontos_init.py  # Select automated mode

# Create test logs (over threshold)
for i in {1..20}; do
    date=$(date -v-${i}d +%Y-%m-%d)
    cat > docs/logs/${date}_test-${i}.md << EOF
---
id: log_${date}_test_${i}
type: log
status: active
event_type: chore
impacts: []
---
# Test Log ${i}
EOF
done

# Make a change and commit
echo "test" > test.txt
git add .
git commit -m "test: trigger consolidation"

# Verify consolidation happened
ls docs/logs/        # Should have fewer logs
ls docs/archive/     # Should have archived logs
git log --oneline -1 # Should include consolidated files
```

---

## 8. Migration Notes

### For Existing Users

1. **No breaking changes** - Existing configs continue to work
2. **New hook on reinstall** - Run `python3 ontos_init.py` to install pre-commit hook
3. **Opt-in for prompted users** - Consolidation reminder is additive, not breaking

### For New Users

1. **Promise shown first** - Mode selection explains what they're getting
2. **Hooks installed automatically** - Both pre-commit and pre-push
3. **Default is prompted** - Safe, visible behavior for new users

---

## 9. Risks and Mitigations

| Risk | Impact | Mitigation |
|------|--------|------------|
| Pre-commit hook slows commits | Medium | Dual condition check is fast; consolidation only runs when needed |
| Consolidation fails mid-commit | Low | Hook returns 0 always via try/except wrapper |
| Existing pre-commit hook conflict | Medium | **Detect Husky/pre-commit framework, provide integration instructions** |
| Users confused by auto-staged files | Low | **Stage only Ontos files explicitly, never `git add -u`** |
| CI commits include consolidation | Medium | **CI environment detection skips hook automatically** |
| Rebase/cherry-pick contamination | Medium | **Detect special git operations and skip** |
| Count > threshold but no old logs | Low | **Dual condition prevents false alarms** |
| Hook crashes block commit | Low | **Try/except guarantees return 0** |

---

## 10. Success Metrics

1. **Quantitative**
   - Users in automated mode never have >20 active logs
   - Pre-commit hook adds <2s to commit time
   - Zero support issues about "left behind" consolidation files

2. **Qualitative**
   - Users understand mode promises after setup
   - Prompted mode users see consolidation reminders
   - No complaints about unexpected behavior

---

## 11. Future Considerations

### v2.6: Deferred from Architectural Review

These items were identified during review but deferred to reduce v2.5 scope:

| Item | Rationale for Deferral |
|------|------------------------|
| **Scriptable `ontos_check.py`** | Context map warning solves 80% case; full script can wait |
| **`ontos_unarchive.py` rollback** | Archives are in git history; manual workaround exists |
| **Smart trigger (staged changes check)** | Performance optimization; requires more design |
| **Git worktree support** | Edge case; needs research on config isolation |

### v2.6 and Beyond

- **Smart consolidation timing:** Only consolidate if commit touches docs/ directory
- **Consolidation dry-run at setup:** Show what would be consolidated during mode selection
- **Agent-assisted consolidation:** In prompted mode, agent could offer to consolidate inline
- **Performance at scale:** Optimize for projects with 500+ logs

---

## 12. Open Questions ‚Äî RESOLVED

All architectural questions have been resolved through multi-model review (Claude, Codex, Gemini).

---

### Q1: Threshold Logic ‚Äî Count vs Age Mismatch

**RESOLVED: Option C (Dual Condition)**

Trigger when count > threshold AND old logs exist. Prevents confusing "nothing to consolidate" messages.

```python
def should_consolidate() -> bool:
    if get_log_count() <= threshold:
        return False
    return len(get_logs_older_than(threshold_days)) > 0
```

**Rationale:** All reviewers agreed count alone causes false alarms. Dual condition honors both metrics.

---

### Q2: Repeated Consolidation on Multiple Commits

**RESOLVED: Option A + Verbose Mode**

Silent when nothing to consolidate. Add `ONTOS_VERBOSE=1` env var for debugging.

**Rationale:** Unanimous agreement. Clean output for users, debug path for troubleshooting.

---

### Q3: Unicode Box Drawing in Terminal

**RESOLVED: Option B (ASCII-only)**

Use `+`, `-`, `|` instead of `‚ïî`, `‚ïë`, `‚ïö`. Reliability over aesthetics.

**Rationale:** Unanimous agreement. Ontos targets diverse environments (SSH, CI, Windows CMD).

---

### Q4: Existing Pre-commit Hook Conflicts

**RESOLVED: Option C + Framework Detection**

Detect Husky (`.husky/`) and pre-commit framework (`.pre-commit-config.yaml`). Provide integration instructions instead of overwriting.

**Rationale:** All reviewers flagged this as HIGH priority. Don't break user workflows.

---

### Q5: Agent Reminder Enforcement

**RESOLVED: Context Map Warning (v2.5) + Scriptable Check (v2.6)**

Add `check_consolidation_status()` to `ontos_generate_context_map.py`. Warning prints at activation. Defer `ontos_check.py` to v2.6.

**Rationale:** Gemini's insight ‚Äî agents always activate, so context map warning is reliable. Full script can wait.

---

### Q6: File Changes Summary ‚Äî Keep or Remove?

**RESOLVED: Option B**

Keep file list, remove line estimates (always wrong by implementation time).

**Rationale:** Unanimous agreement.

---

## 13. Reviewer Responses ‚Äî Summary

Three models reviewed this plan. Full reviews available in `/strategy/v2.5/`.

### Claude Opus 4.5 (V1_Claude_on_v2.5.md)
**Date:** 2025-12-17

**Key Contributions:**
- Identified CRITICAL `git add -u` staging issue
- Proposed CI environment detection
- Proposed rebase/cherry-pick detection
- Proposed `ontos_check.py` for prompted mode
- Proposed `ontos_unarchive.py` for rollback (deferred to v2.6)

**Verdict:** Proceed with implementation after addressing critical issues.

---

### Codex (V1_Codex on v2.5.md)
**Date:** 2025-12-17

**Key Contributions:**
- Confirmed `git add -u` risk
- Emphasized try/except wrapper for guaranteed return 0
- Noted trigger/behavior mismatch (count vs age)
- Suggested CI safety check

**Verdict:** Address safety issues, then proceed.

---

### Gemini (V1_Gemini on v2.5.md)
**Date:** 2025-12-17

**Key Contributions:**
- Proposed smart trigger (only run if logs touched) ‚Äî deferred to v2.6
- Proposed verbose mode (`ONTOS_VERBOSE=1`)
- Key insight: Context map warning solves prompted mode without new script

**Verdict:** Excellent plan. Proceed with recommendations.

---

### Synthesis

| Issue | Claude | Codex | Gemini | Resolution |
|-------|--------|-------|--------|------------|
| `git add -u` danger | CRITICAL | CRITICAL | ‚Äî | **Fixed: Explicit staging** |
| CI detection | HIGH | HIGH | Mentioned | **Added** |
| Hook conflicts | HIGH | HIGH | HIGH | **Added detection** |
| Count vs Age | Option B | Dual | Option C | **Option C (dual)** |
| Rebase detection | MEDIUM | ‚Äî | ‚Äî | **Added** |
| Prompted mode | ontos_check.py | ‚Äî | Context map warning | **Context map warning** |
| Unicode | ASCII | ‚Äî | ASCII | **ASCII-only** |

---

## 14. Approval Checklist

- [x] Architecture review (pre-commit vs pre-push decision) ‚Äî **APPROVED**
- [x] Open questions resolved (Section 12) ‚Äî **ALL RESOLVED**
- [x] Multi-model review Round 1 (Claude, Codex, Gemini) ‚Äî **COMPLETE**
- [x] Multi-model review Round 2 (Claude, Codex, Gemini) ‚Äî **ALL APPROVED**
- [x] Critical safety issues addressed ‚Äî **FIXED**
  - [x] `git add -u` replaced with explicit staging
  - [x] CI environment detection added
  - [x] Hook conflict detection added
  - [x] Try/except wrapper guarantees return 0
- [x] Promise messaging review (ASCII-only) ‚Äî **APPROVED**
- [x] Test plan updated with new test cases ‚Äî **COMPLETE**
- [x] **Final sign-off** ‚Äî **APPROVED**
- [x] Ready for implementation ‚Äî **YES**

---

**Status:** ‚úÖ APPROVED FOR IMPLEMENTATION

**Implementation Notes:**
- Centralize helper functions (`get_log_count`, `get_logs_older_than`) in `ontos_lib.py`
- Fix test plan section numbering (two 7.2 sections)

**Architect:** Claude Code (Opus 4.5)
**Date:** 2025-12-17
**Version:** 2.0 (Final)

---

*End of v2.5 Implementation Plan*
